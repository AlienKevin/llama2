

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((Model, Action) -> Model)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((Model, Action) -> Model)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:18.206
 fun:17.7266
 :16.6542
    :13.6801
  :13.6608
   :13.5554
 function:13.2417	rejected
                :12.9429
 (:12.3215
      :11.9996
 \:11.8668	rejected
        :11.5471
     :11.4724
         :11.0756
            :11.0429
 match:10.9433	rejected
	:10.9051	rejected
          :10.8512
 #:10.658	rejected
             :10.6049
 {:10.3904	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =


LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((Model, Action) -> Model)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((Model, Action) -> Model)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 :19.3266
   :16.8366
 fun:16.3646
  :15.0914

:14.8473
fun:14.466
    :13.4796
	:13.258	rejected
 let:12.9453
     :12.1675
let:12.0329
#:11.5486	rejected
      :11.3365
 func:11.3294	rejected
func:11.1278	rejected
(*:11.0189	prefix accepted:(
(:11.0189
 match:10.9031	rejected
match:10.7867	rejected
 switch:10.6599	rejected
       :10.6478

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
 

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
 
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((Model, Action) -> Model)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((Model, Action) -> Model)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 fun:20.8762
 let:14.7807
 match:12.6966	rejected
 (:12.6416
 function:12.5476	rejected
 switch:12.2412	rejected
 #:11.8769	rejected
 (*:11.674	prefix accepted: (
 {:11.2721	rejected
 |:11.0077	rejected
 func:10.7422	rejected
 f:10.2072
 //:10.0736	rejected
 lambda:10.055	rejected
 proc:10.0373	rejected
 ((:9.86111	prefix accepted: (
 self:9.86105	rejected
 fn:9.78153	rejected
 ~:9.75935	rejected
 if:9.74108
 model:9.48368

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 model:16.5655
 (:16.4124
 m:16.1156
 ((:15.0048	prefix accepted: (
 {:13.8016	rejected
 ({:13.5451	prefix accepted: (
 state:13.3815
 old:13.2141
 mo:12.1043
 prev:12.0415
 [:11.7551
(:11.689
 current:11.6329
 s:11.359
 st:11.3223
 init:11.2113
 x:11.1298
 t:11.0295
 md:10.7659
 mode:10.7616
((:10.6243	prefix accepted:(

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized pattern
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: (([[String]], String, [String]), (SelectEmoji(String) + StampEmoji((Int, Int)) + ClearCell((Int, Int)) + ClearGrid + FillRow(Int)))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in
  LSP: Info: BidiCtx: Cls: Parenthesized pattern
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Parenthesized pattern
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: (([[String]], String, [String]), (SelectEmoji(String) + StampEmoji((Int, Int)) + ClearCell((Int, Int)) + ClearGrid + FillRow(Int)))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in
  LSP: Info: BidiCtx: Cls: Parenthesized pattern
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "()" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= completions | new-tokens

Top 20 Logits:
grid:17.1706
model:15.0447
old:13.7832
g:13.4469
m:12.8239
current:12.2839
em:11.7197
prev:11.3726
state:11.3397
_,:11.259	prefix accepted:_
emo:10.6226
p:10.2829
((:10.2687	prefix accepted:(

:10.2118
curr:10.1181
x:9.95739
cur:9.77702
init:9.73778
gs:9.67178
initial:9.59276
 grid:9.52008

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <grid>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {grid: (Model, Action), update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: grid
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: grid
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
,:18.1236
_:12.8089
0:12.5013
Model:12.0481
 ,:11.9546
1:11.8182
',:11.8172	rejected
_,:11.403	prefix accepted:_
Old:11.3958
State:11.2817
::11.2285	rejected
Init:10.9808
 as:10.6849	rejected
Before:10.5392
M:10.5101
To:10.4614
 ::10.2759	rejected
In:10.0926
2:9.52497
E:9.46956
,(:9.34999	prefix accepted:,

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: (([[String]], String, [String]), (SelectEmoji(String) + StampEmoji((Int, Int)) + ClearCell((Int, Int)) + ClearGrid + FillRow(Int)))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {grid: Model, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: (([[String]], String, [String]), (SelectEmoji(String) + StampEmoji((Int, Int)) + ClearCell((Int, Int)) + ClearGrid + FillRow(Int)))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {grid: Model, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {grid: Model, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 selected:15.7351
 current:14.4194
 em:13.7951
 sel:13.1677
 cur:12.9245
 curr:12.4851
 selection:11.9999
 e:11.8642
 _,:11.6347	prefix accepted: _
 select:11.3031
 currently:11.1049
selected:11.0297
 prev:10.4767
 old:10.4237
 s:10.1602
 active:10.1075
 c:9.98871
emo:9.80507
 chosen:9.59139
current:9.5486
 last:9.30573

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selected

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selected
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <selected>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {selected: Action, grid: Model, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: selected
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: selected
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
E:19.4713
,:16.7407
_:16.7394
Em:15.9093
emo:13.03
Char:11.9303
Color:11.0164
Value:10.9429
 ,:10.6396
Item:10.6285
Cell:10.5203
_,:10.3648	prefix accepted:_
EM:9.91523
em:9.85771
G:9.55227
Image:9.46119
S:9.43538
Val:9.425
Model:9.37372
-:9.33297	rejected
T:9.29125

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedE

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedE
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <selectedE>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {selectedE: Action, grid: Model, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: selectedE
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: selectedE
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
mo:25.755
lem:15.5936
,:14.0057
omo:12.1336
emo:12.1229
MO:12.116
mu:11.4823
o:11.0971
mm:11.0171
sm:10.1752
imo:10.1515
mi:10.1211
Mo:9.91603
mt:9.86806
md:9.83809
mod:9.7959
ma:9.7435
le:9.59761
no:9.30386
мо:9.22868	rejected
mon:9.21145

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmo

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmo
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <selectedEmo>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {selectedEmo: Action, grid: Model, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: selectedEmo
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: selectedEmo
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
ji:23.2719
ij:15.8544
,:15.3292
jo:13.5862
iji:12.4949
j:12.1318
J:10.8756
ii:10.7935
i:10.6886
 ji:10.6562	rejected
yi:10.2125
je:10.0311
jih:9.90477
qi:9.76767
 ,:9.67861
ijo:8.92604
ci:8.83182
ja:8.65438
ip:8.48661
yj:8.48161
jin:8.1888

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <selectedEmoji>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {selectedEmoji: Action, grid: Model, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: selectedEmoji
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: selectedEmoji
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
,:18.9489
 ,:12.9671
In:12.084
),:11.8821
_,:11.077	prefix accepted:_
Before:11.0725
To:10.9906
',:10.9783	rejected
Id:10.5916
Name:10.5891
Or:10.5025
Index:10.4957
P:10.2299
1:10.1698
Value:10.1235
::10.0497	rejected
Option:10.0019
Model:9.9091
0:9.79937
 as:9.73698	rejected
Opt:9.65922

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: (?, ?, ?)
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Prod [(Var "Model"); (Var "Action")]);
           syn =
           (Prod [(Unknown Internal); (Unknown Internal); (Unknown Internal)])})))
  LSP: Info: Typing Context: {selectedEmoji: ?, grid: ?, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in
  LSP: Info: ALL errors:
Error in term:
  (grid, selectedEmoji, ?)
Nature of error: Expecting type (Model, Action) but got inconsistent type (?, ?, ?)
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: (?, ?, ?)
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Prod [(Var "Model"); (Var "Action")]);
           syn =
           (Prod [(Unknown Internal); (Unknown Internal); (Unknown Internal)])})))
  LSP: Info: Typing Context: {selectedEmoji: ?, grid: ?, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in
  LSP: Info: ALL errors:
Error in term:
  (grid, selectedEmoji, ?)
Nature of error: Expecting type (Model, Action) but got inconsistent type (?, ?, ?)
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {selectedEmoji: ?, grid: ?, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in
  LSP: Info: ALL errors:
Error in term:
  (grid, selectedEmoji, ?)
Nature of error: Expecting type (Model, Action) but got inconsistent type (?, ?, ?)
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 available:16.4354
 em:14.87
 all:13.7688
 avail:11.6832
 av:11.5372
 possible:11.3609
 select:11.3237
 valid:11.1179
 _:11.0434
 allowed:10.8957
 list:10.5978
 remaining:10.5791
 _):10.4608	prefix accepted: _
 un:10.2342
 _,:9.70125	prefix accepted: _
 options:9.58678
 e:9.35574
 other:9.31271
 emot:9.17772
 a:9.08674
 choices:8.97032

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, available

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, available
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <available>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {available: ?, selectedEmoji: ?, grid: ?, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in
  LSP: Info: ALL errors:
Error in term:
  (grid, selectedEmoji, available)
Nature of error: Expecting type (Model, Action) but got inconsistent type (?, ?, ?)
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: available
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: available
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | "," | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
Em:20.9219
E:16.8543
),:15.2116
):13.2837
_:12.4545
List:11.6799
,:11.1668
Options:11.0086
em:10.3876
G:10.1466
Selected:9.97522
Grid:9.93232
S:9.82491
Cho:9.69336
F:9.61553
EM:9.37972
M:9.27777
Items:9.19501
P:9.1189
In:9.07574
)::8.98623	prefix accepted:)

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEm

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEm
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <availableEm>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {availableEm: ?, selectedEmoji: ?, grid: ?, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in
  LSP: Info: ALL errors:
Error in term:
  (grid, selectedEmoji, availableEm)
Nature of error: Expecting type (Model, Action) but got inconsistent type (?, ?, ?)
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: availableEm
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: availableEm
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | "," | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
oj:22.3854
jo:14.3347
os:13.4522
otic:12.2155
otes:11.6747
j:11.6223
ij:11.5283
og:11.3744
js:11.3724
jos:10.9705
),:10.1565
ijo:9.97693
ot:9.97567
ok:9.88169
op:9.50012
):9.43644
ote:9.30568
em:9.00574
oo:8.95605
ps:8.79078
ji:8.72406

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmoj

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmoj
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <availableEmoj>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {availableEmoj: ?, selectedEmoji: ?, grid: ?, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in
  LSP: Info: ALL errors:
Error in term:
  (grid, selectedEmoji, availableEmoj)
Nature of error: Expecting type (Model, Action) but got inconsistent type (?, ?, ?)
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: availableEmoj
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: availableEmoj
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | "," | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
is:23.5639
ies:15.3044
il:12.7475
),:12.4669
ii:11.7326
):11.7147
Is:11.5156
iss:11.0769
ip:10.7565
lis:10.6465
l:10.5741
ie:10.5163
ios:10.2307
os:9.39512
ij:9.22015
tis:9.20495
isi:9.17194
ise:9.16222
ic:9.16137
es:9.13369
icons:9.11814

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <availableEmojis>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {availableEmojis: ?, selectedEmoji: ?, grid: ?, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in
  LSP: Info: ALL errors:
Error in term:
  (grid, selectedEmoji, availableEmojis)
Nature of error: Expecting type (Model, Action) but got inconsistent type (?, ?, ?)
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: availableEmojis
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: availableEmojis
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | "," | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
),:19.6889
):14.6449
 as:14.1733	rejected
,:12.6021
 ),:11.3335
 ::10.804
 =:10.5807	rejected
::10.3385
)::10.1817	prefix accepted:)
)=:10.0799	prefix accepted:)
_:10.0321
=:9.81921	rejected
List:9.72789
),(:9.66595	prefix accepted:),
'),:9.05847	rejected
In:9.05146
As:8.94014
)->:8.32978	prefix accepted:)
 :8.31266
To:8.24312
),\:8.22662	prefix accepted:),

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis),

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis),
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: (([[String]], String, [String]), (SelectEmoji(String) + StampEmoji((Int, Int)) + ClearCell((Int, Int)) + ClearGrid + FillRow(Int)))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: (([[String]], String, [String]), (SelectEmoji(String) + StampEmoji((Int, Int)) + ClearCell((Int, Int)) + ClearGrid + FillRow(Int)))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 action:16.8168
 a:15.6226
 act:14.493
 :11.7843
 (:11.683

:11.6499
 e:11.3972
 actions:11.1803
 x:11.0356
 ac:10.631
 msg:10.5175
action:10.5096
 next:10.4172
 event:10.2816
 new:10.1754
 message:9.95512
 m:9.81826
 input:9.65436
 current:9.56314
 _:9.54669
 v:9.50246

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <action>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: action
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: action
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | "->"
root ::= completions | new-tokens

Top 20 Logits:
 ->:18.5928
 :14.0908
->:14.0494
 =>:13.2387	rejected
_:11.9394
::11.7948	rejected

:11.7425
 =:11.1229	rejected
 ::11.0638	rejected
':10.8873	rejected
0:10.4784
 +:10.4556	rejected
  :10.4193
 →:10.3245	rejected
1:10.2275
,:10.1542
 -:9.77199
 -->:9.63667	prefix accepted: -
 {:9.61805	rejected
   :9.57969
2:9.32024

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Model, Action) -> Model)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:19.2003
 :17.6364
 match:15.4381	rejected
  :15.3512
   :15.2952
    :14.9517
 case:13.4687
      :13.1409
 (:12.9014
                :12.8283
        :12.3362
 {:12.2178	rejected
     :12.1372
 action:12.1074
         :11.9475
 #:11.8061	rejected
          :11.7111
	:11.6754	rejected
 let:11.6028
 (*:11.6019	prefix accepted: (
 ?:11.3277	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->


LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Model, Action) -> Model)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
   :21.1202
    :16.9628
 :16.1604
  :15.7784

:15.3489
     :15.016
      :14.4091
case:14.0902
       :13.3926
match:13.3786	rejected
        :13.3126
         :13.1944
	:13.1936	rejected
 case:12.0883
           :11.9161
 match:11.9097	rejected
          :11.8646
                :11.7953
#:11.1903	rejected
switch:11.1767	rejected
            :11.0152

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
   

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
   
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Model, Action) -> Model)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 case:18.7029
 match:16.9992	rejected
 let:15.2662
 switch:12.9739	rejected
 if:12.7743
 (:12.577
 print:12.2927	rejected
 #:11.2963	rejected
 action:11.1125
 {:11.0565	rejected
 (*:10.9805	prefix accepted: (
 begin:10.8422	rejected
 model:10.8261
 var:10.7202	rejected

:10.2165
 open:9.89012	rejected
 printf:9.71778	rejected
 pair:9.53622	rejected
 List:9.535	rejected
 fun:9.43754
 Model:9.37838	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <case end<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 action:18.4402
 selected:12.2468
 (:11.9252
 :11.8482

:10.6975
 Action:10.4192	rejected
 grid:10.2379
(:10.1847
 actions:10.1195	rejected
 !:10.1186
 not:9.99469	rejected
 let:9.93041
 ::9.92338	rejected
 s:9.84577
::9.7959	rejected
 @:9.70482	rejected
 update:9.69979
 List:9.64772	rejected
 show:9.55155	rejected
 type:9.54494
_:9.50457	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <action>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (SelectEmoji(String) + StampEmoji((Int, Int)) + ClearCell((Int, Int)) + ClearGrid + FillRow(Int))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: action
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Generating Completions for prefix: action
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:18.4624
 :17.305
 of:15.8482	rejected
  :14.9838
    :14.6047
      :13.5921
   :13.3955
                :12.9676
 in:12.8709	rejected
 with:12.7886	rejected
 {:12.6899	rejected
::12.6009
 |:12.5492
,:12.4846
     :12.2912
 ::12.1212
        :12.0957
         :11.8526
 match:11.8398	rejected
 #:11.8113	rejected
          :11.7318

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action


LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <action>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (SelectEmoji(String) + StampEmoji((Int, Int)) + ClearCell((Int, Int)) + ClearGrid + FillRow(Int))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
   :18.1025
    :16.1796
     :14.7705

:14.6513
      :14.0676
        :13.4082
  :13.3912
 :13.265
       :12.1093
         :11.9792
	:11.9004	rejected
|:11.6
          :11.4158
#:11.2752	rejected
 |:10.9521
                :10.766
            :10.6043
           :10.103
(*:10.0765	prefix accepted:(
             :9.82527
              :9.29058

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
   

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
   
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <action>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (SelectEmoji(String) + StampEmoji((Int, Int)) + ClearCell((Int, Int)) + ClearGrid + FillRow(Int))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:21.0229
 #:15.3355	rejected
 +:13.9619
 (*:13.9618	prefix accepted: (
 //:12.8054	prefix accepted: /
 match:12.3531	rejected
 ~:12.3362	rejected
 /*:11.8734	prefix accepted: /
 {:11.7074	rejected

:11.5579
 ||:11.5541	prefix accepted: |
 ##:11.1948	rejected
 /:12.8054
 <:10.9813
 *:10.9781
 (+:10.9753	prefix accepted: (
 `:10.9472	rejected
 #{:10.9317	rejected
 -:10.6489
 %:10.6117	rejected
 ::10.5023

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    |

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    |
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 Select:18.5865
 St:16.0524
 Clear:14.3744
 +:13.9389	rejected
 _:12.0101
 F:11.8787
 Action:11.6881	rejected
Select:11.5428
 (:11.4897
 :11.3252
 select:10.8137
 Selected:10.4204	rejected
 #:10.4125	rejected
 ~:9.8799	rejected
 None:9.87854	rejected
+:9.70513	rejected
 action:9.57045
St:9.3678
 @:9.23409	rejected
 Selection:9.14629	rejected
 Some:9.07234	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | Select

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | Select
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Select>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "Select"))))
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  Select
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Select
LSP: Generating Completions for prefix: Select
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Emoji"
root ::= completions

Top 20 Logits:
E:20.4054
(:13.1553	rejected
Em:11.6783
_:11.1529	rejected
New:10.9741	rejected
 em:10.6703	rejected
e:10.5904	rejected
 new:10.0445	rejected
emo:9.70821	rejected
Action:9.5878	rejected
(_:9.34518	rejected
A:8.97729	rejected
 E:8.94045	rejected
Next:8.34707	rejected
 (:8.22368	rejected
 a:8.13617	rejected
G:8.08842	rejected
Color:7.86363	rejected
First:7.78626	rejected
 e:7.68273	rejected
((:7.66384	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectE

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectE
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <SelectE>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "SelectE"))))
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  SelectE
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: SelectE
LSP: Generating Completions for prefix: SelectE
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "moji"
root ::= completions

Top 20 Logits:
mo:25.6211
emo:16.3701	rejected
MO:14.3907	rejected
omo:14.2158	rejected
mm:12.5011	rejected
мо:11.8815	rejected
 mo:11.8568	rejected
lem:11.6038	rejected
imo:11.5398	rejected
ma:11.3845	rejected
mu:11.3529	rejected
amo:11.3167	rejected
mi:11.3153	rejected
m:11.1338
mor:10.9553	rejected
mit:10.4544	rejected
Mo:10.428	rejected
cho:10.3648	rejected
no:10.2298	rejected
o:9.83502	rejected
po:9.81506	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmo

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmo
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <SelectEmo>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "SelectEmo"))))
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  SelectEmo
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: SelectEmo
LSP: Generating Completions for prefix: SelectEmo
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ji"
root ::= completions

Top 20 Logits:
ji:25.3898
 ji:14.1201	rejected
jo:14.1153	rejected
ij:12.9812	rejected
iji:12.9215	rejected
J:12.6565	rejected
je:12.4807	rejected
j:12.3099
ja:11.9106	rejected
yi:11.677	rejected
 Ji:11.58	rejected
(:10.9244	rejected
ju:10.8212	rejected
i:10.67	rejected
qi:10.2815	rejected
jih:9.77118	rejected
jin:9.71061	rejected
ii:9.35825	rejected
zi:9.33976	rejected
ci:9.28055	rejected
ui:9.25288	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <SelectEmoji>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (String -> (SelectEmoji(String) + StampEmoji((Int, Int)) + ClearCell((Int, Int)) + ClearGrid + FillRow(Int)))
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Var "Action");
           syn = (Arrow ((Var "Emoji"), (Var "Action")))})))
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  SelectEmoji
Nature of error: Expecting type Action but got inconsistent type (Emoji -> Action)
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: SelectEmoji
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: SelectEmoji
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
(:18.3473
 em:15.7419	rejected
 new:14.1074	rejected
 e:14.0282	rejected
(":12.9999	prefix accepted:(
(_:12.0666	rejected
 (:11.5351
 next:11.2116	rejected
 selected:11.1517	rejected
 x:10.2643	rejected
 s:9.9972	rejected
 a:9.71175	rejected
 chosen:9.46958	rejected
 selection:9.42915	rejected
 _:9.42655	rejected
 sel:9.36269	rejected
(::9.17867	prefix accepted:(
 :9.16204
(':9.06642	prefix accepted:(
 c:9.01399	rejected
 select:8.98	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (SelectEmoji(String) + StampEmoji((Int, Int)) + ClearCell((Int, Int)) + ClearGrid + FillRow(Int))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (SelectEmoji(String) + StampEmoji((Int, Int)) + ClearCell((Int, Int)) + ClearGrid + FillRow(Int))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Emoji
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Emoji
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "()" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= completions | new-tokens

Top 20 Logits:
emo:17.4298
new:16.2894
e:15.3269
selected:15.0801
em:14.078
next:13.3287
x:13.1146
s:12.3835
a:11.9476
select:11.5725
ch:10.8374
value:10.7502
sel:10.7455
target:10.7153
n:10.679
v:10.5868
c:10.5713
current:10.3934
Selected:10.3292	rejected
selection:10.1837
i:10.0445

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emo

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emo
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <emo>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Emoji
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {emo: Emoji, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Emoji
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: emo
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: emo
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
ji:22.169
):15.6181
ij:12.7418
jo:11.8837
_:11.7338
To:11.0488
iji:10.7343
 ji:10.7235	rejected
){:10.6111	prefix accepted:)
)::10.5674	prefix accepted:)
Name:10.4209
J:10.3639
)->:10.3517	prefix accepted:)
jih:10.1608
ja:9.97072
1:9.94435
je:9.89413
 ::9.60915	rejected
 ->:9.55967	rejected
Selected:9.37141
ii:9.3113

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <emoji>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Emoji
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {emoji: Emoji, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Emoji
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: emoji
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: emoji
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
):17.5974
To:15.0323
Selected:14.0349
'):13.8658	rejected
)::12.033	prefix accepted:)
Name:11.8724
In:11.7674
New:11.7554
)->:11.6183	prefix accepted:)
_:11.2621
Key:11.1484
From:11.1023
_):11.0961	prefix accepted:_
Id:10.7109
),:10.6897
Choice:10.3875
Selection:10.2804
Index:10.2582
::10.204	rejected
Value:10.149
T:9.85336

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji)

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (SelectEmoji(String) + StampEmoji((Int, Int)) + ClearCell((Int, Int)) + ClearGrid + FillRow(Int))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {emoji: Emoji, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:19.4704
  :14.5431
 ->:14.2704	rejected
    :14.1908
     :14.0975
      :14.035
 :13.7614
                :13.7135
       :13.7126
 when:13.5503	rejected
         :13.5073
        :13.4462
   :13.2512
          :13.1904
           :12.9968
 if:12.7699	rejected
             :12.7492
            :12.6212
              :12.3173

:12.2929
               :12.0146

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) =>

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) =>
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {emoji: Emoji, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: emoji action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "emoji" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 (:17.3858

:16.3901
 :15.991
 grid:14.8424
  :14.5108
                :13.6005
 if:13.4654
    :13.13
 [:12.672
            :12.5976
     :12.5472
 ?:12.522	rejected
      :12.3751
        :12.2688
 model:12.22
 ((:12.1635	prefix accepted: (
              :12.0538
 {:11.983	rejected
 #:11.9691	rejected
 List:11.9392	rejected
         :11.8395

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {emoji: Emoji, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {emoji: Emoji, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {emoji: Emoji, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: emoji action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: emoji action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "emoji" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
grid:18.0168

:15.6279
 grid:14.1584
?,:12.7821	rejected
model:12.7771
  :11.9872
List:11.6808	rejected
 :11.4678
#:11.2713	rejected
update:10.7101
f:10.7057
    :10.5893
Grid:10.5525	rejected
_,:10.4602	rejected
                :10.4026
g:10.2872
 ?:10.2343	rejected
selected:9.98663
 #:9.95663	rejected
#,:9.94122	rejected
   :9.86893

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <grid>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [[String]]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = (Var "Model"); syn = (Var "Grid")})))
  LSP: Info: Typing Context: {emoji: Emoji, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  grid
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: grid
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: grid
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: emoji action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:20.2559
 ,:14.3949
                :11.9195
      :11.5671
        :11.5519
       :11.5501
  :11.5233
    :11.5228
          :11.335
     :11.3193
::10.9915
.:10.9012	rejected
   :10.8737
            :10.8223
           :10.8141
 +:10.7273
             :10.6556
         :10.5936
,,:10.5193	prefix accepted:,
 :10.4079
              :10.3575

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model");
           syn = (Prod [(Var "Grid"); (Unknown Internal)])})))
  LSP: Info: Typing Context: {emoji: Emoji, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  grid, ?
Nature of error: Expecting type Model but got inconsistent type (Grid, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model");
           syn = (Prod [(Var "Grid"); (Unknown Internal)])})))
  LSP: Info: Typing Context: {emoji: Emoji, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  grid, ?
Nature of error: Expecting type Model but got inconsistent type (Grid, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {emoji: Emoji, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  grid, ?
Nature of error: Expecting type Model but got inconsistent type (Grid, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: emoji action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: emoji action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "emoji" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 em:20.1718
emo:12.593
 action:12.5799
 if:12.4639
 List:12.3021	rejected
 e:12.1089
 :11.7897
                :11.7413
  :11.2391
 select:11.0825
 Some:10.9676	rejected
    :10.8598
 Em:10.5746	rejected
 selected:10.4416
      :10.3469
       :10.3336
          :10.238

:10.1337
em:10.1268
         :10.1056
 (:10.1039

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, em

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, em
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <em>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "em"))
  LSP: Info: Typing Context: {emoji: Emoji, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  em
Nature of error: Variable em is not bound  
Error in term:
  grid, em
Nature of error: Expecting type Model but got inconsistent type (Grid, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: em
LSP: Generating Completions for prefix: em
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: emoji action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "oji"
root ::= completions

Top 20 Logits:
o:21.3675
oi:11.1529	rejected
mo:11.1161	rejected
oj:10.7091
jo:10.141	rejected
oto:10.1246	rejected
ji:9.67991	rejected
oo:9.59347	rejected
,:9.21141	rejected
po:9.08762	rejected
omo:8.9672	rejected
otion:8.95969	rejected
oin:8.71746	rejected
 o:8.65492	rejected

:8.56315	rejected
iji:8.32874	rejected
pto:8.2146	rejected
ajo:8.07898	rejected
ijo:7.9016	rejected
i:7.60507	rejected
emo:7.57762	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emo

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emo
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <emo>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "emo"))
  LSP: Info: Typing Context: {emoji: Emoji, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  emo
Nature of error: Variable emo is not bound  
Error in term:
  grid, emo
Nature of error: Expecting type Model but got inconsistent type (Grid, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: emo
LSP: Generating Completions for prefix: emo
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: emoji action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ji"
root ::= completions

Top 20 Logits:
ji:27.1663
iji:16.1608	rejected
jo:15.2377	rejected
 ji:14.7296	rejected
ja:14.3799	rejected
je:13.3072	rejected
ij:12.9697	rejected
jih:11.8934	rejected
,:11.6315	rejected
 Ji:11.5456	rejected
js:11.4706	rejected
ii:11.3073	rejected
ijo:11.2876	rejected
qi:10.9625	rejected
):10.8266	rejected
json:10.4776	rejected
ije:10.2661	rejected
yi:10.2251	rejected
J:10.148	rejected
ject:9.7767	rejected
ija:9.48257	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <emoji>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: String
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {emoji: Emoji, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  grid, emoji
Nature of error: Expecting type Model but got inconsistent type (Grid, Emoji)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: emoji
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: emoji
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: emoji action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:19.9216
 ,:14.3386
                :11.9831
):11.4321
',:11.3227	rejected
  :11.279
,\:10.8275	prefix accepted:,
 \:10.7942
 :10.4393
.:10.2397	rejected
    :10.2377
     :10.1944
 +:10.1649
   :10.0387
            :9.93446
),:9.90212	prefix accepted:)
      :9.88546
 @:9.85855
        :9.79775
             :9.78404
       :9.77869

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {emoji: Emoji, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {emoji: Emoji, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Emoji]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {emoji: Emoji, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: emoji action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: emoji action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "emoji" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 available:18.7661
 [:13.9219
  :13.1732
 :13.1597
available:12.8592
 List:12.7665	rejected
    :12.6535
 selected:12.5718
                :12.0941
     :12.0387
       :11.936
        :11.8806
         :11.5854
          :11.5083
   :11.3774
      :11.33
            :11.0546
 em:10.7686
 Em:10.6968	rejected
              :10.4242
 select:10.3206

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, available

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, available
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <available>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Emoji]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "available"))
  LSP: Info: Typing Context: {emoji: Emoji, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  available
Nature of error: Variable available is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: available
LSP: Generating Completions for prefix: available
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: emoji action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Emojis"
root ::= completions

Top 20 Logits:
Em:23.0389
E:12.9672
_:12.8659	rejected
em:11.9839	rejected
 Em:11.2088	rejected
):11.102	rejected
EM:10.9814	rejected
 em:10.4936	rejected
Om:9.96988	rejected
M:9.70169	rejected
List:9.55515	rejected
Im:9.47559	rejected
.:9.36021	rejected
Emp:9.11553	rejected
Er:9.06976	rejected
Sm:9.02374	rejected
G:8.99777	rejected
(:8.59947	rejected
Ed:8.54327	rejected
A:8.5273	rejected
Sim:8.51501	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEm

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEm
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <availableEm>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Emoji]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "availableEm"))
  LSP: Info: Typing Context: {emoji: Emoji, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  availableEm
Nature of error: Variable availableEm is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: availableEm
LSP: Generating Completions for prefix: availableEm
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: emoji action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ojis"
root ::= completions

Top 20 Logits:
oj:31.667
jos:18.1317	rejected
ij:15.8562	rejected
j:15.469	rejected
jo:15.2008	rejected
oz:15.1048	rejected
ok:14.086	rejected
o:13.3908
oi:13.1802	rejected
om:13.1502	rejected
ois:12.9924	rejected
jm:12.7338	rejected
oy:12.6924	rejected
uj:12.1088	rejected
os:12.0306	rejected
aj:11.9966	rejected
ej:11.9805	rejected
imos:11.6935	rejected
obj:11.4119	rejected
otos:11.2427	rejected
og:11.2137	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmoj

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmoj
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <availableEmoj>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Emoji]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "availableEmoj"))
  LSP: Info: Typing Context: {emoji: Emoji, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  availableEmoj
Nature of error: Variable availableEmoj is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: availableEmoj
LSP: Generating Completions for prefix: availableEmoj
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: emoji action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "is"
root ::= completions

Top 20 Logits:
is:25.5339
ins:17.5492	rejected
i:13.8982
ips:13.5303	rejected
ies:13.5161	rejected
Is:13.3511	rejected
ils:12.4464	rejected
ians:12.2755	rejected
iss:12.1009	rejected
ios:12.0129	rejected
ions:11.875	rejected
ij:11.8705	rejected
ias:11.7897	rejected
isi:11.7538	rejected
js:11.6025	rejected
ius:11.502	rejected
ís:11.212	rejected
 is:11.1435	rejected
si:11.1051	rejected
ists:11.073	rejected
irs:11.0136	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <availableEmojis>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Emoji]
  LSP: Info: Seft type: [String]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {emoji: Emoji, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: availableEmojis
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: availableEmojis
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: emoji action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
):21.324
 ):15.6302
),:15.3273	prefix accepted:)
);:14.7066	prefix accepted:)
)::13.6022	prefix accepted:)
)\:13.3927	prefix accepted:)
,:13.1908
)):13.0592
 +:12.4445

:11.6586
 :11.6343
 \:11.4444
).:11.3796	rejected
)|:11.3353	prefix accepted:)
)]:11.307	prefix accepted:)
  :11.264
)`:11.2211	prefix accepted:)
)(:11.1586	prefix accepted:)
                :10.7821
 *:10.781
 |:10.6171	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {emoji: Emoji, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:18.7221
 :15.9151
  :15.845
 #:15.1533	rejected
    :14.7822
                :14.6887
      :13.8489
     :13.665
        :13.5888
 in:13.4019	rejected
       :13.1821
   :13.1221
          :13.0096
         :12.9749
            :12.8663
           :12.6545
             :12.5221
 (*:12.4969	prefix accepted: (
              :12.4685
 end:12.4567
               :12.1061

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)


LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {emoji: Emoji, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
   :20.4004
    :17.7923

:16.4822
  :16.0209
        :15.6929
      :15.2056
                :15.1009
     :15.059
       :14.0849
	:13.9952	rejected
          :13.7732
#:13.7318	rejected
 :13.5656
            :13.5266
         :13.1441
              :12.76
|:12.2967
             :12.0082
           :11.78
               :11.71
(*:11.6659	prefix accepted:(

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
   

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
   
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {emoji: Emoji, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:21.7646
 #:15.9324	rejected
 (*:14.2425	prefix accepted: (

:13.7251
 //:12.4452	prefix accepted: /
 ##:11.5689	rejected
 |\:11.4942	prefix accepted: |
 +:11.2813
 ~:11.277	rejected
 /:12.4452
 \:11.1986
 ^:11.1495	rejected
 St:11.1405	rejected
 <:11.1097
 /*:11.0845	prefix accepted: /
 end:11.0425
 *:10.9553
 ||:10.7666	prefix accepted: |
 (**:10.7459	prefix accepted: (
	:10.7307	rejected
 (:14.2425

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    |

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    |
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 St:20.1117
 Clear:16.846
 F:15.8367
 _:13.5902
 stamp:11.0409
St:10.6897
 :10.5182
 Update:9.57149	rejected
  :9.4509
 (:9.35216
 st:9.33001
 #:9.31554	rejected
 clear:9.11578
 Set:9.08232	rejected
 Insert:8.74282	rejected
 _,:8.73442	prefix accepted: _
 Em:8.69444	rejected
 Add:8.6152	rejected
 Fil:8.56352
 Cle:8.38585
 Put:8.34054	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | St

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | St
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <St>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "St"))))
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  St
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: St
LSP: Generating Completions for prefix: St
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ampEmoji"
root ::= completions

Top 20 Logits:
amp:29.2311
am:16.1901
omp:14.7711	rejected
amps:14.4553	rejected
ample:13.5198	rejected
ap:13.4897	rejected
 amp:13.2371	rejected
ump:13.0533	rejected
ampf:12.652	rejected
rip:12.4895	rejected
ampa:12.3403	rejected
mp:12.1113	rejected
map:11.7546	rejected
AMP:11.622	rejected
ame:11.0903	rejected
emp:10.7816	rejected
arp:10.285	rejected
p:9.9223	rejected
amt:9.65519	rejected
amb:9.47501	rejected
d:9.46119	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | Stamp

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | Stamp
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Stamp>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "Stamp"))))
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  Stamp
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Stamp
LSP: Generating Completions for prefix: Stamp
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Emoji"
root ::= completions

Top 20 Logits:
E:23.5328
Em:13.9139
Cell:13.1237	rejected
(:12.9866	rejected
Grid:11.8096	rejected
At:10.6227	rejected
Empty:10.421	rejected
Over:10.3747	rejected
_:10.2748	rejected
  :10.1124	rejected
Row:9.95439	rejected
::9.93957	rejected
Selected:9.92223	rejected
Image:9.85589	rejected
 em:9.60176	rejected
Action:9.51311	rejected
 E:9.35095	rejected
 ::9.29391	rejected
 (:9.2691	rejected
In:9.21049	rejected
(_:9.08674	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampE

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampE
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <StampE>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "StampE"))))
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  StampE
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: StampE
LSP: Generating Completions for prefix: StampE
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "moji"
root ::= completions

Top 20 Logits:
mo:32.2722
MO:18.7874	rejected
mu:17.4146	rejected
emo:17.2589	rejected
omo:17.0812	rejected
мо:16.8768	rejected
mit:16.71	rejected
 mo:16.5141	rejected
lem:16.4082	rejected
mi:16.1944	rejected
mm:16.1705	rejected
imo:15.2282	rejected
ma:14.9512	rejected
mos:14.5107	rejected
me:14.1549	rejected
amo:13.7482	rejected
mor:13.6639	rejected
Mo:13.5864	rejected
mer:13.0709	rejected
no:13.0069	rejected
moz:12.9464	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmo

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmo
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <StampEmo>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "StampEmo"))))
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  StampEmo
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: StampEmo
LSP: Generating Completions for prefix: StampEmo
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ji"
root ::= completions

Top 20 Logits:
ji:31.6582
iji:18.1946	rejected
ij:17.5427	rejected
 ji:17.0669	rejected
je:16.9542	rejected
jo:16.5767	rejected
ja:16.3116	rejected
j:16.283
ju:14.3437	rejected
ii:13.99	rejected
js:13.3865	rejected
 Ji:13.3591	rejected
yi:13.2115	rejected
ije:12.7555	rejected
J:12.6551	rejected
jin:12.247	rejected
ijo:12.1967	rejected
xi:12.021	rejected
jih:11.8117	rejected
ci:11.8011	rejected
jan:11.675	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <StampEmoji>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ((Int, Int) -> (SelectEmoji(String) + StampEmoji((Int, Int)) + ClearCell((Int, Int)) + ClearGrid + FillRow(Int)))
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Var "Action");
           syn = (Arrow ((Prod [(Var "Row"); (Var "Col")]), (Var "Action")))})))
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  StampEmoji
Nature of error: Expecting type Action but got inconsistent type ((Row, Col) -> Action)
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: StampEmoji
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: StampEmoji
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
(:21.1667
 (:15.4963
(_:14.7271	rejected
((:14.557	prefix accepted:(
([:13.5375	prefix accepted:(
 row:13.4933	rejected
({:13.0393	prefix accepted:(
(":12.0473	prefix accepted:(
 r:12.022	rejected
  :11.6271
(-:11.3671	prefix accepted:(
 at:11.2962	rejected
 _:11.2557	rejected
 :11.1228
():11.0943	prefix accepted:(
 i:10.5485	rejected
   :10.5139
[:10.4748	rejected
       :10.4705
 x:10.4475	rejected
    :10.4307

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (SelectEmoji(String) + StampEmoji((Int, Int)) + ClearCell((Int, Int)) + ClearGrid + FillRow(Int))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (SelectEmoji(String) + StampEmoji((Int, Int)) + ClearCell((Int, Int)) + ClearGrid + FillRow(Int))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Row, Col)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: (Row, Col)
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "()" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= completions | new-tokens

Top 20 Logits:
row:20.3989
r:17.8379
x:15.6214
i:15.5518
y:14.5307
0:13.4475
1:12.4171
pos:12.3373
col:12.2736
Row:12.1221	rejected
selected:12.1106
2:12.0948
_,:11.8252	prefix accepted:_
3:11.8058
a:11.6607
rw:11.6426
idx:11.5272
at:11.3142
cell:11.108
n:11.0069
target:10.9214

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <row>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Row, Col)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {row: (Row, Col), action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: (Row, Col)
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: row
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: row
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
,:19.3344
To:16.6655
Id:14.8406
Index:14.5016
I:13.871
Pos:12.8544
 ,:12.826
',:12.7711	rejected
_:12.5149
N:12.1146
Selected:12.1064
Num:12.0766
::11.8689	rejected
No:11.8273
i:11.7176
_,:11.7076	prefix accepted:_
Number:11.6853
ID:11.5599
1:11.5516
St:11.5076
Position:11.0576

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Row, Col)
  LSP: Info: Seft type: (Int, Int)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Row, Col)
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Row, Col)
  LSP: Info: Seft type: (Int, Int)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Row, Col)
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Col
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Row, Col)
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 col:21.1683
col:16.328
 column:16.0085
  :14.1698
 :12.8225
 c:11.8227
 cell:11.3521
column:11.1358
   :10.7452
 row:10.7449
 coll:10.3478
 cols:10.2146
 cl:10.1367
 x:10.1321
 i:10.0736
 Col:9.99228	rejected
    :9.69249
 _):9.69001	prefix accepted: _
 columns:9.62094
 co:9.52151
 pos:9.43688

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <col>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Col
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Row, Col)
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: col
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: col
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
):20.664
)->:14.2961	prefix accepted:)
 ):14.1752
)=:14.0156	prefix accepted:)
),:13.2533
)|:13.1228	prefix accepted:)
,:13.0942
)::11.2657	prefix accepted:)
 as:10.7274	rejected
 +:10.6295	rejected
)):10.6162
'):10.1763	rejected
1:10.1175
);:10.0314	prefix accepted:)
um:10.0302
To:9.98602
)>:9.92833	prefix accepted:)
_:9.8031
 :9.77704
){:9.5784	prefix accepted:)
)':9.51185	prefix accepted:)

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col)

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (SelectEmoji(String) + StampEmoji((Int, Int)) + ClearCell((Int, Int)) + ClearGrid + FillRow(Int))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:19.0992
 :14.1598
 ->:13.764	rejected
  :13.5482
 if:12.6403	rejected
 when:12.6366	rejected

:12.4077
    :12.0882
   :11.5948
     :11.3895
      :11.0992
       :10.6197
=>:10.4217
        :10.3672
                :10.3238
         :10.0781
          :10.0524
 as:9.88969	rejected
 |:9.82049	rejected
 {:9.63981	rejected
           :9.43563

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) =>

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) =>
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "col" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "row" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 (:18.7714
 :17.2212

:16.8931
 update:16.0329
 let:14.9869
  :14.9816
 ((:14.8341	prefix accepted: (
 if:13.4164
(:13.1025
                :13.0746
    :12.9967
     :12.008
 #:11.9739	rejected
      :11.9032
 ([:11.8902	prefix accepted: (
 List:11.8439	rejected
   :11.7064
        :11.5573
       :11.1851
            :11.1556
 model:11.0448

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "col" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "row" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
update:20.049

:16.1644
 update:14.7013
grid:13.5113
 :12.5784
List:12.0598	rejected
model:11.996
  :11.8572
Grid:11.2224	rejected
E:11.1836	rejected
updated:10.9583	rejected
 grid:10.593
Update:10.3983	rejected
    :10.3199
add:10.2817	rejected
clear:10.2126
action:10.1911
insert:10.171	rejected
#:10.1011	rejected
                :9.97729
Model:9.92534	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (update

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (update
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <update>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ((([[String]], String, [String]), (SelectEmoji(String) + StampEmoji((Int, Int)) + ClearCell((Int, Int)) + ClearGrid + FillRow(Int))) -> ([[String]], String, [String]))
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model");
           syn =
           (Arrow ((Prod [(Var "Model"); (Var "Action")]), (Var "Model")))})))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  update
Nature of error: Expecting type Model but got inconsistent type ((Model, Action) -> Model)
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: update
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: update
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Grid"
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= completions | new-tokens

Top 20 Logits:
Grid:24.7886
(:15.2159
_:14.8182	rejected
G:14.1017
In:13.2415	rejected
Cell:12.4366	rejected
Row:12.1804	rejected
Model:12.167	rejected
E:12.0805	rejected
Graph:11.7008	rejected
grid:11.6788	rejected
GridView:11.6085	rejected
At:11.5632	rejected
GR:11.5524	rejected
Gr:11.3906
 Grid:11.3657	rejected
 grid:10.6637	rejected
Group:10.6407	rejected
Grad:10.6005	rejected
With:10.3562	rejected
State:10.1791	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <updateGrid>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (([[String]], Int, Int, String) -> [[String]])
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model");
           syn =
           (Arrow (
              (Prod [(Var "Grid"); (Var "Row"); (Var "Col"); (Var "Emoji")]),
              (Var "Grid")))})))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid
Nature of error: Expecting type Model but got inconsistent type ((Grid, Row, Col, Emoji) -> Grid)
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: updateGrid
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: updateGrid
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
(:20.6813
 grid:14.7339	rejected
 (:14.2238
((:13.5995	prefix accepted:(
!(:12.6728	prefix accepted:!
(!:12.2526	prefix accepted:(
[:12.0061	rejected
?(:11.9855	rejected
(?:11.8109	prefix accepted:(
,:11.7523
.:11.1969	rejected
 ?:10.9278	rejected
([:10.8928	prefix accepted:(
.(:10.7982	rejected
(*:10.7035	prefix accepted:(

:10.6311
(),:10.5822	prefix accepted:(
  :10.4415
 !:10.292
::10.2542
<:10.0903

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [[String]]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = (Var "Model"); syn = (Var "Grid")})))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(?)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [[String]]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = (Var "Model"); syn = (Var "Grid")})))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(?)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(?)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "col" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "row" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
grid:20.6169
 grid:14.7236
row:14.6172

:14.2853
selected:13.5299
model:12.6765
action:12.0697
x:11.9064	rejected
g:11.8431
clear:11.7647
update:11.4607
#:11.0612	rejected
  :10.951
0:10.7224
copy:10.5112	rejected
_,:10.4783	rejected
 :10.4373
f:10.3826
gr:10.3108
Grid:10.1848	rejected
t:10.1835

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <grid>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Seft type: [[String]]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana =
           (Prod [(Var "Grid"); (Var "Row"); (Var "Col"); (Var "Emoji")]);
           syn = (Var "Grid")})))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(grid)
Nature of error: Expecting type Model but got inconsistent type Grid  
Error in term:
  grid
Nature of error: Expecting type (Grid, Row, Col, Emoji) but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: grid
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: grid
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:21.4171
 ,:14.4465
 row:13.1942	rejected
::12.1651
)(:11.5038	prefix accepted:)
,(:11.2982	prefix accepted:,
.:11.1664	rejected
,\:10.9581	prefix accepted:,
,,:10.7575	prefix accepted:,
 =:10.1149
),:9.66092	prefix accepted:)
 ::9.56684
 +:9.34829
\:9.26384
?,:9.16208	rejected
 ?:9.13591	rejected
!,:9.12725	prefix accepted:!
,[:9.12554	prefix accepted:,
=:9.11791
):11.5038
;:9.05569	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Seft type: ([[String]], ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana =
           (Prod [(Var "Grid"); (Var "Row"); (Var "Col"); (Var "Emoji")]);
           syn = (Prod [(Var "Grid"); (Unknown Internal)])})))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  grid, ?
Nature of error: Expecting type (Grid, Row, Col, Emoji) but got inconsistent type (Grid, ?)  
Error in term:
  updateGrid(grid, ?)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Seft type: ([[String]], ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana =
           (Prod [(Var "Grid"); (Var "Row"); (Var "Col"); (Var "Emoji")]);
           syn = (Prod [(Var "Grid"); (Unknown Internal)])})))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  grid, ?
Nature of error: Expecting type (Grid, Row, Col, Emoji) but got inconsistent type (Grid, ?)  
Error in term:
  updateGrid(grid, ?)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  grid, ?
Nature of error: Expecting type (Grid, Row, Col, Emoji) but got inconsistent type (Grid, ?)  
Error in term:
  updateGrid(grid, ?)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "col" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "row" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 row:21.6764
row:15.1112
 :14.1241
 col:13.4813
 Row:11.9071	rejected
  :11.2264
 (:10.9278
 Int:10.6902	rejected

:10.6439
 int:10.5697
 ro:10.5286
 ?:10.4539	rejected
col:10.1181
 i:10.0596
 selected:9.96319
 List:9.90059	rejected
    :9.66955
 _,:9.57512	rejected
 r:9.51303
 rows:9.32826	rejected
   :9.29511

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <row>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  grid, row
Nature of error: Expecting type (Grid, Row, Col, Emoji) but got inconsistent type (Grid, Row)  
Error in term:
  updateGrid(grid, row)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: row
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: row
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:20.6527
 -:15.8703
 ,:15.0481
 +:14.5815
-:14.5018
To:14.0831	rejected
+:13.3689
 %:11.3621	rejected
::11.1188
.:10.9631	rejected
 as:10.9087	rejected
%:10.6586	rejected
 col:10.6451	rejected
?,:9.88116	rejected
 ?:9.81635	rejected
 :9.8029
 *:9.50719
,\:9.421	prefix accepted:,
 ::9.19736
 /:9.05647
Int:8.93218	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Seft type: ([[String]], Int, ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana =
           (Prod [(Var "Grid"); (Var "Row"); (Var "Col"); (Var "Emoji")]);
           syn = (Prod [(Var "Grid"); (Var "Row"); (Unknown Internal)])})))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  grid, row, ?
Nature of error: Expecting type (Grid, Row, Col, Emoji) but got inconsistent type (Grid, Row, ?)  
Error in term:
  updateGrid(grid, row, ?)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Seft type: ([[String]], Int, ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana =
           (Prod [(Var "Grid"); (Var "Row"); (Var "Col"); (Var "Emoji")]);
           syn = (Prod [(Var "Grid"); (Var "Row"); (Unknown Internal)])})))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  grid, row, ?
Nature of error: Expecting type (Grid, Row, Col, Emoji) but got inconsistent type (Grid, Row, ?)  
Error in term:
  updateGrid(grid, row, ?)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  grid, row, ?
Nature of error: Expecting type (Grid, Row, Col, Emoji) but got inconsistent type (Grid, Row, ?)  
Error in term:
  updateGrid(grid, row, ?)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "col" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "row" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 col:21.2328
col:15.8393
 :15.442
  :12.4982
 column:11.1616	rejected
    :11.0763
 row:10.965

:10.9489
 Col:10.7749	rejected
   :10.5202
 co:10.463
 cl:10.1654
     :9.99719
 c:9.90808
 cols:9.79111	rejected
 _,:9.76283	rejected
	:9.75903	rejected
 ,:9.59317	rejected
 -:9.36155
      :9.34774
 (:9.28156

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <col>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  grid, row, col
Nature of error: Expecting type (Grid, Row, Col, Emoji) but got inconsistent type (Grid, Row, Col)  
Error in term:
  updateGrid(grid, row, col)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: col
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: col
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:21.8924
 ,:15.6779
),:12.07	prefix accepted:)
 selected:11.2591	rejected
 :11.1923
.:11.0516	rejected
 +:10.837
 -:10.3346
::10.1508
,\:10.1476	prefix accepted:,
,,:10.0114	prefix accepted:,
.,:9.63212	rejected
,":9.59654	prefix accepted:,
  :9.44546
):12.07

:9.32446
+:9.05239
)),:8.96137	prefix accepted:))
 \:8.95807
,(:8.82051	prefix accepted:,
!,:8.6547	prefix accepted:!

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Seft type: ([[String]], Int, Int, String)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(grid, row, col, ?)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Seft type: ([[String]], Int, Int, String)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(grid, row, col, ?)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Emoji
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(grid, row, col, ?)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "col" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "row" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 selected:18.7243
 :13.7031
selected:13.461

:11.2322
  :10.9161
 ":10.9151
 s:10.8871
 select:10.7636
 em:10.6073	rejected
 f:9.93814
 \:9.66502	rejected
 ?:9.65475	rejected
 sel:9.60234
 Em:9.60012	rejected
 Selected:9.44569	rejected
    :9.35749
 grid:9.34355
 (:9.2389
 !:9.22763
   :9.21852
 selection:9.09022	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selected

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selected
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <selected>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Emoji
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "selected"))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(grid, row, col, selected)
Nature of error: Expecting type Model but got inconsistent type Grid  
Error in term:
  selected
Nature of error: Variable selected is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: selected
LSP: Generating Completions for prefix: selected
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Emoji"
root ::= completions

Top 20 Logits:
E:22.014
Em:12.9337
),:12.0861	rejected
_:11.7838	rejected
 E:10.537	rejected
EM:10.3061	rejected
emo:9.78668	rejected
em:9.76128	rejected
G:9.62998	rejected
Model:9.13118	rejected
Grid:9.12257	rejected
Value:9.03533	rejected
Empty:9.02582	rejected
)):9.01357	rejected
Element:8.97138	rejected
.:8.97053	rejected
 em:8.92102	rejected
()),:8.79707	rejected
e:8.65974	rejected
 =:8.63401	rejected
 Em:8.60971	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedE

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedE
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <selectedE>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Emoji
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "selectedE"))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(grid, row, col, selectedE)
Nature of error: Expecting type Model but got inconsistent type Grid  
Error in term:
  selectedE
Nature of error: Variable selectedE is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: selectedE
LSP: Generating Completions for prefix: selectedE
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "moji"
root ::= completions

Top 20 Logits:
mo:30.4423
MO:17.4593	rejected
мо:17.3436	rejected
imo:17.2834	rejected
emo:16.8307	rejected
omo:16.7394	rejected
 mo:15.3073	rejected
mu:15.1739	rejected
jo:14.9282	rejected
no:14.5871	rejected
mor:14.3174	rejected
mi:14.1918	rejected
lem:14.1745	rejected
mm:14.068	rejected
Mo:13.8482	rejected
meno:13.6499	rejected
o:13.6461	rejected
my:13.4988	rejected
mon:13.2491	rejected
lo:13.2063	rejected
go:12.9185	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmo

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmo
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <selectedEmo>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Emoji
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "selectedEmo"))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(grid, row, col, selectedEmo)
Nature of error: Expecting type Model but got inconsistent type Grid  
Error in term:
  selectedEmo
Nature of error: Variable selectedEmo is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: selectedEmo
LSP: Generating Completions for prefix: selectedEmo
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ji"
root ::= completions

Top 20 Logits:
ji:27.8862
 ji:16.5289	rejected
yi:16.0204	rejected
ja:15.1427	rejected
jih:14.8262	rejected
iji:14.2992	rejected
 Ji:13.5257	rejected
jo:13.0612	rejected
ei:12.6237	rejected
je:11.6361	rejected
xi:11.1913	rejected
qi:10.4143	rejected
ii:10.4092	rejected
i:10.3522	rejected
json:10.2106	rejected
ји:10.1686	rejected
ai:10.0686	rejected
J:9.67043	rejected
ui:9.53183	rejected
zi:9.24975	rejected
hi:9.20514	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <selectedEmoji>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Emoji
  LSP: Info: Seft type: String
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(grid, row, col, selectedEmoji)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: selectedEmoji
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: selectedEmoji
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
),:19.7936	prefix accepted:)
):19.7936
)):13.1895
)),:12.8796	prefix accepted:))
 ),:12.795	prefix accepted: )
),\:12.6835	prefix accepted:)
,:12.3923
),(:11.3271	prefix accepted:)
 :10.5605
)[:10.2884	prefix accepted:)

:10.2253
);:9.9978	prefix accepted:)
()),:9.8825	prefix accepted:(
)::9.36126	prefix accepted:)
::9.28124
).:9.21235	rejected
],:9.16591	rejected
.:9.09526	rejected
)\:9.00225	prefix accepted:)
[:8.89237	rejected
\:8.89095
Rejected the highest logit candidate ), with logit -inf

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji)

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [[String]]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = (Var "Model"); syn = (Var "Grid")})))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(grid, row, col, selectedEmoji)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
 ,:16.1195

:14.4526
 :13.4002
  :12.636
 \:11.925
    :11.4978
   :11.1949
 grid:11.0017	rejected
     :10.9505
                :10.6026
 ::10.3692
      :10.3509
       :10.1724
 model:10.106	rejected
 |:10.0063	rejected
 #:9.83706	rejected
 ):9.74027
 +:9.64898
        :9.59643
 (:9.48296
 as:9.46123	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model");
           syn = (Prod [(Var "Grid"); (Unknown Internal)])})))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(grid, row, col, selectedEmoji), ?
Nature of error: Expecting type Model but got inconsistent type (Grid, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model");
           syn = (Prod [(Var "Grid"); (Unknown Internal)])})))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(grid, row, col, selectedEmoji), ?
Nature of error: Expecting type Model but got inconsistent type (Grid, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(grid, row, col, selectedEmoji), ?
Nature of error: Expecting type Model but got inconsistent type (Grid, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "col" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "row" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 selected:16.6997
selected:16.486
 :14.2132

:13.1311
  :11.2509
 \:10.8062	rejected
\:10.3088	rejected
 available:9.75627
   :8.98313
    :8.94302
 select:8.91427
 em:8.82297	rejected
 "",:8.56739	prefix accepted: ""
 Selected:8.54824	rejected
     :8.48026
 Em:8.34812	rejected
available:8.3184
,,:8.27603	rejected
 #:8.15844	rejected
 _,:8.13066	rejected
                :8.1266

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selected

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selected
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <selected>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "selected"))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(grid, row, col, selectedEmoji), selected
Nature of error: Expecting type Model but got inconsistent type (Grid, ?)  
Error in term:
  selected
Nature of error: Variable selected is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: selected
LSP: Generating Completions for prefix: selected
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Emoji"
root ::= completions

Top 20 Logits:
E:21.313
Em:13.223
,:11.8991	rejected
_:10.8744	rejected
emo:10.3505	rejected
em:10.0477	rejected
Selected:9.9388	rejected
EM:9.55947	rejected
 E:9.48649	rejected
G:9.26671	rejected
C:9.01475	rejected
Empty:8.94136	rejected
 em:8.94062	rejected
 ,:8.87857	rejected

:8.63168	rejected
S:8.56573	rejected
P:8.4947	rejected
T:8.48703	rejected
D:8.47799	rejected
X:8.45017	rejected
U:8.3947	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedE

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedE
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <selectedE>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "selectedE"))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(grid, row, col, selectedEmoji), selectedE
Nature of error: Expecting type Model but got inconsistent type (Grid, ?)  
Error in term:
  selectedE
Nature of error: Variable selectedE is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: selectedE
LSP: Generating Completions for prefix: selectedE
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "moji"
root ::= completions

Top 20 Logits:
mo:29.8848
MO:18.8348	rejected
omo:17.8198	rejected
emo:17.3693	rejected
imo:17.3181	rejected
jo:17.2921	rejected
мо:16.8409	rejected
Mo:15.8085	rejected
m:14.9295
mit:14.8221	rejected
 mo:14.8186	rejected
o:14.763	rejected
amo:14.4175	rejected
cho:14.2029	rejected
po:13.5458	rejected
mos:13.5172	rejected
ma:13.5109	rejected
no:13.2022	rejected
mi:12.8101	rejected
mot:12.7783	rejected
mu:12.7159	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmo

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmo
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <selectedEmo>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "selectedEmo"))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(grid, row, col, selectedEmoji), selectedEmo
Nature of error: Expecting type Model but got inconsistent type (Grid, ?)  
Error in term:
  selectedEmo
Nature of error: Variable selectedEmo is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: selectedEmo
LSP: Generating Completions for prefix: selectedEmo
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ji"
root ::= completions

Top 20 Logits:
ji:32.1658
 ji:19.463	rejected
j:17.7576
jo:17.7495	rejected
jin:17.7302	rejected
iji:17.3284	rejected
jih:15.9986	rejected
xi:15.6359	rejected
je:15.4846	rejected
jen:15.1476	rejected
ja:14.9635	rejected
jp:14.6017	rejected
ju:14.5503	rejected
jet:14.4162	rejected
 Ji:14.4099	rejected
chi:14.2595	rejected
jar:14.0574	rejected
ki:13.8802	rejected
ји:13.8109	rejected
jer:13.7809	rejected
js:13.3018	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <selectedEmoji>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: String
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(grid, row, col, selectedEmoji), selectedEmoji
Nature of error: Expecting type Model but got inconsistent type (Grid, Emoji)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: selectedEmoji
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: selectedEmoji
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:20.8346
 ,:16.9449
 :14.4706
  :12.8448
):11.9838
,,:11.858	prefix accepted:,
,\:11.7779	prefix accepted:,

:11.6831
),:11.0672	prefix accepted:)
    :10.8051
 \:10.7473
   :10.5813
     :10.2526
 +:10.0624
                :9.98759
.:9.77507	rejected
,[:9.77414	prefix accepted:,
      :9.72949
\:9.69471
,(:9.55629	prefix accepted:,
 ):9.53335

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Emoji]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "col" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "row" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 available:18.5128
available:16.1941
 :15.9509
  :12.8412

:12.697
 [:11.7408
 selected:10.6338
    :10.5347
 av:10.4399
   :10.3687
 avail:10.3622
     :9.92646
 \:9.82903	rejected
 []:9.15244
                :9.099
	:9.05993	rejected
       :8.96291
        :8.85762
      :8.84132
 [],:8.71405	prefix accepted: []
 a:8.44188

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, available

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, available
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <available>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Emoji]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "available"))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  available
Nature of error: Variable available is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: available
LSP: Generating Completions for prefix: available
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Emojis"
root ::= completions

Top 20 Logits:
Em:22.9248
E:12.9984
_:12.2981	rejected
em:11.5747	rejected
):11.2828	rejected
 Em:11.0919	rejected
EM:11.0257	rejected
Emp:10.3079	rejected
Om:10.2035	rejected
M:10.0815	rejected
Im:9.80945	rejected
G:9.75542	rejected
Er:9.74041	rejected
Sm:9.69821	rejected
A:9.3628	rejected
S:9.34691	rejected
 :9.17066	rejected
Tem:9.13078	rejected
 em:9.1122	rejected
P:9.1118	rejected

:9.01673	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEm

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEm
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <availableEm>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Emoji]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "availableEm"))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  availableEm
Nature of error: Variable availableEm is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: availableEm
LSP: Generating Completions for prefix: availableEm
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ojis"
root ::= completions

Top 20 Logits:
oj:26.8261
jos:20.1792	rejected
ij:14.2774	rejected
j:14.2729	rejected
ej:13.7345	rejected
jo:13.5468	rejected
jem:13.3759	rejected
ois:12.9345	rejected
yj:12.4493	rejected
jm:12.3694	rejected
jon:12.3226	rejected
jor:12.1042	rejected
emos:11.9667	rejected
jin:11.8606	rejected
osh:11.7995	rejected
oz:11.574	rejected
otos:11.5548	rejected
os:11.4111	rejected
ijo:11.3767	rejected
jer:11.3563	rejected
o:11.2007

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmoj

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmoj
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <availableEmoj>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Emoji]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "availableEmoj"))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  availableEmoj
Nature of error: Variable availableEmoj is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: availableEmoj
LSP: Generating Completions for prefix: availableEmoj
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "is"
root ::= completions

Top 20 Logits:
is:26.6115
ins:17.7984	rejected
ips:14.8672	rejected
iss:14.7762	rejected
irs:14.0707	rejected
i:13.8862
ios:13.7685	rejected
ies:13.7317	rejected
Is:13.6208	rejected
ias:13.4394	rejected
ij:13.0502	rejected
js:12.9713	rejected
ius:12.9433	rejected
isf:12.7023	rejected
ims:12.6439	rejected
ists:12.4555	rejected
ís:12.3901	rejected
ris:12.2255	rejected
isan:11.9969	rejected
ils:11.9249	rejected
isp:11.7619	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <availableEmojis>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Emoji]
  LSP: Info: Seft type: [String]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: availableEmojis
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: availableEmojis
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
):21.6935
 ):19.3056
),:15.8588	prefix accepted:)
 :15.042
);:13.9498	prefix accepted:)
)):13.8731
,:13.5794
  :13.0174
)\:12.7339	prefix accepted:)

:12.4963
)::11.5548	prefix accepted:)
).:11.2224	rejected
)]:11.1748	prefix accepted:)
 ),:10.9529	prefix accepted: )
)|:10.775	prefix accepted:)
 \:10.773
    :10.7007
   :10.4601
                :10.4555
     :10.3647
)":10.2515	prefix accepted:)

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:19.9451
 :19.0483
  :17.0454
    :15.5823
 #:15.1996	rejected
     :14.2609
   :14.2037
      :14.15
                :14.0401
        :13.5677
       :13.3481
         :12.7333
          :12.5371
           :12.2541
            :12.1955
#:11.7225	rejected
               :11.6114
             :11.5748
              :11.5376
 in:11.5318	rejected
	:11.5313	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)


LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
   :20.8121
    :15.7253
  :15.0381
     :14.5978
 :14.5885

:14.2303
	:14.1818	rejected
#:14.1559	rejected
       :13.462
      :13.4133
                :13.3345
        :13.3277
|:12.5469
(*:12.2092	prefix accepted:(
         :11.8823
            :11.5918
          :11.4186
end:11.2149
           :10.9748
              :10.8212
               :10.7147

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
   

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
   
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:22.7533
 #:17.0927	rejected
 //:13.8807	prefix accepted: /
 (*:13.7121	prefix accepted: (
 |\:12.2616	prefix accepted: |
 /*:12.0646	prefix accepted: /
 Clear:12.0222	rejected
 ||:11.9464	prefix accepted: |
 ...:11.9065	rejected

:11.8262
 *:11.4793
	:11.3519	rejected
 /:13.8807
 \:11.0612
 ##:11.0023	rejected
 case:10.9914	rejected
 (:13.7121
 -:10.7194
 ///:10.6655	prefix accepted: /
 ::10.6472
 ~:10.5961	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    |

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    |
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 Clear:21.2664
 F:17.22
 _:13.3088
 :12.734
Clear:12.1378
 St:11.0158
 Cle:10.6027
 clear:10.4202
 Fil:10.1563
  :10.0982
 Remove:9.82658	rejected
 #:9.77901	rejected
 Update:9.41345	rejected
 Select:9.29592
 Set:9.22617	rejected
 Res:9.05726	rejected
 Em:8.84629	rejected
 Make:8.82729	rejected
 Delete:8.81109	rejected
 (:8.80499
    :8.67594

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | Clear

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | Clear
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Clear>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "Clear"))))
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  Clear
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Clear
LSP: Generating Completions for prefix: Clear
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Cell" | "Grid"
root ::= completions

Top 20 Logits:
Cell:24.2058
Grid:19.3002
Row:16.3634	rejected
E:14.6403	rejected
Cells:14.1262	rejected
Column:13.2776	rejected
All:13.2126	rejected
cell:12.6005	rejected
Color:12.5249	rejected
GridView:12.4573	rejected
Card:12.4089	rejected
Cache:12.3195	rejected
Game:12.1149	rejected
G:12.1129
Group:12.0465	rejected
Circ:12.0326	rejected
Graph:11.9754	rejected
CE:11.8418	rejected
Col:11.8295	rejected
Case:11.7537	rejected
 Cell:11.728	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <ClearCell>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ((Int, Int) -> (SelectEmoji(String) + StampEmoji((Int, Int)) + ClearCell((Int, Int)) + ClearGrid + FillRow(Int)))
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Var "Action");
           syn = (Arrow ((Prod [(Var "Row"); (Var "Col")]), (Var "Action")))})))
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  ClearCell
Nature of error: Expecting type Action but got inconsistent type ((Row, Col) -> Action)
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: ClearCell
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: ClearCell
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
(:21.6008
(_:16.5227	rejected
 (:16.4576
((:13.872	prefix accepted:(
 _:13.3474	rejected
 :13.1471
():12.7878	prefix accepted:(
([:12.7717	prefix accepted:(
  :12.0003
 =>:11.604
 row:11.5435	rejected
 ->:11.4038	rejected
[:11.0656	rejected
 (_:11.0258	rejected
({:10.9097	prefix accepted:(
(":10.5915	prefix accepted:(
(-:10.3795	prefix accepted:(
    :10.3592
      :10.27
 c:10.0462	rejected
 =:10.0322

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (SelectEmoji(String) + StampEmoji((Int, Int)) + ClearCell((Int, Int)) + ClearGrid + FillRow(Int))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (SelectEmoji(String) + StampEmoji((Int, Int)) + ClearCell((Int, Int)) + ClearGrid + FillRow(Int))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Row, Col)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: (Row, Col)
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "()" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= completions | new-tokens

Top 20 Logits:
row:20.6758
r:17.2518
i:15.4955
x:14.7092
_,:14.2494	prefix accepted:_
0:13.6517
col:12.9386
 row:12.7683
cell:12.667
y:12.5811
a:11.8907
rw:11.8482
1:11.8429
idx:11.6364
Row:11.5943	rejected
3:11.3751
m:11.2026
rows:11.1062
2:11.0852
rc:11.0792
pos:10.8785

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <row>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Row, Col)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {row: (Row, Col), action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: (Row, Col)
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: row
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: row
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
,:20.5954
To:16.0333
 ,:14.075
',:12.4985	rejected
Clear:12.3732
Index:11.9291
I:11.9196
C:11.811
1:11.8101
Id:11.6636
2:11.3172
_,:11.2976	prefix accepted:_
_:11.2976
Pos:10.9496
i:10.6165
Of:10.4919
At:10.4518
::10.2519	rejected
0:10.1453
.:10.1241	rejected
Col:9.92117

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Row, Col)
  LSP: Info: Seft type: (Int, Int)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Row, Col)
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Row, Col)
  LSP: Info: Seft type: (Int, Int)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Row, Col)
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Col
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Row, Col)
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 col:20.4943
col:17.9225
 :14.4373
 column:13.7502
 coll:11.4435
 c:11.4325
  :11.3167
 _):11.1884	prefix accepted: _
 cols:11.1254
 cell:11.0338
 Col:10.975	rejected
 row:10.7976
 cl:10.4332
 _:11.1884
 co:9.92943
 i:9.61932
    :9.33823
   :9.19189
column:9.12179
 pos:9.05921
 x:8.90296

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <col>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Col
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Row, Col)
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: col
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: col
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
):21.7754
)=:15.9863	prefix accepted:)
 ):15.9749
)->:15.3924	prefix accepted:)
),:12.4056
)):12.0408
)|:11.7991	prefix accepted:)
 :11.5739
)>:11.3713	prefix accepted:)
 =>:11.1382	rejected
,:11.0916
 as:10.9144	rejected
){:10.4836	prefix accepted:)
)::10.4248	prefix accepted:)
)':10.3947	prefix accepted:)
)":10.2447	prefix accepted:)
'):10.2374	rejected
  :10.2043
_):10.1939	prefix accepted:_
)]:10.1503	prefix accepted:)
To:10.1313

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col)

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (SelectEmoji(String) + StampEmoji((Int, Int)) + ClearCell((Int, Int)) + ClearGrid + FillRow(Int))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:19.9943
 :17.8591
  :15.4864
 ->:14.3732	rejected
    :12.8143
   :12.6757
 when:12.0762	rejected
     :12.0548
      :11.8043

:11.537
 if:11.3178	rejected
=>:11.2123
 =:11.1566
       :11.0316
        :10.7395
         :10.6192
          :10.4695
                :10.3797
 :=:9.9259	rejected
            :9.9015
           :9.88025

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "col" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "row" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 (:18.8943
 :17.9578
 update:16.6658

:15.3124
 let:15.0891
  :14.596
(:14.0573
 clear:13.528
 ((:13.3643	prefix accepted: (
 if:12.7393
 List:12.6177	rejected
    :12.1489
 ([:11.9842	prefix accepted: (
 begin:11.8435	rejected
   :11.6788
 case:11.5038
 grid:11.2072
     :11.1369
 [:10.9284
                :10.8555
 ?:10.5902	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "col" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "row" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:20.0336
 (:18.9174
 update:17.3449
 let:15.2688
 clear:14.3931
 List:14.0311	rejected
 ((:13.7737	prefix accepted: (
 begin:13.2349	rejected
 if:13.2224
	:12.5981	rejected
 ?:12.5569	rejected
 #:12.3412	rejected
 grid:12.106
 case:12.0444
 ([:11.8421	prefix accepted: (
 fail:11.6158	rejected
1:11.5013
 (?:11.2732	prefix accepted: (
0:11.2574
 (*:11.1544	prefix accepted: (
 [:11.137

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 


LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "col" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "row" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
     :20.4152
       :19.0967
      :17.5204
         :15.9475
        :15.7183
    :15.5791
   :14.8645
           :14.858
                :14.8252
          :13.9758
               :13.9494
	:13.9267	rejected
             :13.8419
            :13.4332
              :13.1814

:11.7981
  :11.786
#:11.3446	rejected
 :10.8161
(:10.3775
 (:8.8136

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
       

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
       
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "col" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "row" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 let:21.7739
 (:19.5105
 if:18.7391
 case:17.5815
 update:17.4526
 List:17.1617	rejected
 begin:17.1349	rejected
 clear:16.6691
 #:16.6558	rejected
 match:16.0835	rejected
 fun:15.6094
 grid:15.2838
 ((:14.6641	prefix accepted: (
 Grid:14.1545	rejected
 (*:14.0583	prefix accepted: (
 model:13.6693
 print:13.6004	rejected
 ?:13.474	rejected
 [:13.4648
 ~:13.1211	rejected
 try:13.0727	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 grid:14.3949
 new:13.3295
 update:13.2196
 clear:13.2137
 go:13.0049
 cell:12.1591
 updated:11.6484
 g:11.2995
 f:10.8122
 remove:10.6852
 row:10.6589
 em:10.5763
 empty:10.5482
 get:10.4359
 old:10.4066
 cleared:10.0276
 (:9.97266
 upd:9.97114
 is:9.8833
 set:9.79463
 xs:9.75015

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <grid>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {grid: ?, col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: grid
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: grid
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
 =:16.9512
':13.6381	rejected
With:13.0286
_:12.9849
2:12.5844
1:12.3153
Row:12.235
::12.0226
After:12.0027
Clear:11.7175
Update:11.6091
Copy:11.4616
Cell:11.4105
Updated:11.2696
To:11.1801
New:11.0075
C:10.5905
Up:10.5468
0:10.5092
At:10.5069
 ::10.4943

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid =

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid =
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "col" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "row" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 update:18.5767
 List:16.5684	rejected
 :15.0946
 clear:14.436

:14.313
 case:13.2057
 (:13.0732
 if:12.5847
  :12.5143
 grid:12.1434
 match:11.7629	rejected
 copy:11.5306	rejected
 [:11.3641
 list:10.8003	rejected
 Grid:10.3849	rejected
 fill:10.331
                :10.2364
 Update:9.90113	rejected
    :9.76695
 replace:9.75443	rejected
   :9.43744

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = update

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = update
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <update>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ((([[String]], String, [String]), (SelectEmoji(String) + StampEmoji((Int, Int)) + ClearCell((Int, Int)) + ClearGrid + FillRow(Int))) -> ([[String]], String, [String]))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: update
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: update
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Grid"
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "in"
root ::= completions | new-tokens

Top 20 Logits:
Grid:21.3957
(:14.4547
Row:12.3335	rejected
In:12.2444	rejected
_:12.1963	rejected
Cell:11.989	rejected
G:11.5595
 Grid:11.4629	rejected
 in:11.2012
Graph:11.1986	rejected
E:11.0657	rejected
 (:10.2084
At:10.1622	rejected
List:10.1584	rejected
Empty:10.1311	rejected
((:9.99021	prefix accepted:(
 grid:9.98266	rejected
grid:9.98246	rejected
Group:9.91971	rejected
GridView:9.80994	rejected
Map:9.73907	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <updateGrid>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (([[String]], Int, Int, String) -> [[String]])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: updateGrid
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: updateGrid
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "in"
root ::= new-tokens

Top 20 Logits:
(:21.156
 (:15.3027
 in:14.9946
 grid:13.8757	rejected
((:13.7429	prefix accepted:(
([:12.971	prefix accepted:(
(!:12.7969	prefix accepted:(

:12.0363
[:11.7652	rejected
 !:11.7255
(":11.7123	prefix accepted:(
!(:11.4865	prefix accepted:!
In:11.421	rejected
():11.3891	prefix accepted:(
 :11.0458
  :10.8836
::10.7778
(_:10.5161	rejected
 ?:10.3852	rejected
.(:10.2551	rejected
?(:9.95399	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [[String]]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in end in
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [[String]]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in end in
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "col" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "row" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
grid:20.9222

:15.3348
clear:14.4197
 grid:14.197
update:13.355
model:12.9236
List:12.5605	rejected
row:11.918
  :11.4667
 :11.3922
copy:11.3614	rejected
list:10.8561	rejected
g:10.7572
#:10.6611	rejected
if:10.3131
x:10.2879	rejected
_,:10.1542	rejected
get:10.1469	rejected
Grid:10.1412	rejected
action:10.13
in:10.1239

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <grid>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Seft type: [[String]]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana =
           (Prod [(Var "Grid"); (Var "Row"); (Var "Col"); (Var "Emoji")]);
           syn = (Var "Grid")})))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in end in
  LSP: Info: ALL errors:
Error in term:
  grid
Nature of error: Expecting type (Grid, Row, Col, Emoji) but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: grid
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: grid
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:21.215
 ,:14.7677
::12.2323
,(:11.8357	prefix accepted:,
 row:11.76	rejected
.:11.1915	rejected
,,:10.6899	prefix accepted:,
):10.4962
 ::10.1911
',:9.8568	rejected
 :9.6068
 ?:9.5595	rejected
,\:9.41566	prefix accepted:,

:9.23761
),:9.19308	prefix accepted:)
,[:9.16089	prefix accepted:,
  :9.15257
(),:9.08937	prefix accepted:(
)(:8.91129	prefix accepted:)
_:8.83406	rejected
 =:8.68471

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Seft type: ([[String]], ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana =
           (Prod [(Var "Grid"); (Var "Row"); (Var "Col"); (Var "Emoji")]);
           syn = (Prod [(Var "Grid"); (Unknown Internal)])})))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in end in
  LSP: Info: ALL errors:
Error in term:
  grid, ?
Nature of error: Expecting type (Grid, Row, Col, Emoji) but got inconsistent type (Grid, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Seft type: ([[String]], ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana =
           (Prod [(Var "Grid"); (Var "Row"); (Var "Col"); (Var "Emoji")]);
           syn = (Prod [(Var "Grid"); (Unknown Internal)])})))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in end in
  LSP: Info: ALL errors:
Error in term:
  grid, ?
Nature of error: Expecting type (Grid, Row, Col, Emoji) but got inconsistent type (Grid, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in end in
  LSP: Info: ALL errors:
Error in term:
  grid, ?
Nature of error: Expecting type (Grid, Row, Col, Emoji) but got inconsistent type (Grid, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "col" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "row" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 row:19.7521
row:15.039
 :13.2771
 col:11.583
  :11.2572
 Row:11.1919	rejected

:11.0847
 i:10.7847
 (:10.7743
 List:9.75096	rejected
 Int:9.6316	rejected
 x:9.54989	rejected
    :9.40288
 int:9.29414
 r:9.24389
 rows:9.21966	rejected
 -:9.17611
 ?:9.10427	rejected
   :9.02289
 _,:8.99193	rejected
 if:8.97774

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <row>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in end in
  LSP: Info: ALL errors:
Error in term:
  grid, row
Nature of error: Expecting type (Grid, Row, Col, Emoji) but got inconsistent type (Grid, Row)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: row
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: row
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:20.5314
 ,:14.2679
 +:13.1683
To:13.1438	rejected
 -:12.1578
+:11.6449
::10.4629
 col:10.2126	rejected
.:10.1696	rejected
-:10.0203
 as:9.85724	rejected
 to:8.92697	rejected
 :8.85072
 ?:8.44661	rejected
=:8.39919
,\:8.33005	prefix accepted:,
 %:8.28722	rejected
 *:8.24748

:8.24425
 ::8.13823
',:8.10385	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Seft type: ([[String]], Int, ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana =
           (Prod [(Var "Grid"); (Var "Row"); (Var "Col"); (Var "Emoji")]);
           syn = (Prod [(Var "Grid"); (Var "Row"); (Unknown Internal)])})))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in end in
  LSP: Info: ALL errors:
Error in term:
  grid, row, ?
Nature of error: Expecting type (Grid, Row, Col, Emoji) but got inconsistent type (Grid, Row, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Seft type: ([[String]], Int, ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana =
           (Prod [(Var "Grid"); (Var "Row"); (Var "Col"); (Var "Emoji")]);
           syn = (Prod [(Var "Grid"); (Var "Row"); (Unknown Internal)])})))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in end in
  LSP: Info: ALL errors:
Error in term:
  grid, row, ?
Nature of error: Expecting type (Grid, Row, Col, Emoji) but got inconsistent type (Grid, Row, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in end in
  LSP: Info: ALL errors:
Error in term:
  grid, row, ?
Nature of error: Expecting type (Grid, Row, Col, Emoji) but got inconsistent type (Grid, Row, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "col" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "row" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 col:20.8028
col:15.8724
 :13.6085
 row:12.2254
  :11.3197
 Col:10.7642	rejected
 column:10.6471	rejected
 c:10.0191

:9.9239
 cols:9.87333	rejected
 co:9.6057
 coll:9.42574	rejected
 ,:9.40341	rejected
 cl:9.26802
 _,:9.19863	rejected
 i:9.08082
 -:9.02757
 (:9.02731
    :8.91869
   :8.85262
	:8.84407	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <col>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in end in
  LSP: Info: ALL errors:
Error in term:
  grid, row, col
Nature of error: Expecting type (Grid, Row, Col, Emoji) but got inconsistent type (Grid, Row, Col)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: col
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: col
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:21.3742
,":18.2997	prefix accepted:,
 ,:14.8788
 "",:13.5417	rejected
 :13.4991
):12.7367
 ":11.9932	rejected
::11.7626
 ""):11.604	rejected
,,:11.4096	prefix accepted:,
,':11.1945	prefix accepted:,
",:11.0763	rejected
 -:11.0459
,(:10.967	prefix accepted:,
),:10.8865	prefix accepted:)
 _,:10.7795	rejected
,\:10.7327	prefix accepted:,
.:10.611	rejected
,[:10.266	prefix accepted:,
  :9.91971
,”:9.73782	prefix accepted:,

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Seft type: ([[String]], Int, Int, String)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Seft type: ([[String]], Int, Int, String)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Emoji
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "col" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "row" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 ""):19.0398	prefix accepted: ""
 ":13.6581
 "":19.0398
 selected:11.5654
 "",:11.411	prefix accepted: ""
 "-:11.3102
 ?:11.2176	rejected
 :11.0704
 [:11.0666
 "_:10.4428
 """:10.3466	prefix accepted: ""
 [":10.3016	prefix accepted: [
 _):10.2196	rejected
 empty:10.2114	rejected
 "<:10.1989
 Em:9.99566	rejected
 "\:9.90081
 default:9.85022	rejected
 ''):9.83617	rejected
 (":9.57751	prefix accepted: (
 *):9.33379	rejected
Rejected the highest logit candidate  "") with logit -inf

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, ""

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, ""
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <"">
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: String literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Emoji
  LSP: Info: Seft type: String
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: ""
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: ""
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
 ):15.1629
)::13.4299	prefix accepted:)
 in:12.9495	rejected
 :::11.5321
:::11.3037
 as:11.2246	rejected
(*:10.8823	prefix accepted:(
 ::10.8122
 (*:10.6384	prefix accepted: (
 :10.4366
 +:10.2953
)):10.1561

:10.1299
'):10.045	rejected
 /*:9.69042	prefix accepted: /
  :9.61583
 ,:9.27159
\:9.27108
[:9.02136	rejected
 *:8.99281
 [:8.93269	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "")

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "")
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [[String]]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "in"
root ::= new-tokens

Top 20 Logits:
 in:20.4015
 :15.8019

:15.3842
  :13.89
in:13.432
                :12.137
    :11.7508
 and:11.2959	rejected
   :11.2277
     :11.1603
      :11.0677
 #:10.7613	rejected
 ?:10.7153	rejected
        :10.4304
         :10.3129
          :10.2696
 end:10.1292	rejected
            :9.91647
           :9.65751
       :9.62816
             :9.60711

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {grid: Grid, col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: grid col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "col" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "row" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:19.5908
 :18.5713
  :16.8246
 (:16.4943
    :14.9032
      :14.8098
     :14.3831
                :14.021
        :14.0049
   :13.629
         :13.2186
            :13.015
 #:12.9965	rejected
          :12.9747
              :12.4886
       :12.4847
 (*:12.394	prefix accepted: (
             :12.2339
           :12.2039
 ((:12.0834	prefix accepted: (
               :11.8938

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in


LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {grid: Grid, col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: grid col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "col" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "row" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
       :19.7391
         :18.8447
        :17.7694
     :17.0103
           :16.4651
      :16.1521
          :15.3427
	:14.5365	rejected
    :14.2802
                :13.9838
            :13.8879
             :13.8519
   :13.1472
               :12.9491

:12.827
  :12.6991
              :12.49
 :11.5035
(:10.848
#:10.132	rejected
 (:9.5246

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
         

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
         
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {grid: Grid, col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: grid col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "col" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "row" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 (:20.4739
 if:17.2357
 let:15.5823
 case:15.1217
 (*:15.0349	prefix accepted: (
 grid:14.8486
 clear:14.6926
 List:14.6463	rejected
 match:14.4233	rejected
 #:14.3172	rejected
 print:14.3028	rejected
 update:13.9477
 ((:13.8256	prefix accepted: (
 model:13.2321
 begin:13.1448	rejected
 ([:12.9816	prefix accepted: (

:12.9394
 {:12.618	rejected
 fill:12.5392
 [:12.5375
 St:11.9162

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {grid: Grid, col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {grid: Grid, col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {grid: Grid, col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: grid col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: grid col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "col" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "row" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
grid:18.7753
clear:15.0739
 grid:14.0658

:13.7211
update:13.6049
fill:13.3059
List:13.0165	rejected
if:12.1138
 clear:10.839
 :10.7426
  :10.5307
 List:10.1743	rejected
g:10.1212
remove:10.0809	rejected
 update:9.96732
select:9.79558
insert:9.72761	rejected
map:9.71367	rejected
add:9.4917	rejected
f:9.48518
list:9.36472	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <grid>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [[String]]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = (Var "Model"); syn = (Var "Grid")})))
  LSP: Info: Typing Context: {grid: Grid, col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  grid
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: grid
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: grid
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: grid col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:20.1486
 ,:16.0582
                :13.3394
  :12.3428
 :12.0714
    :11.8404
,,:11.636	prefix accepted:,
::11.5383

:11.4761
          :11.1897
      :11.1885
 ::11.1644
     :11.0955
   :11.0593
,(:11.014	prefix accepted:,
        :10.9883
.:10.9408	rejected
            :10.7501
             :10.3232
              :10.2917
               :10.288

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model");
           syn = (Prod [(Var "Grid"); (Unknown Internal)])})))
  LSP: Info: Typing Context: {grid: Grid, col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  grid, ?
Nature of error: Expecting type Model but got inconsistent type (Grid, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model");
           syn = (Prod [(Var "Grid"); (Unknown Internal)])})))
  LSP: Info: Typing Context: {grid: Grid, col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  grid, ?
Nature of error: Expecting type Model but got inconsistent type (Grid, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {grid: Grid, col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  grid, ?
Nature of error: Expecting type Model but got inconsistent type (Grid, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: grid col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: grid col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "col" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "row" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 selected:17.7477
selected:13.659
 "",:13.2308	prefix accepted: ""
 ":12.1599
 :11.8397
 if:11.4566
 grid:11.3357
 select:11.0856

:10.5299
 ?:10.4551	rejected
 Selected:9.85027	rejected
 Em:9.67626	rejected
  :9.56868
 List:9.55361	rejected
 "":13.2308
 em:9.36001	rejected
 (:9.33677
 clear:9.07034
 available:8.96554
 ""):8.85744	prefix accepted: ""
                :8.70227

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selected

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selected
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <selected>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "selected"))
  LSP: Info: Typing Context: {grid: Grid, col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  grid, selected
Nature of error: Expecting type Model but got inconsistent type (Grid, ?)  
Error in term:
  selected
Nature of error: Variable selected is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: selected
LSP: Generating Completions for prefix: selected
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: grid col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Emoji"
root ::= completions

Top 20 Logits:
E:21.5788
emo:12.2415	rejected
Em:11.9745
_:11.1769	rejected
,:11.0631	rejected
EM:10.1468	rejected
 E:10.0773	rejected
 em:9.78612	rejected
em:9.68773	rejected
Cell:9.39048	rejected
Empty:9.26745	rejected
Grid:9.22935	rejected
G:9.17086	rejected
Row:8.71503	rejected
C:8.19256	rejected
e:7.98847	rejected
.:7.98013	rejected
F:7.96457	rejected
X:7.92625	rejected
Model:7.842	rejected
Image:7.77371	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedE

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedE
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <selectedE>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "selectedE"))
  LSP: Info: Typing Context: {grid: Grid, col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  grid, selectedE
Nature of error: Expecting type Model but got inconsistent type (Grid, ?)  
Error in term:
  selectedE
Nature of error: Variable selectedE is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: selectedE
LSP: Generating Completions for prefix: selectedE
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: grid col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "moji"
root ::= completions

Top 20 Logits:
mo:31.0768
emo:18.3386	rejected
MO:18.0587	rejected
omo:16.9257	rejected
мо:16.7408	rejected
 mo:15.792	rejected
no:15.172	rejected
imo:15.0413	rejected
Mo:14.9491	rejected
mu:13.962	rejected
mm:13.8942	rejected
ma:13.8929	rejected
amo:12.9931	rejected
mor:12.8212	rejected
m:12.6279
o:12.3388	rejected
mi:12.0981	rejected
more:11.9178	rejected
moz:11.8456	rejected
jo:11.8153	rejected
モ:11.7699	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmo

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmo
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <selectedEmo>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "selectedEmo"))
  LSP: Info: Typing Context: {grid: Grid, col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  grid, selectedEmo
Nature of error: Expecting type Model but got inconsistent type (Grid, ?)  
Error in term:
  selectedEmo
Nature of error: Variable selectedEmo is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: selectedEmo
LSP: Generating Completions for prefix: selectedEmo
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: grid col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ji"
root ::= completions

Top 20 Logits:
ji:29.714
 ji:16.8575	rejected
jo:15.6523	rejected
jih:15.3027	rejected
yi:14.7017	rejected
iji:14.6865	rejected
 Ji:13.8704	rejected
je:13.8668	rejected
ja:13.6032	rejected
j:12.5282
xi:12.4098	rejected
ei:11.979	rejected
ju:11.8984	rejected
ји:11.2928	rejected
ij:11.1512	rejected
qi:11.0498	rejected
json:10.904	rejected
jem:10.8306	rejected
J:10.694	rejected
jp:10.4989	rejected
ii:10.381	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <selectedEmoji>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: String
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {grid: Grid, col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  grid, selectedEmoji
Nature of error: Expecting type Model but got inconsistent type (Grid, Emoji)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: selectedEmoji
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: selectedEmoji
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: grid col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:20.8776
 ,:14.5907
 +:11.8597
):10.9607
),:10.9383	prefix accepted:)
 :10.8347
,,:10.7925	prefix accepted:,
::10.4869
  :10.1588
.:10.0389	rejected
 available:9.7206	rejected

:9.23609
 ::9.00816
 if:8.98285	rejected
',:8.9338	rejected
 =:8.82651
 *:8.79418
                :8.72221
 \:8.65376
    :8.59439
,(:8.58302	prefix accepted:,

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {grid: Grid, col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {grid: Grid, col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Emoji]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {grid: Grid, col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: grid col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: grid col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "col" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "row" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 available:19.1015
available:14.6417
 :13.2616
 List:12.1535	rejected
 [:11.7591
 grid:11.4293
 av:10.8039
 avail:10.6466
 filter:10.3229	rejected
 selected:10.0872
  :9.93866
 [":9.89496	prefix accepted: [
 update:9.85423
 ""):9.80171	prefix accepted: ""
 list:9.6783	rejected
 if:9.62052
 select:9.38506
 a:9.36511
 clear:9.22101

:9.19376
 (:9.16206

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, available

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, available
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <available>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Emoji]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "available"))
  LSP: Info: Typing Context: {grid: Grid, col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  available
Nature of error: Variable available is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: available
LSP: Generating Completions for prefix: available
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: grid col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Emojis"
root ::= completions

Top 20 Logits:
Em:22.3822
E:12.2884
_:11.8271	rejected
em:11.5866	rejected
 Em:11.0201	rejected
EM:10.8879	rejected
):10.5839	rejected
Emp:10.5523	rejected
Om:10.2281	rejected
 em:9.94046	rejected
Im:9.91784	rejected
M:9.86922	rejected
G:9.77852	rejected
Er:9.76292	rejected
Sm:9.66798	rejected
Empty:9.26938	rejected
Grid:9.08946	rejected
Available:9.07026	rejected
S:8.97827	rejected
.:8.7201	rejected
P:8.65762	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEm

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEm
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <availableEm>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Emoji]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "availableEm"))
  LSP: Info: Typing Context: {grid: Grid, col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  availableEm
Nature of error: Variable availableEm is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: availableEm
LSP: Generating Completions for prefix: availableEm
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: grid col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ojis"
root ::= completions

Top 20 Logits:
oj:28.8134
jos:15.8029	rejected
ijo:14.0504	rejected
jo:14.0413	rejected
o:13.4212
ois:12.1591	rejected
ij:11.6853	rejected
uj:11.6291	rejected
j:10.9624	rejected
ej:10.7215	rejected
oi:10.1393	rejected
yj:9.76109	rejected
aj:9.71684	rejected
oy:9.54808	rejected
oz:9.50807	rejected
 ej:9.42698	rejected
 jo:9.37134	rejected
jp:9.32702	rejected
voj:9.31014	rejected
ój:9.25131	rejected
obj:9.18398	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmoj

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmoj
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <availableEmoj>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Emoji]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "availableEmoj"))
  LSP: Info: Typing Context: {grid: Grid, col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  availableEmoj
Nature of error: Variable availableEmoj is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: availableEmoj
LSP: Generating Completions for prefix: availableEmoj
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: grid col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "is"
root ::= completions

Top 20 Logits:
is:27.9528
Is:15.6864	rejected
ies:14.7444	rejected
ims:13.2734	rejected
ij:13.1653	rejected
ips:13.1331	rejected
ios:12.6028	rejected
 is:12.4166	rejected
i:12.3171
isp:12.1899	rejected
isi:12.1773	rejected
lis:12.0683	rejected
ис:11.9841	rejected
ises:11.832	rejected
im:11.8024	rejected
ins:11.682	rejected
isf:11.5579	rejected
isu:11.5196	rejected
ism:11.3069	rejected
irs:11.1406	rejected
js:11.0942	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <availableEmojis>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Emoji]
  LSP: Info: Seft type: [String]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {grid: Grid, col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: availableEmojis
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: availableEmojis
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: grid col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
):22.7227
 ):18.2976
),:16.5431	prefix accepted:)
);:15.481	prefix accepted:)
,:15.0852
)):14.6877

:14.0942
 :13.6812
  :13.5921
)]:12.6566	prefix accepted:)
)::12.5059	prefix accepted:)
).:12.5028	rejected
)`:12.2728	prefix accepted:)
 +:12.2642
)":12.1038	prefix accepted:)
                :12.0633
)\:11.9876	prefix accepted:)
    :11.9406
 |:11.8074	rejected
     :11.5572
)}:11.4808	prefix accepted:)

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {grid: Grid, col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:19.7351
  :17.3205
 :16.807
    :15.7358
        :15.2448
      :15.226
     :14.7866
                :14.4409
   :14.2469
          :14.1145
 #:13.7952	rejected
            :13.5329
           :12.9897
              :12.9768
       :12.8609
         :12.6497
             :12.4644
               :12.131
	:11.7285	rejected
 end:11.4028
 in:11.0422	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)


LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {grid: Grid, col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
   :19.5212
    :16.0863
        :15.45
  :15.1433
     :15.0487

:14.7094
      :14.5414
          :14.0696
            :13.2072
       :13.1356
                :12.9965
         :12.9239
 :12.7444
	:12.5185	rejected
           :12.227
#:11.9694	rejected
              :11.7453
             :11.7332
|:11.3975
               :10.8343
(*:10.1868	prefix accepted:(

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
   

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
   
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {grid: Grid, col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:22.7283
 #:15.487	rejected
 (*:13.3157	prefix accepted: (
 //:13.1683	prefix accepted: /

:12.9462
 case:12.4031	rejected
 Clear:12.226	rejected
	:11.8849	rejected
 end:11.6537
 clear:11.4703	rejected
 /:13.1683
 /*:11.2208	prefix accepted: /
 (:13.3157
 --:10.8285	prefix accepted: -
 -:10.8285
 ():10.5671	prefix accepted: (
 ~:10.5211	rejected
 *:10.4888
 ///:10.3723	prefix accepted: /
 +:10.3712
 &:10.3072

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    |

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    |
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 Clear:19.5398
 F:17.314
 _:12.7652
Clear:12.714
 :12.3195
 St:11.9753
 Cle:10.5604
 clear:10.3876
 Select:10.0107
 Fil:9.91377
  :9.70415
 Res:9.25521	rejected
 Update:9.24221	rejected
 Set:9.11617	rejected
 #:9.09595	rejected
 (:9.08485
 Remove:8.94915	rejected
 Create:8.83459	rejected
 Make:8.76958	rejected
 Em:8.73621	rejected
 Full:8.66573	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | Clear

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | Clear
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Clear>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "Clear"))))
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  Clear
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Clear
LSP: Generating Completions for prefix: Clear
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Cell" | "Grid"
root ::= completions

Top 20 Logits:
Grid:21.1306
Row:13.5817	rejected
All:13.5039	rejected
Cell:12.4701
G:11.9909
GR:11.9472	rejected
grid:11.6489	rejected
 Grid:11.5071	rejected
E:11.2453	rejected
Gr:11.188
GridView:11.0241	rejected
_:10.6098	rejected
Graph:10.1591	rejected
():10.0513	rejected
Column:9.96533	rejected
(:9.95322	rejected
 grid:9.94233	rejected
Group:9.91911	rejected
Grad:9.50369	rejected
Full:9.49144	rejected
Canvas:9.48578	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <ClearGrid>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (SelectEmoji(String) + StampEmoji((Int, Int)) + ClearCell((Int, Int)) + ClearGrid + FillRow(Int))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: ClearGrid
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: ClearGrid
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:18.5499
():14.689	prefix accepted:(
 :13.7988
 ->:13.4199	rejected
=>:12.8819
  :12.7197
    :12.0391
        :11.6471
      :11.6078
     :11.5464
          :11.214
   :11.2119
(:14.689
 ():11.1179	prefix accepted: (
(_:10.8151	rejected
            :10.7992
 _:10.5274	rejected
       :10.4113
         :10.3009
           :10.2167
                :9.98565

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid =>

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid =>
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 (:19.2849
 :18.6601

:17.3715
  :16.6934
 let:16.1055
 clear:15.9456
 ((:14.8726	prefix accepted: (
    :13.7456
                :13.4493
     :13.3183
 ([:13.2985	prefix accepted: (
(:13.2737
      :13.0471
   :12.9555
        :12.7181
            :12.3035
             :12.1911
              :11.9064
          :11.8654
         :11.6834
 (":11.4249	prefix accepted: (

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
clear:20.8037
 clear:15.8565

:14.3339
grid:13.7532
empty:12.9581	rejected
List:12.3799	rejected
update:12.1015
Clear:11.503
 :10.9986
fill:10.9196
let:10.8623
model:10.6987
[]:10.1519
default:10.1416	rejected
 (:10.0022
clean:9.90343	rejected
 grid:9.89658
Grid:9.70653	rejected
  :9.65309
Model:9.29712	rejected
cle:9.26013

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clear

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clear
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <clear>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "clear"))
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  clear
Nature of error: Variable clear is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: clear
LSP: Generating Completions for prefix: clear
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Grid"
root ::= completions

Top 20 Logits:
Grid:21.3468
G:14.1908
_:13.4038	rejected
Graph:12.7067	rejected
grid:12.5793	rejected
GR:12.5402	rejected
(:12.1038	rejected
(),:11.6511	rejected
Empty:11.5005	rejected
Gr:11.5002
Model:11.3885	rejected
GridView:10.7704	rejected
,:10.5986	rejected
Game:10.5944	rejected
():10.5784	rejected
Row:10.5564	rejected
Group:10.4629	rejected
 Grid:10.4196	rejected
 grid:10.0385	rejected
State:9.94571	rejected
Graphics:9.68239	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <clearGrid>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]] -> [[String]])
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model");
           syn = (Arrow ((Var "Grid"), (Var "Grid")))})))
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  clearGrid
Nature of error: Expecting type Model but got inconsistent type (Grid -> Grid)
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: clearGrid
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: clearGrid
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
(:19.3974
 grid:16.3974	rejected
(),:13.0773	prefix accepted:(
 (:12.9326
():11.8705	prefix accepted:(
,:11.8563
([:11.6959	prefix accepted:(
((:11.4868	prefix accepted:(
(":10.9214	prefix accepted:(
 model:10.4111	rejected
[:10.2565	rejected
(*:9.64643	prefix accepted:(
 :9.55102
::9.36742
(!:9.34225	prefix accepted:(
(_:9.23949	rejected
(?:8.98022	prefix accepted:(
 [:8.80943	rejected
.:8.76841	rejected
 graph:8.7364	rejected
grid:8.72961	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [[String]]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = (Var "Model"); syn = (Var "Grid")})))
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  clearGrid(?)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [[String]]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = (Var "Model"); syn = (Var "Grid")})))
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  clearGrid(?)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Grid
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  clearGrid(?)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Grid
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
grid:20.8893
model:14.6447
update:13.7518
 grid:13.6982
List:13.6306	rejected
clear:12.8498
3:12.7489
[]:12.0341
init:11.7107	rejected
Model:11.3192	rejected
empty:11.2669	rejected
1:11.0942
copy:11.0894	rejected
0:11.0494
Grid:10.9098	rejected
available:10.8444
g:10.6767
get:10.6509	rejected
list:10.5959	rejected
initial:10.5615	rejected
default:10.5485	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <grid>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Grid
  LSP: Info: Seft type: [[String]]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  clearGrid(grid)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Grid
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: grid
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: grid
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
),:23.4304	prefix accepted:)
):23.4304
,:14.4888
)):14.1483
);:13.6548	prefix accepted:)
 ),:13.3478	prefix accepted: )
)),:13.2238	prefix accepted:))
::12.8812
)::12.7146	prefix accepted:)
),(:12.6303	prefix accepted:)
),\:11.6835	prefix accepted:)
).:11.1215	rejected
 ::11.0441
 ):13.3478
));:10.7819	prefix accepted:))
()),:10.5088	prefix accepted:(
 ,:10.4662
 as:10.2123	rejected
)[:10.2005	prefix accepted:)
)(:10.1674	prefix accepted:)
))):10.1631	prefix accepted:))
Rejected the highest logit candidate ), with logit -inf

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [[String]]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = (Var "Model"); syn = (Var "Grid")})))
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  clearGrid(grid)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
 ,:18.3
                :12.6124
  :12.4722
 :12.4369
    :12.0178
     :11.6381
   :11.4059
      :11.3088
 as:11.0684	rejected
        :11.0034

:10.6119
          :10.5739
       :10.5658
            :10.3857
             :10.3613
           :10.1992
               :10.0283
              :10.0235
 ::10.0049
 +:9.76789
         :9.72987

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model");
           syn = (Prod [(Var "Grid"); (Unknown Internal)])})))
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  clearGrid(grid), ?
Nature of error: Expecting type Model but got inconsistent type (Grid, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model");
           syn = (Prod [(Var "Grid"); (Unknown Internal)])})))
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  clearGrid(grid), ?
Nature of error: Expecting type Model but got inconsistent type (Grid, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  clearGrid(grid), ?
Nature of error: Expecting type Model but got inconsistent type (Grid, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
selected:20.0554
 selected:16.1919
 :10.7921

:10.0318
 "",:10.023	prefix accepted: ""
select:9.96413
available:9.44206
Selected:9.19296	rejected
 ":9.17257
  :8.52301
default:8.35385	rejected
 Selected:8.26557	rejected
(:8.23113
 select:8.09202
grid:8.08052
 (:8.04727
selector:7.70246	rejected
model:7.69703
 available:7.69091
selection:7.58987	rejected
 ,:7.52332	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selected

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selected
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <selected>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "selected"))
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  selected
Nature of error: Variable selected is not bound  
Error in term:
  clearGrid(grid), selected
Nature of error: Expecting type Model but got inconsistent type (Grid, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: selected
LSP: Generating Completions for prefix: selected
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Emoji"
root ::= completions

Top 20 Logits:
E:22.4687
Em:11.8606
emo:11.5611	rejected
_:10.6273	rejected
Selected:10.6065	rejected
,:10.5452	rejected
EM:9.16745	rejected
 E:9.13197	rejected
em:9.1281	rejected
 em:9.04289	rejected
G:9.03806	rejected
Empty:8.93324	rejected
X:8.90866	rejected
C:8.39572	rejected
Available:8.36022	rejected
U:8.33005	rejected
O:8.31641	rejected
F:8.26233	rejected
Image:8.20041	rejected
.:8.1442	rejected
I:8.01441	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedE

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedE
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <selectedE>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "selectedE"))
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  clearGrid(grid), selectedE
Nature of error: Expecting type Model but got inconsistent type (Grid, ?)  
Error in term:
  selectedE
Nature of error: Variable selectedE is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: selectedE
LSP: Generating Completions for prefix: selectedE
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "moji"
root ::= completions

Top 20 Logits:
mo:29.8516
emo:19.7304	rejected
omo:19.258	rejected
imo:17.657	rejected
MO:17.1783	rejected
 mo:15.7064	rejected
мо:15.374	rejected
Mo:15.3312	rejected
jo:12.9609	rejected
mm:12.8238	rejected
 Moore:12.8118	rejected
mor:12.8092	rejected
amo:12.7473	rejected
mos:12.5993	rejected
yo:12.554	rejected
mi:12.5078	rejected
mu:12.4048	rejected
ermo:12.019	rejected
モ:11.969	rejected
no:11.9114	rejected
neo:11.7037	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmo

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmo
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <selectedEmo>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "selectedEmo"))
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  selectedEmo
Nature of error: Variable selectedEmo is not bound  
Error in term:
  clearGrid(grid), selectedEmo
Nature of error: Expecting type Model but got inconsistent type (Grid, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: selectedEmo
LSP: Generating Completions for prefix: selectedEmo
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ji"
root ::= completions

Top 20 Logits:
ji:32.8994
iji:20.2491	rejected
 ji:18.6549	rejected
jo:16.6925	rejected
 Ji:15.5733	rejected
yi:14.8518	rejected
ja:14.8075	rejected
jih:14.5945	rejected
ij:13.5828	rejected
ijo:12.866	rejected
ju:12.6168	rejected
jin:12.4057	rejected
J:12.3484	rejected
xi:12.2768	rejected
ји:12.2303	rejected
qi:12.2274	rejected
je:12.0721	rejected
ui:12.0181	rejected
jp:11.8583	rejected
ject:11.8527	rejected
jem:11.647	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <selectedEmoji>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: String
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  clearGrid(grid), selectedEmoji
Nature of error: Expecting type Model but got inconsistent type (Grid, Emoji)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: selectedEmoji
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: selectedEmoji
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:21.5961
 ,:16.2653
,,:11.9079	prefix accepted:,
 :11.7743
  :10.797
),:10.6504	prefix accepted:)
):10.6504
::10.3759
,":10.275	prefix accepted:,
,[:9.95015	prefix accepted:,
 +:9.79014
,\:9.76978	prefix accepted:,
,(:9.59873	prefix accepted:,
.:9.57196	rejected
 ::9.38892

:9.17116
 *:9.075
   :8.50629
",:8.50371	rejected
,.:8.4775	rejected
 =:8.4428

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Emoji]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 available:20.0748
available:16.8712
 :14.4806
 [:11.9387
  :11.4241
 av:10.329
 []:10.2528
 avail:10.2326
 [":10.1517	prefix accepted: [
 selected:9.8927

:9.63157
 ":9.60584
 ""):9.39561	prefix accepted: ""
 List:9.29149	rejected
 list:9.26691	rejected
 Em:9.17808	rejected
 grid:9.16631
 [],:9.15789	prefix accepted: []
 a:9.09408
	:8.93036	rejected
 em:8.67712	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, available

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, available
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <available>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Emoji]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "available"))
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  available
Nature of error: Variable available is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: available
LSP: Generating Completions for prefix: available
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Emojis"
root ::= completions

Top 20 Logits:
Em:26.8029
Im:16.0697	rejected
Emp:15.5212	rejected
Equ:15.2948	rejected
 Em:15.2255	rejected
Mem:15.1358	rejected
em:14.9824	rejected
Om:14.4207	rejected
E:13.8781
Rem:13.6826	rejected
EM:13.4807	rejected
Er:13.4163	rejected
Empty:13.3598	rejected
Ent:13.1718	rejected
Eq:13.0067	rejected
El:12.7887	rejected
Sim:12.7018	rejected
Ed:12.6834	rejected
 em:12.6719	rejected
Ex:12.6596	rejected
Am:12.4356	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEm

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEm
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <availableEm>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Emoji]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "availableEm"))
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  availableEm
Nature of error: Variable availableEm is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: availableEm
LSP: Generating Completions for prefix: availableEm
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ojis"
root ::= completions

Top 20 Logits:
oj:33.0208
jos:17.8519	rejected
oz:17.032	rejected
jo:15.6348	rejected
ois:14.4686	rejected
j:14.4558	rejected
oi:14.1929	rejected
uj:14.1688	rejected
oy:13.777	rejected
ij:13.597	rejected
o:13.3842
aj:12.8766	rejected
obj:12.8146	rejected
ijo:12.4801	rejected
ój:12.1406	rejected
ov:12.1054	rejected
jor:12.0733	rejected
og:12.0633	rejected
oir:12.0476	rejected
ox:11.7372	rejected
jq:11.7121	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmoj

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmoj
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <availableEmoj>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Emoji]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "availableEmoj"))
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  availableEmoj
Nature of error: Variable availableEmoj is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: availableEmoj
LSP: Generating Completions for prefix: availableEmoj
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "is"
root ::= completions

Top 20 Logits:
is:28.2615
ins:18.7704	rejected
i:17.6001
ies:16.2113	rejected
ises:14.3746	rejected
si:13.5472	rejected
irs:13.5294	rejected
Is:13.1154	rejected
s:12.5304	rejected
ios:12.4034	rejected
ists:12.0952	rejected
ings:12.0722	rejected
in:12.0606	rejected
iss:12.0023	rejected
isl:11.9039	rejected
es:11.8242	rejected
isp:11.7619	rejected
isi:11.7104	rejected
 is:11.6733	rejected
ips:11.4766	rejected
ys:11.0828	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <availableEmojis>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Emoji]
  LSP: Info: Seft type: [String]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: availableEmojis
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: availableEmojis
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
):22.4226
 ):18.849
),:15.2319	prefix accepted:)
);:14.2881	prefix accepted:)
)):14.1196
 :13.1153
,:12.9409
  :12.8759

:12.553
)|:12.1331	prefix accepted:)
).:11.6454	rejected
)]:11.4968	prefix accepted:)
)::11.4739	prefix accepted:)
)}:11.44	prefix accepted:)
)\:11.1549	prefix accepted:)
)":11.0433	prefix accepted:)
    :10.6686
 |:10.3933	rejected
()):10.3647	prefix accepted:(
)(:10.2642	prefix accepted:)
     :10.234

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:19.2972
  :15.9594
 :15.9538
    :15.0007
      :14.0105
        :13.7862
     :13.7479
 #:13.5702	rejected
   :13.2311
                :13.226
          :12.6605
            :12.3939
       :11.8495
           :11.779
              :11.3905
             :11.3522
         :11.3399
               :10.7899
	:10.6341	rejected
 (*:10.1335	prefix accepted: (
#:9.8131	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)


LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
   :21.0632
    :15.9038
  :15.5061
     :14.874

:14.0036
      :13.7975
        :13.7389
	:13.707	rejected
 :13.5878
#:13.2614	rejected
       :12.6382
                :12.5863
|:12.4915
end:12.3719
            :11.9442
          :11.8604
(*:11.5808	prefix accepted:(
         :11.349
           :11.1982
 |:11.0095
               :10.828

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
   

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
   
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:22.1126
 #:15.8918	rejected
 end:13.9345
 (*:13.249	prefix accepted: (
 //:12.3535	prefix accepted: /
 *:12.0967
 else:11.8913	rejected
 case:11.654	rejected
 <:11.2523
 in:11.123	rejected
 \:11.1054
 if:11.0883	rejected
 /:12.3535
 eq:10.9474	rejected
 ||:10.8947	prefix accepted: |
 equal:10.8049	rejected
 /*:10.7255	prefix accepted: /
 |\:10.6458	prefix accepted: |
 when:10.6231	rejected
 ##:10.6125	rejected
 der:10.5837	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    |

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    |
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 F:22.3219
Fill:14.4037
 _:14.1991
 :13.2811
 St:11.5757
  :11.1205
>:10.9247	rejected
 #:10.8537	rejected
 fill:10.8202
 :10.7868	rejected
 Select:10.6282
 Fil:10.3628
 >:10.3454	rejected
 Clear:10.1613
 FI:10.0121	rejected
 +:9.72494	rejected
    :9.59849
_:9.43284
 (:9.43175
 @:9.25886	rejected
 Update:8.94069	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | F

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | F
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <F>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "F"))))
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  F
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: F
LSP: Generating Completions for prefix: F
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "illRow"
root ::= completions

Top 20 Logits:
ill:26.5707
ills:13.4509	rejected
i:13.2908
ille:13.025	rejected
it:12.1671	rejected
lip:12.0067	rejected
Ill:11.68	rejected
ll:11.2175	rejected
illing:10.9357	rejected
iller:10.905	rejected
Fill:10.3879	rejected
ocus:10.2235	rejected
etch:10.1964	rejected
illi:10.1322	rejected
ild:9.77513	rejected
irm:9.60423	rejected
fill:9.57762	rejected
old:9.50971	rejected
ell:9.33239	rejected
 ill:9.26313	rejected
L:8.74843	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | Fill

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | Fill
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Fill>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "Fill"))))
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  Fill
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Fill
LSP: Generating Completions for prefix: Fill
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Row"
root ::= completions

Top 20 Logits:
Row:24.5466
row:14.5236	rejected
Rows:12.6845	rejected
Cell:12.6043	rejected
Grid:12.2799	rejected
 Row:11.6745	rejected
R:11.5976
E:11.5124	rejected
(:11.3775	rejected
Ro:11.1284
Empty:11.0491	rejected
_:10.7693	rejected
All:10.6374	rejected
Selected:10.5639	rejected
ROW:10.3524	rejected
With:10.3113	rejected
r:9.98146	rejected
Col:9.75254	rejected
Up:9.53375	rejected
 row:9.46206	rejected
RO:9.43673	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <FillRow>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (Int -> (SelectEmoji(String) + StampEmoji((Int, Int)) + ClearCell((Int, Int)) + ClearGrid + FillRow(Int)))
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Var "Action");
           syn = (Arrow ((Var "Row"), (Var "Action")))})))
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  FillRow
Nature of error: Expecting type Action but got inconsistent type (Row -> Action)
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: FillRow
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: FillRow
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
(:19.8946
 row:14.4083	rejected
 (:13.5873
(_:13.3392	rejected
 r:12.7349	rejected
((:11.6668	prefix accepted:(
 em:11.4604	rejected
({:10.8357	prefix accepted:(
 i:10.2764	rejected
():10.2365	prefix accepted:(
 :10.2167
  :10.161
 fill:10.1209	rejected
 =>:9.7679
 col:9.71389	rejected
([:9.48864	prefix accepted:(
 ->:9.45405	rejected
 _:9.45135	rejected
 rows:9.32415	rejected
 x:9.26176	rejected
 cell:9.18717	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (SelectEmoji(String) + StampEmoji((Int, Int)) + ClearCell((Int, Int)) + ClearGrid + FillRow(Int))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (SelectEmoji(String) + StampEmoji((Int, Int)) + ClearCell((Int, Int)) + ClearGrid + FillRow(Int))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Row
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Row
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "()" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= completions | new-tokens

Top 20 Logits:
row:20.363
r:15.7529
i:14.5313
n:14.0332
idx:13.5117
index:13.1465
fill:12.9327
selected:12.5899
filled:12.4321
target:12.3911
to:12.0558
x:11.9585
y:11.8899
num:11.7685
col:11.6517
line:11.5918
which:11.1787
rows:10.9794
a:10.8613
em:10.7953
 row:10.7633

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(row

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(row
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <row>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Row
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Row
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: row
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: row
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
To:19.3476
):18.6861
Index:15.2534
Number:14.62
Num:14.5365
Id:14.3668
No:13.1716
Fil:12.5621
_:12.4055
to:12.1296
I:12.0497
T:12.0283
N:11.9022
Selected:11.8858
ID:11.7925
Fill:11.7354
Pos:11.6952
Of:11.6372
)=:11.6029	prefix accepted:)
 ):11.5158
)->:11.0387	prefix accepted:)

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowTo

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowTo
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <rowTo>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Row
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {rowTo: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Row
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: rowTo
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: rowTo
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
Fill:23.7221
Clear:18.4128
St:16.7259
Be:16.4888
Fil:15.3398
F:14.4981
Update:13.9575
Paint:13.626
Select:13.58
fill:13.5588
Empty:13.5329
Replace:13.2896
FI:13.1388
Change:13.0397
Add:12.9431
Set:12.7741
Use:12.6152
C:12.536
Re:12.5028
):12.5026
Full:12.4785

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <rowToFill>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Row
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Row
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: rowToFill
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: rowToFill
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
):20.6009
)->:15.7051	prefix accepted:)
)=:15.5993	prefix accepted:)
In:15.5819
 ):15.2604
With:14.7325
,:13.343
Index:12.743
And:12.2403
Em:11.7706
 =>:11.4906	rejected
Id:11.4613
),:11.2833
E:11.2046
::10.8677	rejected
As:10.8526
 ->:10.8284	rejected
_):10.7021	prefix accepted:_
Up:10.5305
_:10.7021
On:10.4385

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill)

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (SelectEmoji(String) + StampEmoji((Int, Int)) + ClearCell((Int, Int)) + ClearGrid + FillRow(Int))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:20.1247
 :16.4779
 ->:15.9472	rejected
  :14.1925
    :12.559
   :12.1292

:12.0309
     :11.5412
 when:11.0511	rejected
      :10.9291
=>:10.2353
 =:10.2294
       :10.2264
 >:9.99915	rejected
        :9.96846
 as:9.74813	rejected
 ==>:9.60407	prefix accepted: =
 :=:9.5595	rejected
 :::9.50629	rejected
                :9.48653
          :9.36892

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) =>

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) =>
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "rowToFill" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 :21.5206

:18.5737
 (:18.2718
  :17.875
 let:15.1794
    :14.8666
     :14.3305
                :14.1049
(:14.0442
   :13.9466
      :13.8966
 ((:13.8524	prefix accepted: (
 fill:13.7351
       :13.3284
        :13.2328
            :12.8197
             :12.7343
          :12.6096
         :12.2878
              :12.208
           :11.9207

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "rowToFill" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:23.0909
 (:17.7487
 let:15.4762
	:14.2867	rejected
 #:13.9476	rejected
 fill:13.8492
 ((:13.0695	prefix accepted: (
 (*:12.1735	prefix accepted: (
 clear:11.7597
 //:11.5921	rejected
 (":11.1199	prefix accepted: (
 [:11.0986
 if:10.9378
 begin:10.8568	rejected
 #(:10.8102	rejected
1:10.7989
 ([:10.5936	prefix accepted: (
2:10.3391
 update:10.3218
 {:10.2924	rejected
 (\:10.2007	prefix accepted: (

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 


LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "rowToFill" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
       :21.7889
     :19.6365
      :17.7876
        :17.2297
         :15.8503
    :15.2385
           :15.0142
   :14.5697
          :14.088
	:13.194	rejected
             :13.0354
                :12.8229
               :12.7092
  :12.6644
            :12.5896

:12.0332
              :11.8765
 :11.5432
#:11.1158	rejected
(:10.2868
(*:9.45657	prefix accepted:(

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
       

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
       
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "rowToFill" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 let:25.0045
 (:19.4289
 if:17.9707
 fill:16.3145
 clear:15.739
 #:15.6017	rejected
 ((:14.789	prefix accepted: (
 List:14.683	rejected
 update:14.648
 begin:14.369	rejected
 print:14.1513	rejected
 (*:13.9842	prefix accepted: (
 match:13.8017	rejected
 case:13.5875
 [:13.2338
 assert:13.1786	rejected
 grid:12.9799
 list:12.8509	rejected
 {:12.8061	rejected
 printf:12.5406	rejected
 F:12.4062

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 grid:20.2404
 new:15.0305
 updated:13.2275
 g:12.8642
 fill:12.7735
 (:12.2912
 :12.1078
 filled:12.0442
 row:12.0138
 em:11.7508
 update:11.7473
 model:11.5421
 go:11.4348
 clear:11.3391
 next:10.5838
 rows:10.4401
 selected:10.2903
 cleared:10.0884
 available:9.92774
 f:9.88171
 result:9.6548

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <grid>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {grid: ?, rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: grid
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: grid
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
 =:22.2482
=:14.8447
::14.4187
With:14.2124
 :14.1906
':13.974	rejected
2:13.383
 ::13.0749
1:12.6436
  :12.3655
Updated:12.253
_:12.2148
New:12.097
Fil:11.9667
Update:11.5274
To:11.4227
Fill:11.31
    :11.3019
After:11.2867
In:11.1128
Copy:11.069

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid =

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid =
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "rowToFill" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 fill:21.5233
 :14.8925
 update:14.8842
fill:14.3926
 List:13.7675	rejected
 (:13.7655

:12.647
 clear:12.3081
  :12.1476
 grid:11.9469
 filled:10.5605	rejected
 if:10.5284
 fil:10.4069
    :9.55639
 filling:9.42036	rejected
 filter:9.33659	rejected
 list:9.31835	rejected
 Grid:9.2855	rejected
 fol:9.22567	rejected
 f:9.19022
 F:8.94809

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fill

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fill
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <fill>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "fill"))
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  fill
Nature of error: Variable fill is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: fill
LSP: Generating Completions for prefix: fill
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "RowInGrid"
root ::= completions

Top 20 Logits:
Row:23.639
row:14.2515	rejected
Rows:14.0401	rejected
Ro:13.7265
_:13.442	rejected
In:13.4128	rejected
Grid:13.0722	rejected
l:13.0255	rejected
R:12.6969
(:12.2987	rejected
Rule:12.0055	rejected
er:11.9119	rejected
Root:11.2055	rejected
Raw:11.1434	rejected
ROW:11.1106	rejected
E:11.0862	rejected
ow:11.0546	rejected
 Row:11.0434	rejected
in:11.0016	rejected
G:10.9588	rejected
Cell:10.9524	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRow

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRow
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <fillRow>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "fillRow"))
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  fillRow
Nature of error: Variable fillRow is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: fillRow
LSP: Generating Completions for prefix: fillRow
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "InGrid"
root ::= completions

Top 20 Logits:
In:25.8714
in:15.6863	rejected
(:14.6677	rejected
IN:12.6909	rejected
Grid:12.4026	rejected
With:12.0912	rejected
Empty:11.2565	rejected
Of:11.2289	rejected
From:11.2074	rejected
For:10.9103	rejected
Int:10.871	rejected
n:10.7187	rejected
Ind:10.6268	rejected
I:10.6184
And:10.5607	rejected
E:10.4832	rejected
On:10.3708	rejected
To:10.3379	rejected
Row:10.3167	rejected
i:10.2523	rejected
Index:10.072	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowIn

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowIn
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <fillRowIn>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "fillRowIn"))
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  fillRowIn
Nature of error: Variable fillRowIn is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: fillRowIn
LSP: Generating Completions for prefix: fillRowIn
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Grid"
root ::= completions

Top 20 Logits:
Grid:24.375
G:16.2572
GridView:14.7902	rejected
grid:14.5402	rejected
GR:13.8907	rejected
Group:13.1564	rejected
Graph:13.0367	rejected
Gr:12.9421
Grad:12.833	rejected
(:12.6011	rejected
Model:12.4681	rejected
Cell:12.4393	rejected
List:12.2123	rejected
GB:12.1942	rejected
Column:12.1061	rejected
Row:11.8383	rejected
Game:11.74	rejected
g:11.7309	rejected
 Grid:11.5372	rejected
Graphics:11.273	rejected
A:11.1517	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <fillRowInGrid>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (([[String]], Int, String) -> [[String]])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: fillRowInGrid
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: fillRowInGrid
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "in"
root ::= new-tokens

Top 20 Logits:
(:21.7209
 (:16.1947
((:15.1462	prefix accepted:(
 grid:13.5433	rejected
([:12.383	prefix accepted:(
():11.3219	prefix accepted:(
[:10.8702	rejected
(!:10.7493	prefix accepted:(
.(:10.7007	rejected
 :10.6983

:10.6895
(":10.6221	prefix accepted:(
!(:10.5889	prefix accepted:!
 in:10.4231
::10.2362
(?:10.1511	prefix accepted:(
?(:10.0736	rejected
 ((:9.96259	prefix accepted: (
  :9.83804
({:9.46914	prefix accepted:(
(@:9.43987	prefix accepted:(

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [[String]]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in end in
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [[String]]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in end in
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Grid, Row, Emoji)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "rowToFill" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
grid:21.1584
 grid:14.1865
update:13.9876
clear:13.6603

:13.6461
row:12.8228
model:12.7675
List:11.6122	rejected
g:10.9571
selected:10.9305
0:10.6688
list:10.5932	rejected
copy:10.3058	rejected
fill:10.2585
available:10.1211
 :10.0126
Grid:9.98919	rejected
action:9.90221
empty:9.82948	rejected
gr:9.60819
this:9.57946	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <grid>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Grid, Row, Emoji)
  LSP: Info: Seft type: [[String]]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana = (Prod [(Var "Grid"); (Var "Row"); (Var "Emoji")]);
           syn = (Var "Grid")})))
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in end in
  LSP: Info: ALL errors:
Error in term:
  grid
Nature of error: Expecting type (Grid, Row, Emoji) but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: grid
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: grid
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:21.1971
 ,:15.6866
 row:13.905	rejected
::12.1503
):11.8014
,(:11.1873	prefix accepted:,
 ::10.9184
),:10.6094	prefix accepted:)
.:10.5824	rejected
,,:10.566	prefix accepted:,
 :9.93277
)(:9.87241	prefix accepted:)
(),:9.69956	prefix accepted:(
  :9.11069

:8.77003
(:9.69956
 selected:8.59802	rejected
',:8.50052	rejected
 ?:8.45654	rejected
row:8.43483	rejected
 +:8.34358

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Grid, Row, Emoji)
  LSP: Info: Seft type: ([[String]], ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana = (Prod [(Var "Grid"); (Var "Row"); (Var "Emoji")]);
           syn = (Prod [(Var "Grid"); (Unknown Internal)])})))
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in end in
  LSP: Info: ALL errors:
Error in term:
  grid, ?
Nature of error: Expecting type (Grid, Row, Emoji) but got inconsistent type (Grid, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Grid, Row, Emoji)
  LSP: Info: Seft type: ([[String]], ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana = (Prod [(Var "Grid"); (Var "Row"); (Var "Emoji")]);
           syn = (Prod [(Var "Grid"); (Unknown Internal)])})))
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in end in
  LSP: Info: ALL errors:
Error in term:
  grid, ?
Nature of error: Expecting type (Grid, Row, Emoji) but got inconsistent type (Grid, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in end in
  LSP: Info: ALL errors:
Error in term:
  grid, ?
Nature of error: Expecting type (Grid, Row, Emoji) but got inconsistent type (Grid, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "rowToFill" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 row:21.4417
row:14.8694
 :13.168
 selected:11.6897
 (:11.4935
 Row:10.7092	rejected
  :10.1023
 ro:10.0671
 List:9.80049	rejected
 available:9.76208
 col:9.62751	rejected
 i:9.51972
 Int:9.49729	rejected
 int:9.42139

:9.31793
 -:9.14915
 em:9.09784	rejected
 ,:9.05615	rejected
 r:8.95058
 list:8.85066	rejected
 if:8.55874

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, row

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, row
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <row>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "row"))
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in end in
  LSP: Info: ALL errors:
Error in term:
  grid, row
Nature of error: Expecting type (Grid, Row, Emoji) but got inconsistent type (Grid, ?)  
Error in term:
  row
Nature of error: Variable row is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: row
LSP: Generating Completions for prefix: row
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ToFill"
root ::= completions

Top 20 Logits:
To:22.9791
,:15.6529	rejected
to:14.2345	rejected
T:14.1556
 -:11.681	rejected
_:11.6277	rejected
 to:11.5891	rejected
TO:11.5052	rejected
):11.3973	rejected
-:11.2971	rejected
 To:11.1438	rejected
 ,:11.0861	rejected
t:10.8647	rejected
Top:10.8562	rejected
 +:10.8199	rejected
ToList:10.7908	rejected
.:10.4768	rejected
ToString:10.2851	rejected
::10.2512	rejected
Of:9.98141	rejected
+:9.93009	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowTo

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowTo
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <rowTo>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "rowTo"))
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in end in
  LSP: Info: ALL errors:
Error in term:
  grid, rowTo
Nature of error: Expecting type (Grid, Row, Emoji) but got inconsistent type (Grid, ?)  
Error in term:
  rowTo
Nature of error: Variable rowTo is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: rowTo
LSP: Generating Completions for prefix: rowTo
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Fill"
root ::= completions

Top 20 Logits:
Fill:23.9678
F:13.8289
fill:13.659	rejected
Find:13.3108	rejected
Filter:13.254	rejected
Fi:12.9503
Clear:12.5114	rejected
Full:12.2419	rejected
Fil:11.905
FI:11.6207	rejected
Equal:11.5868	rejected
St:11.3894	rejected
Fail:11.2755	rejected
Fetch:11.1986	rejected
Copy:11.0887	rejected
Fl:11.0463	rejected
Field:10.7934	rejected
Feed:10.5743	rejected
Free:10.5337	rejected
Make:10.4877	rejected
 fill:10.4501	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <rowToFill>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in end in
  LSP: Info: ALL errors:
Error in term:
  grid, rowToFill
Nature of error: Expecting type (Grid, Row, Emoji) but got inconsistent type (Grid, Row)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: rowToFill
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: rowToFill
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:20.9592
 ,:15.7808
 -:15.4209
):13.658
-:13.0832
 +:12.9958
),:11.5216	prefix accepted:)
 selected:11.2186	rejected
::11.0469
+:10.9327
 :10.9089
.:10.5019	rejected
,,:10.0461	prefix accepted:,
 %:9.81396	rejected
(),:9.71284	prefix accepted:(
 ::9.63131
 ):9.57906
  :9.51964
 /:9.21098
 *:8.87833

:8.70659

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Grid, Row, Emoji)
  LSP: Info: Seft type: ([[String]], Int, String)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Grid, Row, Emoji)
  LSP: Info: Seft type: ([[String]], Int, String)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Emoji
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "rowToFill" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 selected:18.7748
selected:13.5504
 ""):13.2043	prefix accepted: ""
 :12.7682
 ":12.3565
 "":13.2043
 em:11.056	rejected
 Em:10.9005	rejected
 available:10.7826
 grid:10.3521
 select:10.0814

:9.94876
 model:9.92963
 s:9.8907
 List:9.88009	rejected
  :9.72049
 "",:9.60061	prefix accepted: ""
 Selected:9.57625	rejected
 (:9.4843
 ?:8.86349	rejected
 current:8.77639	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selected

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selected
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <selected>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Emoji
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "selected"))
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in end in
  LSP: Info: ALL errors:
Error in term:
  selected
Nature of error: Variable selected is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: selected
LSP: Generating Completions for prefix: selected
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Emoji"
root ::= completions

Top 20 Logits:
E:22.5151
Em:13.8925
_:11.3497	rejected
):11.2808	rejected
emo:11.1199	rejected
 E:10.9474	rejected
EM:10.2406	rejected
Empty:9.90355	rejected
.:9.86261	rejected
 em:9.824	rejected
em:9.78233	rejected
Grid:9.52061	rejected
G:9.30967	rejected
Cell:9.16036	rejected
 Em:9.01771	rejected
e:8.93901	rejected
Element:8.65745	rejected
Model:8.60603	rejected
Е:8.51688	rejected
Value:8.47515	rejected
Item:8.38193	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedE

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedE
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <selectedE>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Emoji
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "selectedE"))
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in end in
  LSP: Info: ALL errors:
Error in term:
  selectedE
Nature of error: Variable selectedE is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: selectedE
LSP: Generating Completions for prefix: selectedE
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "moji"
root ::= completions

Top 20 Logits:
mo:31.4684
omo:20.3437	rejected
imo:19.0431	rejected
emo:17.3217	rejected
MO:16.8314	rejected
мо:16.7896	rejected
o:16.125	rejected
 mo:15.9762	rejected
jo:15.464	rejected
mm:15.4018	rejected
oo:15.3664	rejected
mu:15.2143	rejected
more:15.0507	rejected
no:14.9093	rejected
mor:14.4265	rejected
po:13.9679	rejected
ko:13.8915	rejected
my:13.8784	rejected
amo:13.7435	rejected
ermo:13.7269	rejected
cho:13.581	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmo

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmo
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <selectedEmo>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Emoji
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "selectedEmo"))
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in end in
  LSP: Info: ALL errors:
Error in term:
  selectedEmo
Nature of error: Variable selectedEmo is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: selectedEmo
LSP: Generating Completions for prefix: selectedEmo
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ji"
root ::= completions

Top 20 Logits:
ji:28.761
 ji:16.5096	rejected
ja:15.1673	rejected
iji:15.1016	rejected
jo:14.5405	rejected
yi:13.673	rejected
ju:13.4729	rejected
jih:12.9711	rejected
 Ji:12.8981	rejected
hi:12.439	rejected
xi:12.3478	rejected
json:11.649	rejected
ei:11.2031	rejected
jp:11.1815	rejected
hui:11.1319	rejected
cii:10.9454	rejected
je:10.8397	rejected
zi:10.69	rejected
idi:10.2575	rejected
js:10.2474	rejected
ii:10.1723	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <selectedEmoji>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Emoji
  LSP: Info: Seft type: String
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: selectedEmoji
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: selectedEmoji
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
):21.3436
 ):16.7677
),:14.631	prefix accepted:)
 in:13.9031	rejected
);:13.179	prefix accepted:)
)):12.5354
)]:12.4198	prefix accepted:)
,:11.8193
)\:11.3248	prefix accepted:)
)":10.999	prefix accepted:)
.:10.8515	rejected
 :10.5499
 +:10.5492
)::10.3617	prefix accepted:)
)|:10.2241	prefix accepted:)

:10.0826
)}:10.0521	prefix accepted:)
).:10.0435	rejected
)?:9.9094	prefix accepted:)
)(:9.71734	prefix accepted:)
 -:9.70133

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji)

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [[String]]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "in"
root ::= new-tokens

Top 20 Logits:
 in:20.9438
 :15.0701
in:14.8113

:13.9785
  :12.7868
    :10.0935
   :10.028
 and:9.28114	rejected
     :9.27622
      :9.13818
 ?:9.0341	rejected
 ;:8.98529	rejected
 ,:8.68208
                :8.3544
        :8.15242
	:8.05418	rejected
       :7.7143
 In:7.6145	rejected
         :7.55567
 i:7.5151
 then:7.43635	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {grid: Grid, rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: grid rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "rowToFill" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:21.766
 :19.6513
  :18.4772
    :16.7317
      :16.3063
        :16.0638
     :15.9274
 (:15.6322
   :15.0496
          :15.0046
         :14.8741
                :14.5325
            :14.1648
       :13.8896
           :13.3329
	:13.0843	rejected
              :12.9748
             :12.9267
               :12.2538
 {:11.4004	rejected
(:11.2687

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in


LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {grid: Grid, rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: grid rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "rowToFill" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
         :22.2242
           :18.2968
        :18.2727
       :17.6074
          :17.49
     :14.995
             :14.5819
      :14.5556
            :14.5521
	:13.4458	rejected
                :13.1884
    :13.1832
  :13.0906
   :12.8583
               :12.8304
              :12.2686
(:11.8509
 :11.6953

:11.5249
 (:9.94146
(*:9.07258	prefix accepted:(

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
         

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
         
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {grid: Grid, rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: grid rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "rowToFill" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 (:23.0829
 update:15.3084
 print:15.2043	rejected
 grid:14.9136
 [:14.4341
 ((:14.3638	prefix accepted: (
 if:14.2758
 let:14.0012
 model:13.866
 match:13.7549	rejected
 ([:13.6827	prefix accepted: (
 (*:13.3123	prefix accepted: (
 List:13.1832	rejected
 {:13.1092	rejected
 case:12.7746
 #:12.767	rejected
 return:12.5847	rejected
 in:12.2407
 println:12.1601	rejected
 printf:11.5448	rejected
 clear:11.5283

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {grid: Grid, rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {grid: Grid, rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {grid: Grid, rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: grid rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: grid rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "rowToFill" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
grid:20.6347
 grid:14.674
update:14.5409
fill:14.4359

:12.3282
clear:12.1798
g:11.8632
List:10.8725	rejected
model:10.6871
 :10.5497
  :10.1161
row:9.92953
selected:9.779
 update:9.72907
list:9.61432	rejected
select:9.48111
updated:9.3152	rejected
in:9.20882
,:9.11707	rejected
print:9.10203	rejected
up:8.90849

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <grid>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [[String]]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = (Var "Model"); syn = (Var "Grid")})))
  LSP: Info: Typing Context: {grid: Grid, rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  grid
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: grid
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: grid
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: grid rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:20.763
 ,:16.4617
,,:11.6069	prefix accepted:,
 :11.3685
):11.2332
::11.0354
  :10.9109
 ::10.2715
.:9.99924	rejected
),:9.80566	prefix accepted:)

:9.71713
    :9.30775
(),:8.95217	prefix accepted:(
   :8.93361
                :8.74067
;:8.73854	rejected
,(:8.60805	prefix accepted:,
,":8.50406	prefix accepted:,
',:8.44719	rejected
 selected:8.35488	rejected
 +:8.28873

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model");
           syn = (Prod [(Var "Grid"); (Unknown Internal)])})))
  LSP: Info: Typing Context: {grid: Grid, rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  grid, ?
Nature of error: Expecting type Model but got inconsistent type (Grid, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model");
           syn = (Prod [(Var "Grid"); (Unknown Internal)])})))
  LSP: Info: Typing Context: {grid: Grid, rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  grid, ?
Nature of error: Expecting type Model but got inconsistent type (Grid, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {grid: Grid, rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  grid, ?
Nature of error: Expecting type Model but got inconsistent type (Grid, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: grid rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: grid rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "rowToFill" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 selected:19.5155
selected:14.5137
 :13.2207
 em:12.1227	rejected
 "",:12.0955	prefix accepted: ""
 select:11.682
 ":11.5007
 s:10.4206
 grid:10.1978
 Selected:10.1765	rejected
  :10.0266
 sele:9.86449
 "":12.0955
 selection:9.6635	rejected
 Em:9.52231	rejected
 ,:9.48543	rejected

:9.38699
 sel:9.24903
 available:9.18509
 row:9.07761
 se:8.93931

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selected

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selected
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <selected>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "selected"))
  LSP: Info: Typing Context: {grid: Grid, rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  selected
Nature of error: Variable selected is not bound  
Error in term:
  grid, selected
Nature of error: Expecting type Model but got inconsistent type (Grid, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: selected
LSP: Generating Completions for prefix: selected
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: grid rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Emoji"
root ::= completions

Top 20 Logits:
E:24.0776
Em:16.967
 E:13.8437	rejected
e:13.2659	rejected
 Em:11.8403	rejected
em:11.3928	rejected
El:11.2942	rejected
emo:11.2006	rejected
 em:10.8513	rejected
Selected:10.669	rejected
O:10.5607	rejected
Ed:10.3862	rejected
EM:10.3537	rejected
Empty:10.214	rejected
Available:10.1959	rejected
Ex:9.69149	rejected
Drop:9.6765	rejected
Е:9.51708	rejected
Element:9.50324	rejected
Tool:9.45377	rejected
Er:9.43731	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedE

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedE
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <selectedE>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "selectedE"))
  LSP: Info: Typing Context: {grid: Grid, rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  grid, selectedE
Nature of error: Expecting type Model but got inconsistent type (Grid, ?)  
Error in term:
  selectedE
Nature of error: Variable selectedE is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: selectedE
LSP: Generating Completions for prefix: selectedE
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: grid rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "moji"
root ::= completions

Top 20 Logits:
mo:31.1743
emo:18.9312	rejected
omo:18.9126	rejected
imo:16.8814	rejected
MO:16.8547	rejected
 mo:16.6627	rejected
jo:15.8891	rejected
mu:14.9855	rejected
amo:14.8485	rejected
мо:14.8257	rejected
oo:14.6701	rejected
no:14.4128	rejected
mm:14.2537	rejected
o:13.8597	rejected
cho:13.367	rejected
Mo:12.992	rejected
po:12.8686	rejected
zo:12.8281	rejected
lem:12.5918	rejected
mot:12.5483	rejected
ermo:12.4094	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmo

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmo
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <selectedEmo>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "selectedEmo"))
  LSP: Info: Typing Context: {grid: Grid, rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  selectedEmo
Nature of error: Variable selectedEmo is not bound  
Error in term:
  grid, selectedEmo
Nature of error: Expecting type Model but got inconsistent type (Grid, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: selectedEmo
LSP: Generating Completions for prefix: selectedEmo
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: grid rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ji"
root ::= completions

Top 20 Logits:
ji:30.52
iji:18.2372	rejected
 ji:17.4215	rejected
jo:16.1897	rejected
jih:15.4143	rejected
ja:15.3936	rejected
j:15.0655
yi:14.6941	rejected
ij:14.1796	rejected
J:13.9557	rejected
 Ji:13.3937	rejected
je:12.8038	rejected
jin:12.5979	rejected
ijo:12.1536	rejected
qi:12.1236	rejected
js:11.6224	rejected
xi:11.4869	rejected
ject:11.4654	rejected
jem:11.4536	rejected
yj:11.0447	rejected
json:10.8053	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <selectedEmoji>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: String
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {grid: Grid, rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  grid, selectedEmoji
Nature of error: Expecting type Model but got inconsistent type (Grid, Emoji)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: selectedEmoji
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: selectedEmoji
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: grid rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:21.0397
 ,:14.6411
 available:11.0891	rejected
):10.7276
,,:10.5049	prefix accepted:,
),:10.482	prefix accepted:)
 :10.3773
.:10.0551	rejected
 +:10.0338
::9.69402
 selected:9.47936	rejected
  :9.18466

:8.63822
.,:8.02967	rejected
',:8.01515	rejected
 ::7.99783
available:7.851	rejected
;:7.83426	rejected
Available:7.75434	rejected
(),:7.50814	prefix accepted:(
:::7.46282

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {grid: Grid, rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {grid: Grid, rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Emoji]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {grid: Grid, rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: grid rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: grid rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "rowToFill" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 available:19.9279
available:15.7728
 :13.6208
 selected:12.7471
 av:11.6987
 avail:10.8082
 [:10.5508
 a:10.4903
  :10.2164
 em:9.70566	rejected
 grid:9.64626
 List:9.37258	rejected
 select:9.28977
 ":9.1271
 ""):8.9817	prefix accepted: ""
 list:8.96068	rejected
 Em:8.90566	rejected
 Av:8.86613	rejected

:8.72099
 [":8.71424	prefix accepted: [
 row:8.56211

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, available

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, available
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <available>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Emoji]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "available"))
  LSP: Info: Typing Context: {grid: Grid, rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  available
Nature of error: Variable available is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: available
LSP: Generating Completions for prefix: available
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: grid rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Emojis"
root ::= completions

Top 20 Logits:
Em:23.7822
E:12.9236
em:12.77	rejected
Emp:11.8301	rejected
Im:11.7661	rejected
 Em:11.7319	rejected
EM:11.667	rejected
_:11.0604	rejected
Om:10.4362	rejected
):10.4093	rejected
Er:10.3368	rejected
M:10.1782	rejected
 em:9.70548	rejected
Tem:9.69426	rejected
El:9.61827	rejected
G:9.55477	rejected
.:9.46724	rejected
Rem:9.38923	rejected
Ext:9.35861	rejected
Eng:9.26685	rejected
Empty:9.25335	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEm

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEm
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <availableEm>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Emoji]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "availableEm"))
  LSP: Info: Typing Context: {grid: Grid, rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  availableEm
Nature of error: Variable availableEm is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: availableEm
LSP: Generating Completions for prefix: availableEm
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: grid rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ojis"
root ::= completions

Top 20 Logits:
oj:30.7506
jos:18.0076	rejected
jo:15.0413	rejected
ij:14.7152	rejected
ois:13.8287	rejected
os:12.7266	rejected
oz:12.6229	rejected
j:12.3347	rejected
ijo:12.2003	rejected
o:12.1436
uj:11.2941	rejected
ot:11.0953	rejected
ok:11.0616	rejected
obj:10.7783	rejected
aj:10.3355	rejected
oi:10.1137	rejected
jor:9.83042	rejected
otos:9.60528	rejected
ox:9.57355	rejected
job:9.53798	rejected
jon:9.43455	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmoj

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmoj
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <availableEmoj>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Emoji]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "availableEmoj"))
  LSP: Info: Typing Context: {grid: Grid, rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  availableEmoj
Nature of error: Variable availableEmoj is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: availableEmoj
LSP: Generating Completions for prefix: availableEmoj
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: grid rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "is"
root ::= completions

Top 20 Logits:
is:28.4759
ins:16.3975	rejected
Is:16.3245	rejected
i:14.31
ises:14.2691	rejected
ies:14.2342	rejected
ios:13.2576	rejected
im:13.1001	rejected
in:12.837	rejected
isis:12.2363	rejected
isi:12.0279	rejected
ism:11.9873	rejected
ij:11.8553	rejected
ис:11.8203	rejected
 is:11.5872	rejected
ias:11.4399	rejected
iss:11.4119	rejected
isan:11.3591	rejected
ines:11.1935	rejected
iz:11.1684	rejected
ir:11.1051	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <availableEmojis>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Emoji]
  LSP: Info: Seft type: [String]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {grid: Grid, rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: availableEmojis
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: availableEmojis
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: grid rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
):20.1547
 ):15.0007
 end:14.6282	rejected

:12.9268
)):12.3564
);:11.9639	prefix accepted:)
 in:11.6723	rejected
),:11.3034	prefix accepted:)
,:11.119
)`:11.0517	prefix accepted:)
 :10.8791
)":10.4184	prefix accepted:)
)]:10.1222	prefix accepted:)
)}:9.90554	prefix accepted:)
  :9.83059
)\:9.66385	prefix accepted:)
)':9.62646	prefix accepted:)
end:9.33111	rejected
)))):9.30202	prefix accepted:))
)|:9.29703	prefix accepted:)
)*:8.98316	prefix accepted:)

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis)

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {grid: Grid, rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 end:17.9691

:16.9067
 :15.0397
  :14.5925
 in:14.1856	rejected
end:13.5776
    :13.4434
        :13.0955
      :13.0038
                :12.6476
     :12.536
          :12.4025
   :11.9538
            :11.8792
         :10.85
              :10.7685
       :10.7607
           :10.7435
             :10.6288
 #:10.5522	rejected
	:10.3936	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <case end>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Case expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Model, Action) -> Model)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "in"
root ::= new-tokens

Top 20 Logits:
 in:17.5239

:16.3624
 :15.2952
  :14.7356
    :12.7376
   :11.7082
      :11.6887
in:11.6139
     :11.521
;:11.4957	rejected
        :11.4209
 #:11.0378	rejected
                :10.9435
	:9.92262	rejected
 ;;:9.89612	rejected
;;:9.82167	rejected
 end:9.7324	rejected
       :9.71613
 with:9.6541	rejected
          :9.57665
         :9.4163

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:18.7129
  :15.9013
 :15.5533
    :14.4176
      :13.6504
     :13.0367
   :12.94
        :12.5927
                :12.3412
          :12.2568
            :11.5115
       :11.4906
           :11.4106
              :11.1796
	:11.1582	rejected
 #:10.9627	rejected
             :10.6164
         :10.4882
               :10.1708
;:9.87143	rejected
`:9.72493	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in


LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
  :18.728

:18.4038
    :16.9552
        :16.2363
      :15.92
          :15.8238
```:15.2987	rejected
     :14.8421
                :14.6813
#:14.6717	rejected
            :14.5914
 :14.5516
              :13.9348
   :13.8848
           :13.7215
             :13.201
       :13.1155
         :13.0786
"":12.7484
	:12.7275	rejected
end:12.6645	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:21.2302
 #:14.8377	rejected
	:14.8198	rejected
 ```:14.4368	rejected
 """:12.599	prefix accepted: ""
 *:12.5483	rejected
 }:12.2248	rejected
 `:12.1807	rejected
 let:11.9003
 (*:11.8427	prefix accepted: (
 *):11.6831	rejected
 type:11.5721
:11.5375	rejected
 ":11.4859
 "":12.599
 */:11.3245	rejected
 ;;:11.2762	rejected
 ;:11.2286	rejected
 end:11.1638	rejected
 model:11.0099
 ):10.9832	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  


LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
#:15.7092	rejected
let:15.1858
type:13.5394

:12.7564
  :12.3285
 :11.3037
(*:10.8589	prefix accepted:(
    :10.2985
model:10.2917
module:10.2696	rejected
 #:10.2024	rejected
open:9.79475	rejected
fun:9.56185
##:9.49087	rejected
{:9.35019	rejected
```:9.20757	rejected
################:9.19921	rejected
print:9.16088	rejected
   :9.15941
     :8.94911
E:8.94573	rejected
Rejected the highest logit candidate # with logit -inf

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 view:13.6357
 select:11.3693
 main:11.351
 model:11.3158
 get:11.0968
 em:10.7174
 render:10.7154
 init:10.4843
 string:10.2278
 draw:9.98794
 action:9.86009
 is:9.80853
 equal:9.79252
 update:9.69584
 actions:9.53918
 Em:9.47745	rejected
 eq:9.43979
 stamp:9.42875
 h:9.27647
 make:9.26799
 print:9.25926

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <view>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {view: ?, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: view
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: view
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
::15.1613
_:12.9307
Model:11.9619
 ::11.1658
Grid:10.9337
 =:10.7615
E:10.6041
Cell:10.5977
Action:10.0984
Row:9.83918
port:9.57097
 (:9.5106
Main:9.44469
Button:9.18063
Select:8.8659
Em:8.82433
 model:8.80844	rejected
Selected:8.59381
(:8.45872
List:8.43641
Actions:8.32078

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view:

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view:
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >:<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Annotation
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {view: ?, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Annotation
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {view: ?, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty type hole
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex or complete: :
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: :
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ":"
new-tokens ::= whitespace | "(" | "()" | "+" | "Action" | "Bool" | "Col" | "Emoji" | "Float" | "Grid" | "Int" | "Model" | "Row" | "String" | "[" | constructor
root ::= completions | new-tokens

Top 20 Logits:
 Model:16.7799
 (:15.4229
 ?:14.2216	rejected
 ((:13.1663	prefix accepted: (
 Grid:13.1348
 (?:12.6518	prefix accepted: (
 View:12.5587
 ([:12.2347	prefix accepted: (
 Em:11.4096
 ():11.1668
 [:11.0871
 Int:11.0032
 :10.837
 Row:10.637
 [[:10.3362	prefix accepted: [
Model:10.1989
 Action:9.99138
 Render:9.68897
 {:9.677	rejected
 (_:9.50654	rejected
 <:9.29795	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Model>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: Model
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Model
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
new-tokens ::= whitespace | "(" | "+" | "," | "->" | "="
root ::= completions | new-tokens

Top 20 Logits:
 ->:19.636
->:12.9147
 =>:12.8523	prefix accepted: =
 *:12.1614	rejected
 =:12.8523
 :11.2935
 #:11.1455	rejected
 -:11.0703
,:10.7931
 ~:10.6977	rejected
 +:10.6613
 <:10.0378	rejected
 >:9.85324	rejected
 →:9.60069	rejected
 -->:9.55811	prefix accepted: -
 >>:9.37733	rejected

:9.37543
 &:9.23153	rejected
 -(:9.152	prefix accepted: -
*:9.1406	rejected
 @:8.98724	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model ->

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model ->
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >-><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Function type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Function type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty type hole
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex or complete: ->
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ->
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "+" | "Action" | "Bool" | "Col" | "Emoji" | "Float" | "Grid" | "Int" | "Model" | "Row" | "String" | "[" | constructor
root ::= new-tokens

Top 20 Logits:
 Html:13.6571
 Grid:13.1589
 View:12.4482
 String:12.4241
 [:11.8666
 ?:11.3692	rejected
 Em:11.1813
 _:11.0056	rejected
 Action:10.8678
 Model:10.6014
 [[:10.5202	prefix accepted: [
 (:10.5087
 V:10.4077
 E:10.3384
 DOM:10.3017
 Dom:10.1887
 React:10.1845
 <:10.0552	rejected
 Node:9.9348
 Row:9.88608
 ():9.83654

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> Html

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> Html
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Html>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ (FreeTypeVariable "Html"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  Html
Nature of error: Type variable Html is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Html
LSP: Generating Completions for prefix: Html
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
 =:12.6679	rejected
 Action:12.0485	rejected
.:11.8521	rejected
(:11.1491	rejected
<:10.7296	rejected
Action:10.25
 Msg:9.53161	rejected
 Model:8.9428	rejected
Node:8.90944
Model:8.79095
 Element:8.77009	rejected
 View:8.6768	rejected
_:8.66895
 in:8.65752	rejected
 Event:8.63455	rejected
=:8.59227	rejected
 Node:8.49684	rejected
 +:8.49352	rejected
 E:8.44019	rejected

:8.43362	rejected
():8.40406	rejected
Rejected the highest logit candidate  = with logit -inf

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlAction

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlAction
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlAction>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ (FreeTypeVariable "HtmlAction"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  HtmlAction
Nature of error: Type variable HtmlAction is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlAction
LSP: Generating Completions for prefix: HtmlAction
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
 Action:13.6028	rejected
 =:13.3028	rejected
(:11.7029	rejected
 Msg:10.2973	rejected
 in:10.0707	rejected
 *:10.0421	rejected
<:10.0157	rejected
=:9.75922	rejected
[:9.41519	rejected
.:9.40507	rejected
 Em:9.33652	rejected
 Model:9.33223	rejected
():9.17439	rejected
 (:8.78358	rejected
 [:8.72408	rejected
 Event:8.67065	rejected
 :8.65266	rejected
*:8.57173	rejected

:8.54704	rejected
 action:8.4128	rejected
 _:8.31995	rejected
Rejected the highest logit candidate  Action with logit -inf

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResult

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResult
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlActionResult>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ (FreeTypeVariable "HtmlActionResult"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  HtmlActionResult
Nature of error: Type variable HtmlActionResult is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlActionResult
LSP: Generating Completions for prefix: HtmlActionResult
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
 =:13.5295	rejected
<:10.7232	rejected
 Action:10.6794	rejected
(:10.5433	rejected
=:9.57484	rejected
 Msg:9.21367	rejected
 :9.20537	rejected
 *:9.06157	rejected
 in:9.04217	rejected

:8.95541	rejected
 View:8.60757	rejected
 ->:8.54437	rejected
 Model:8.45574	rejected
 Html:8.24834	rejected
 [:8.20949	rejected
.:8.20664	rejected
 #:8.13584	rejected
():8.10443	rejected
 _:8.00861	rejected
 String:8.00088	rejected
*:7.89414	rejected
Rejected the highest logit candidate  = with logit -inf

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultType

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultType
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlActionResultType>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ (FreeTypeVariable "HtmlActionResultType"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  HtmlActionResultType
Nature of error: Type variable HtmlActionResultType is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlActionResultType
LSP: Generating Completions for prefix: HtmlActionResultType
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
 =:13.3438	rejected
(:11.0822	rejected
<:10.2564	rejected
 :9.65407	rejected
 Action:9.63157	rejected
 in:9.11424	rejected

:8.9905	rejected
=:8.92494	rejected
 ->:8.91805	rejected
.:8.76797	rejected
 *:8.72704	rejected
 +:8.32431	rejected
():8.22299	rejected
([:8.05435	rejected
Model:8.04011
Action:7.95679
(*:7.95659	rejected
[:7.88784	rejected
Def:7.80386
 (:7.72933	rejected
 Model:7.64156	rejected
Rejected the highest logit candidate  = with logit -inf

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModel

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModel
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlActionResultTypeModel>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ (FreeTypeVariable "HtmlActionResultTypeModel"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  HtmlActionResultTypeModel
Nature of error: Type variable HtmlActionResultTypeModel is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlActionResultTypeModel
LSP: Generating Completions for prefix: HtmlActionResultTypeModel
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
 =:11.9044	rejected
Action:11.69
 Action:9.97985	rejected
View:9.72445
List:9.04851
(:8.82995	rejected
 in:8.75448	rejected
.:8.63234	rejected
Grid:8.59327
Msg:8.11513
<:7.88269	rejected
 :7.86356	rejected
Html:7.85447
String:7.79668
Type:7.78343
_:7.72074
=:7.68498	rejected
Result:7.66017
V:7.65785
():7.65534	rejected
Component:7.58852
Rejected the highest logit candidate  = with logit -inf

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelAction

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelAction
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlActionResultTypeModelAction>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ (FreeTypeVariable "HtmlActionResultTypeModelAction"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  HtmlActionResultTypeModelAction
Nature of error: Type variable HtmlActionResultTypeModelAction is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlActionResultTypeModelAction
LSP: Generating Completions for prefix: HtmlActionResultTypeModelAction
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
 =:11.9201	rejected
Result:11.2417
Action:11.0598
Type:9.93517
(:9.41116	rejected
 Action:9.28752	rejected
Msg:9.27168
List:9.03729
Model:9.00686
Message:8.55071
Html:8.52122
=:8.37078	rejected
Array:8.30859
String:8.24369
<:8.23901	rejected
 in:8.17409	rejected
Grid:7.99326
Res:7.94799
View:7.90759
.:7.88298	rejected
():7.75585	rejected
Rejected the highest logit candidate  = with logit -inf

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResult

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResult
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlActionResultTypeModelActionResult>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ (FreeTypeVariable "HtmlActionResultTypeModelActionResult"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  HtmlActionResultTypeModelActionResult
Nature of error: Type variable HtmlActionResultTypeModelActionResult is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlActionResultTypeModelActionResult
LSP: Generating Completions for prefix: HtmlActionResultTypeModelActionResult
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
Type:12.7684
 =:11.5842	rejected
View:10.9905
Action:10.2287
Model:9.27328
(:9.16293	rejected
T:8.88852
Html:8.87912
String:8.53403
List:8.49099
Row:8.39707
.:8.36138	rejected
Msg:8.3301
Grid:8.27958
V:8.20493
Types:8.18859
E:7.89905
 in:7.87296	rejected
():7.7812	rejected
Result:7.74736
Cell:7.6202

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultType

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultType
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlActionResultTypeModelActionResultType>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ (FreeTypeVariable "HtmlActionResultTypeModelActionResultType"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  HtmlActionResultTypeModelActionResultType
Nature of error: Type variable HtmlActionResultTypeModelActionResultType is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlActionResultTypeModelActionResultType
LSP: Generating Completions for prefix: HtmlActionResultTypeModelActionResultType
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
 =:12.3092	rejected
Html:10.9645
Action:10.3548
Model:10.2394
View:10.0512
Unit:9.52345
String:9.46908
Grid:9.25775
(:9.15446	rejected
=:8.74025	rejected
Element:8.72581
List:8.62465
E:8.43605
 in:8.28884	rejected
 :8.26064	rejected
Row:8.23317
Int:8.2093
V:8.20167
State:8.16122
Bool:8.13847
.:8.09179	rejected
Rejected the highest logit candidate  = with logit -inf

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModel

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModel
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlActionResultTypeModelActionResultTypeModel>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ (FreeTypeVariable "HtmlActionResultTypeModelActionResultTypeModel"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  HtmlActionResultTypeModelActionResultTypeModel
Nature of error: Type variable HtmlActionResultTypeModelActionResultTypeModel is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlActionResultTypeModelActionResultTypeModel
LSP: Generating Completions for prefix: HtmlActionResultTypeModelActionResultTypeModel
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
Action:12.611
 =:12.2568	rejected
Html:9.71146
Model:9.53408
Type:9.41733
View:9.27246
List:9.22119
Grid:9.0353
 in:9.02284	rejected
=:8.7538	rejected
Result:8.65883
V:8.39447
String:8.38553
E:8.35553
Int:8.20261
 :8.16754	rejected
Component:7.96932
Update:7.95179
State:7.87821

:7.83993	rejected
 Action:7.81626	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelAction

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelAction
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlActionResultTypeModelActionResultTypeModelAction>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ
   (FreeTypeVariable "HtmlActionResultTypeModelActionResultTypeModelAction"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  HtmlActionResultTypeModelActionResultTypeModelAction
Nature of error: Type variable HtmlActionResultTypeModelActionResultTypeModelAction is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlActionResultTypeModelActionResultTypeModelAction
LSP: Generating Completions for prefix: HtmlActionResultTypeModelActionResultTypeModelAction
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
Result:14.9934
Res:13.6647
 =:11.8486	rejected
Type:11.217
Re:10.9286
Model:10.4767
R:10.2463
Action:9.73568
Results:9.27944
T:8.8951
Html:8.84988
Rest:8.81012
=:8.7942	rejected
E:8.73266
Ref:8.43737
Types:8.37174
View:8.35885
V:8.35359
(:8.24408	rejected
 in:8.19508	rejected
Unit:8.17801

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResult

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResult
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlActionResultTypeModelActionResultTypeModelActionResult>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ
   (FreeTypeVariable
      "HtmlActionResultTypeModelActionResultTypeModelActionResult"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  HtmlActionResultTypeModelActionResultTypeModelActionResult
Nature of error: Type variable HtmlActionResultTypeModelActionResultTypeModelActionResult is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlActionResultTypeModelActionResultTypeModelActionResult
LSP: Generating Completions for prefix: HtmlActionResultTypeModelActionResultTypeModelActionResult
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
Type:15.4862
 =:12.215	rejected
T:12.1824
Typ:11.3619
Model:10.8779
Action:10.8409
Types:10.7578
Ty:10.7036
View:10.6561
type:9.77258
V:9.21155
Html:9.06596
E:9.05964
ViewModel:9.00989
=:8.9739	rejected
Grid:8.96362
String:8.85208
Row:8.68876
.:8.46252	rejected
 in:8.386	rejected
G:8.3666

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultType

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultType
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlActionResultTypeModelActionResultTypeModelActionResultType>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ
   (FreeTypeVariable
      "HtmlActionResultTypeModelActionResultTypeModelActionResultType"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  HtmlActionResultTypeModelActionResultTypeModelActionResultType
Nature of error: Type variable HtmlActionResultTypeModelActionResultTypeModelActionResultType is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlActionResultTypeModelActionResultTypeModelActionResultType
LSP: Generating Completions for prefix: HtmlActionResultTypeModelActionResultTypeModelActionResultType
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
Model:12.5668
 =:12.1703	rejected
Html:10.5165
View:10.1943
Action:10
Grid:9.53369
String:9.30677
(:9.13583	rejected
List:9.09786
=:9.06693	rejected
E:9.04495
Unit:9.02853
V:8.6778
M:8.41833

:8.41418	rejected
Element:8.38153
 in:8.35911	rejected
Int:8.32912
_:8.30432
 :8.2551	rejected
<:8.21778	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtml

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtml
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtml>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ
   (FreeTypeVariable
      "HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtml"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtml
Nature of error: Type variable HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtml is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtml
LSP: Generating Completions for prefix: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtml
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
Action:12.0651
 =:11.5981	rejected
Element:11.0795
Result:10.6809
Node:10.4511
Model:10.4393
View:10.3633
Type:10.3111
String:10.2746
V:9.73278
Html:9.71591
Msg:9.25526
E:9.01769
Grid:8.97244
T:8.85985
Attribute:8.73041
Div:8.66046
Event:8.60938
Component:8.60191
Unit:8.58764
.:8.5648	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModel

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModel
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModel>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ
   (FreeTypeVariable
      "HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModel"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModel
Nature of error: Type variable HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModel is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModel
LSP: Generating Completions for prefix: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModel
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
Action:13.5416
 =:11.9879	rejected
Model:11.6766
Html:11.0172
View:10.8421
Type:10.2075
Result:10.1766
V:9.96673
Grid:9.49761
State:9.49473
List:9.05848
E:8.89995
Element:8.89853
Component:8.61553
String:8.53869
And:8.4386
T:8.42842
=:8.42159	rejected
Event:8.35637
Node:8.30351
Update:8.24119

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelAction

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelAction
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelAction>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ
   (FreeTypeVariable
      "HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelAction"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelAction
Nature of error: Type variable HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelAction is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelAction
LSP: Generating Completions for prefix: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelAction
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
Result:14.9055
Res:12.6748
 =:11.6644	rejected
Model:11.6115
Type:10.5676
Action:10.1501
Re:10.0446
Html:9.74967
View:9.40658
Ref:9.38975
R:9.14915
E:9.05363
T:8.97426
 in:8.70716	rejected
V:8.70654
result:8.66523
=:8.55257	rejected
Update:8.55233
List:8.44716
Rest:8.38404
Grid:8.33279

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionRes

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionRes
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionRes>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ
   (FreeTypeVariable
      "HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionRes"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionRes
Nature of error: Type variable HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionRes is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionRes
LSP: Generating Completions for prefix: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionRes
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
ul:13.6187
u:12.338
 =:11.1258	rejected
ut:10.0088
 in:9.81532	rejected
Model:9.69662
Type:9.27199
Action:8.99205
...:8.70857	rejected
ule:8.58516
=:8.54301	rejected

:8.51248	rejected
Html:7.97044
ult:7.88053
ultado:7.78915
ume:7.56735
 :7.50563	rejected
T:7.303
Mod:7.29125
?:7.07374	rejected
p:6.91695

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResul

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResul
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResul>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ
   (FreeTypeVariable
      "HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResul"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResul
Nature of error: Type variable HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResul is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResul
LSP: Generating Completions for prefix: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResul
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
 =:11.653	rejected
te:11.4644
th:11.404
 in:10.8195	rejected
ter:10.1597

:9.79894	rejected
T:9.6876
Model:9.44225
Type:9.43334
 :9.25981	rejected
Action:9.11495
tt:9.09523
...:8.85005	rejected
 t:8.61076	rejected
=:8.60393	rejected
tex:8.39302
 |:7.87718	rejected
:7.80382
text:7.78507
View:7.60228
*:7.39856	rejected
Rejected the highest logit candidate  = with logit -inf

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModel

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModel
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModel>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ
   (FreeTypeVariable
      "HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModel"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModel
Nature of error: Type variable HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModel is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModel
LSP: Generating Completions for prefix: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModel
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
Action:14.1928
 =:11.6918	rejected
View:11.5737
Model:11.1018
Html:10.3311
Act:10.0325
Grid:9.56034
Result:9.30514
Type:9.18966
E:9.06548
V:9.0588
=:8.86241	rejected
Res:8.73246
List:8.69
 ->:8.5225	rejected
Actions:8.47301
M:8.36621
A:8.36058
 :8.30822	rejected
 Action:8.30146	rejected
Event:8.16029

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelAction

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelAction
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelAction>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ
   (FreeTypeVariable
      "HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelAction"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelAction
Nature of error: Type variable HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelAction is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelAction
LSP: Generating Completions for prefix: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelAction
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
Res:13.9707
Result:13.8064
Model:10.934
 =:10.6707	rejected
Type:10.5154
Re:10.4156
R:10.2621
T:9.92191
Rest:9.4625
Results:9.27666
Action:9.18487
t:9.09579
Mod:9.06366
Response:8.59808
M:8.5503
Ty:8.28595
Mode:8.25799
=:8.11427	rejected
Typ:8.04339
E:8.03205
 in:7.86019	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionRes

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionRes
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionRes>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ
   (FreeTypeVariable
      "HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionRes"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionRes
Nature of error: Type variable HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionRes is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionRes
LSP: Generating Completions for prefix: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionRes
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
ul:13.6689
u:11.9907
ut:11.0204
Model:10.7719
 =:10.6394	rejected
ult:10.4294
ultado:9.6383
Type:9.23086
Action:9.06943
l:8.90552
lt:8.8595
Mod:8.85517
ule:8.60814
T:8.07995
=:7.95445	rejected
Html:7.82269
Mode:7.67131
Result:7.61932
ull:7.6128

:7.59966	rejected
 in:7.59697	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResul

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResul
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResul>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ
   (FreeTypeVariable
      "HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResul"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResul
Nature of error: Type variable HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResul is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResul
LSP: Generating Completions for prefix: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResul
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
Model:13.3104
 =:11.2287	rejected
Action:10.3909
T:9.87787
Mode:9.81707
Type:9.76694
Html:9.6083
View:9.5197
=:9.51277	rejected
model:9.24472
Component:9.20525
th:9.18564
 in:9.18257	rejected
te:9.17605
M:9.03036
in:9.02442
E:8.65683
Result:8.48366
Actions:8.4507
Mod:8.40207
Grid:8.29721

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModel

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModel
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModel>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ
   (FreeTypeVariable
      "HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModel"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModel
Nature of error: Type variable HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModel is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModel
LSP: Generating Completions for prefix: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModel
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
Action:15.0637
Act:13.9977
 =:13.2825	rejected
Ac:11.8701
A:11.4926
Model:11.2576
View:11.0513
Actions:10.3963
Res:10.0098
Html:9.52332
Type:9.51119
V:9.34815
Mode:9.30862
=:9.3034	rejected
T:9.30029
Result:9.28996
M:9.26663
Mod:9.14472
At:9.06834
Acc:8.62008
E:8.47934

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelAction

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelAction
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelAction>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ
   (FreeTypeVariable
      "HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelAction"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelAction
Nature of error: Type variable HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelAction is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelAction
LSP: Generating Completions for prefix: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelAction
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
Res:15.0433
Result:13.0396
 =:12.3311	rejected
T:10.967
Model:10.7265
R:10.5741
Type:10.1948
Re:10.1061
Action:9.87538
Rest:9.10193
Results:8.93406
=:8.78463	rejected
Mod:8.6555
Mode:8.57178
Ty:8.43196
Response:8.37083
M:8.34842
res:8.12461
 in:8.12117	rejected
E:8.06532
t:8.00633

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionRes

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionRes
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionRes>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ
   (FreeTypeVariable
      "HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionRes"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionRes
Nature of error: Type variable HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionRes is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionRes
LSP: Generating Completions for prefix: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionRes
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
ul:13.8367
 =:12.1643	rejected
u:11.716
ult:11.6256
ut:11.3764
Model:10.5395
ule:9.56313
ultado:9.3496
Action:9.17224
T:9.12451
l:9.07637
ull:8.87433
Type:8.84018
lt:8.56159
uld:8.40929
Mod:8.3375
Html:8.26317
in:8.20496
ula:8.11809
ulo:7.87408
um:7.84373

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResul

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResul
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResul>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ
   (FreeTypeVariable
      "HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResul"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResul
Nature of error: Type variable HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResul is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResul
LSP: Generating Completions for prefix: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResul
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
Model:13.5398
 =:12.8995	rejected
Html:10.5638
Action:10.5322
T:10.3641
View:10.0492
=:9.92566	rejected
Mode:9.7662
M:9.76264
Type:9.48202
Component:8.99237
Mod:8.92686
th:8.89136
 in:8.83783	rejected
E:8.81853
Grid:8.71487
Mo:8.64098
in:8.54203
V:8.49959
model:8.42783
tt:8.39905

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModel

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModel
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModel>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ
   (FreeTypeVariable
      "HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModel"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModel
Nature of error: Type variable HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModel is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModel
LSP: Generating Completions for prefix: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModel
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
Action:15.2842
Act:14.1037
 =:13.1499	rejected
Ac:12.1987
A:11.4794
Model:11.0713
View:10.9744
Actions:10.4955
Res:9.98734
Html:9.55698
V:9.44015
=:9.39423	rejected
Mod:9.3003
At:9.29487
Mode:9.16686
Result:9.15703
Type:9.1272
M:9.09944
In:9.03624
Acc:8.89944
T:8.78609

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelAction

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelAction
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelAction>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ
   (FreeTypeVariable
      "HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelAction"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelAction
Nature of error: Type variable HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelAction is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelAction
LSP: Generating Completions for prefix: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelAction
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
Res:15.3839
Result:12.9822
 =:12.4222	rejected
Model:10.697
R:10.4951
T:10.2827
Re:10.1989
Action:10.1989
Type:9.70223
Rest:9.25578
Results:9.18118
=:9.04542	rejected
Response:8.63018
Mod:8.53872
Mode:8.43953
M:8.33221
In:8.2482

:8.07013	rejected
res:8.01588
 in:7.95525	rejected
E:7.94929

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionRes

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionRes
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionRes>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ
   (FreeTypeVariable
      "HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionRes"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionRes
Nature of error: Type variable HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionRes is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionRes
LSP: Generating Completions for prefix: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionRes
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
ul:14.1266
 =:12.0621	rejected
ult:11.6571
u:10.9671
ut:10.8642
Model:10.8144
ule:9.44656
ultado:9.25417
ull:9.13812
T:9.05927
Action:8.92994
l:8.52552
Type:8.43677
uld:8.29201
lt:8.26971
in:8.20675
Html:8.13291
 in:7.95366	rejected
Mod:7.89358
ula:7.86492
ulo:7.72103

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResult

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResult
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResult>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ
   (FreeTypeVariable
      "HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResult"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResult
Nature of error: Type variable HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResult is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResult
LSP: Generating Completions for prefix: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResult
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
 =:12.998	rejected
Model:12.2936
ype:11.8641
Type:11.0454
T:10.4905
Action:10.4786
View:10.478
Grid:9.82342
em:9.60745
t:9.60703
Result:9.60647
Html:9.53881
M:9.35103
tt:8.94708
 :8.73123	rejected
=:8.70659	rejected
 in:8.50604	rejected
E:8.38047
ViewModel:8.30013
Mode:8.23876
Ty:8.23275
Rejected the highest logit candidate  = with logit -inf

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModel

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModel
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModel>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ
   (FreeTypeVariable
      "HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModel"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModel
Nature of error: Type variable HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModel is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModel
LSP: Generating Completions for prefix: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModel
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
Action:15.4601
Act:13.4181
 =:13.0037	rejected
Ac:11.265
A:11.2465
Actions:11.2189
Model:10.9287
View:10.8393
Result:10.7287
Res:10.4775
At:9.61513
V:9.40492
Type:9.28485
Mod:9.24509
Html:9.1012
M:9.06163
E:8.98428
In:8.82759
Event:8.75449
=:8.6923	rejected
Mode:8.65224

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelAction

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelAction
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelAction>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ
   (FreeTypeVariable
      "HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelAction"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelAction
Nature of error: Type variable HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelAction is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelAction
LSP: Generating Completions for prefix: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelAction
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
Res:14.9762
Result:13.9758
 =:11.8969	rejected
R:11.0419
Rest:10.8957
Results:10.5468
Re:9.90277
Model:9.63068
T:9.40646
Type:9.29602
result:9.25773
res:9.1582
Response:9.13852
t:8.92612
Action:8.82021
Reset:8.39867
M:8.29848
=:8.23263	rejected
Resol:7.92275
Ty:7.80354

:7.76215	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionRes

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionRes
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionRes>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ
   (FreeTypeVariable
      "HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionRes"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionRes
Nature of error: Type variable HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionRes is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionRes
LSP: Generating Completions for prefix: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionRes
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
ul:12.9535
 =:11.1089	rejected
u:10.8955
ut:10.8769
ult:10.2121
Model:10.1139
ull:9.19987
ultado:9.12887
l:8.43515
lt:8.34209
ule:8.32725
 in:8.30546	rejected
uls:8.10405
ulu:8.0463
Type:7.83927
 Model:7.5977	rejected
T:7.58212
ulf:7.56997
ulty:7.24806
uly:7.05592
ulp:7.03841

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResul

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResul
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResul>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ
   (FreeTypeVariable
      "HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResul"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResul
Nature of error: Type variable HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResul is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResul
LSP: Generating Completions for prefix: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResul
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
Model:14.1172
 =:12.7151	rejected
th:10.7941
Mode:10.2515
Action:10.1891
M:9.99685
te:9.85782
View:9.43408
Html:9.41515
Type:9.39708
model:9.30288
=:9.10974	rejected
T:8.97895
Mod:8.62965
in:8.5833
 in:8.58252	rejected
ter:8.56301
Actions:8.4075
Grid:8.40322
Component:8.39148
 :8.39108	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModel

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModel
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModel>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ
   (FreeTypeVariable
      "HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModel"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModel
Nature of error: Type variable HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModel is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModel
LSP: Generating Completions for prefix: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModel
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
Action:16.0465
Act:13.9426
 =:13.2849	rejected
Ac:11.7732
A:11.6236
Model:11.2553
Actions:11.2296
View:10.8157
At:10.2626
Result:10.1088
Res:9.8302
V:9.14247
=:9.13224	rejected
Html:9.10688
Type:9.00708
Mode:9.00349
M:8.95397
Mod:8.87593
In:8.74506
 :8.56903	rejected

:8.41623	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelAction

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelAction
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelAction>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ
   (FreeTypeVariable
      "HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelAction"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelAction
Nature of error: Type variable HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelAction is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelAction
LSP: Generating Completions for prefix: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelAction
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
Res:15.5777
Result:13.4974
 =:11.7828	rejected
R:10.7652
Rest:10.6706
Re:10.2381
Results:10.0393
Model:9.74036
res:9.3637
T:9.33055
Response:9.28585
Action:8.91957
t:8.89128
Type:8.84259
result:8.80163
Reset:8.57659
=:8.27213	rejected
M:8.20057
 Res:7.99815	rejected
Resol:7.82651
Mode:7.78498

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionRes

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionRes
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionRes>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ
   (FreeTypeVariable
      "HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionRes"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionRes
Nature of error: Type variable HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionRes is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionRes
LSP: Generating Completions for prefix: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionRes
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
ul:13.5544
ult:11.2399
 =:11.0192	rejected
ut:10.7845
u:10.336
Model:9.86575
ull:9.48248
l:8.99486
ule:8.8113
ultado:8.73929
lt:8.56589
uld:7.99997
ulu:7.97492
ulf:7.95849
uls:7.95121
 in:7.76171	rejected
ulty:7.67977
T:7.67805
ulp:7.63648
uly:7.57138
Type:7.38141

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResul

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResul
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResul>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ
   (FreeTypeVariable
      "HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResul"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResul
Nature of error: Type variable HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResul is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResul
LSP: Generating Completions for prefix: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResul
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
Model:14.2757
 =:12.9578	rejected
M:10.6709
View:10.5887
Mode:10.413
Action:10.3885
th:10.3038
T:10.1094
Html:10.0302
Grid:9.6926
=:9.51843	rejected
te:9.38038
Type:9.15019
Mo:8.92954
Mod:8.9245
Component:8.71882
model:8.61568
tt:8.56198
E:8.51999
HTML:8.51106
 :8.38642	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModel

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModel
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModel>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ
   (FreeTypeVariable
      "HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModel"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModel
Nature of error: Type variable HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModel is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModel
LSP: Generating Completions for prefix: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModel
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
Action:16.0532
Act:14.2961
 =:13.2596	rejected
Ac:12.0171
A:11.7355
Model:11.3202
Actions:11.1971
View:11.0481
At:10.1164
Result:9.86419
Res:9.85717
V:9.36002
=:9.25138	rejected
Html:9.1426
In:8.98719
M:8.98358
Mod:8.96944
Mode:8.96856
Type:8.80718
Acc:8.58446
Active:8.53631

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelAction

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelAction
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelAction>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ
   (FreeTypeVariable
      "HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelAction"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelAction
Nature of error: Type variable HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelAction is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelAction
LSP: Generating Completions for prefix: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelAction
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
Res:15.6907
Result:13.5415
 =:12.0832	rejected
R:10.9103
Rest:10.7422
Re:10.6225
Model:9.99792
Results:9.89748
Response:9.61732
Action:9.43884
T:9.35242
res:8.84858
Type:8.80222
Reset:8.61103
=:8.58779	rejected
result:8.48234
M:8.45432
t:8.23172
 Res:8.04391	rejected
Mode:8.0438
Rep:7.94953

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionRes

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionRes
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionRes>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ
   (FreeTypeVariable
      "HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionRes"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionRes
Nature of error: Type variable HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionRes is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionRes
LSP: Generating Completions for prefix: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionRes
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
ul:14.0155
ult:11.1271
 =:10.9955	rejected
ut:10.3929
u:10.2422
Model:9.88342
ull:9.49165
ule:9.10756
l:8.7423
ultado:8.60215
uld:8.2768
lt:8.25801
ulu:8.17163
ulf:8.15225
ulp:7.98873
uls:7.88929
uly:7.77544
ulk:7.66257
T:7.64444
ulty:7.51536
 in:7.50891	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResul

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResul
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResul>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ
   (FreeTypeVariable
      "HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResul"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResul
Nature of error: Type variable HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResul is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResul
LSP: Generating Completions for prefix: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResul
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
Model:14.4015
 =:12.9887	rejected
View:10.7921
Action:10.6944
M:10.5807
Mode:10.3572
Html:10.2581
Grid:9.89293
T:9.80628
th:9.75404
=:9.67383	rejected
Mo:9.22952
tt:8.91737
te:8.88191
Type:8.84354
Mod:8.80136
HTML:8.69156
Component:8.64404
Actions:8.64403
E:8.62091
model:8.51479

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModel

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModel
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModel>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ
   (FreeTypeVariable
      "HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModel"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModel
Nature of error: Type variable HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModel is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModel
LSP: Generating Completions for prefix: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModel
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
Action:16.2329
Act:14.3013
 =:13.2519	rejected
Ac:11.8627
A:11.5665
Model:11.4496
View:11.3103
Actions:11.2778
At:10.0711
Res:9.93023
Result:9.77873
V:9.71691
Html:9.36166
=:9.32522	rejected
Mod:9.25642
M:9.17507
In:9.09804
Mode:8.97922
E:8.82926
Type:8.81498
Active:8.59672

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelAction

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelAction
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelAction>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ
   (FreeTypeVariable
      "HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelAction"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelAction
Nature of error: Type variable HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelAction is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelAction
LSP: Generating Completions for prefix: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelAction
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
Res:15.7128
Result:13.3748
 =:12.0631	rejected
R:10.8661
Re:10.8413
Rest:10.4053
Model:10.1217
Results:9.77613
Response:9.59252
Action:9.41521
T:8.97847
res:8.91771
=:8.78379	rejected
M:8.56714
Reset:8.53908
Type:8.43811
result:8.3755
 Res:8.13965	rejected

:8.03205	rejected
Mode:8.01273
Rep:7.99229

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResult

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResult
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResult>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ
   (FreeTypeVariable
      "HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResult"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResult
Nature of error: Type variable HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResult is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResult
LSP: Generating Completions for prefix: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResult
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
 =:13.5304	rejected
Type:13.0384
T:12.1075
Model:11.8213
Action:11.1633
t:10.855
View:10.3279
ype:10.2283
Ty:10.145
Types:10.0713
Html:9.89826
Actions:9.66011
Typ:9.59461
Grid:9.49097
tt:9.43781
=:9.10246	rejected
M:9.07024
type:9.06007
in:9.05054
 :8.90161	rejected
Mode:8.89411
Rejected the highest logit candidate  = with logit -inf

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultType

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultType
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultType>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ
   (FreeTypeVariable
      "HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultType"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultType
Nature of error: Type variable HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultType is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultType
LSP: Generating Completions for prefix: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultType
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
 =:13.4779	rejected
Model:12.5375
Html:11.6309
Grid:10.8536
T:10.7378
Action:10.6667
View:10.5485
 in:9.69413	rejected
M:9.41941
=:9.2777	rejected
 :9.16297	rejected
(:8.68297	rejected
List:8.61183
Type:8.55381
in:8.52431
V:8.47904

:8.44982	rejected
E:8.21336
Actions:8.2088
String:8.12509
HTML:7.99658
Rejected the highest logit candidate  = with logit -inf

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModel

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModel
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModel>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ
   (FreeTypeVariable
      "HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModel"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModel
Nature of error: Type variable HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModel is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModel
LSP: Generating Completions for prefix: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModel
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
Action:15.5821
 =:13.4896	rejected
Act:13.0986
A:11.3346
Model:11.1938
View:11.1475
Actions:10.9643
Html:10.8679
Result:10.6327
Ac:10.5335
Type:10.1892
V:9.9984
Grid:9.95239
Res:9.84801
E:9.55385
M:9.25233
Event:9.21804
=:9.14101	rejected
At:9.11673
List:9.01023
In:8.97803

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelAction

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelAction
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelAction>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ
   (FreeTypeVariable
      "HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelAction"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelAction
Nature of error: Type variable HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelAction is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelAction
LSP: Generating Completions for prefix: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelAction
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
Res:14.9047
Result:14.4385
 =:11.7676	rejected
Re:11.0578
Model:10.9654
R:10.5264
Type:10.3699
Rest:9.98868
Results:9.75475
Action:9.52789
Response:9.39645
Ref:8.75749
result:8.67467
Rep:8.63489
M:8.61541
Reset:8.50686
Mode:8.43932
T:8.3809
E:8.36705
res:8.30168
Mod:8.21282

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResult

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResult
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResult>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ
   (FreeTypeVariable
      "HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResult"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResult
Nature of error: Type variable HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResult is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResult
LSP: Generating Completions for prefix: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResult
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
Type:15.725
 =:13.2954	rejected
T:12.731
Model:12.3425
ype:12.114
Typ:11.8881
Ty:11.5488
Action:11.093
Types:10.8138
type:10.0885
Mode:9.89031
Grid:9.85288
View:9.38546
t:9.37654
M:9.32035
Actions:9.189
=:9.1332	rejected
TY:9.03285
Html:8.99722

:8.91807	rejected
ty:8.91003

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultType

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultType
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultType>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ
   (FreeTypeVariable
      "HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultType"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultType
Nature of error: Type variable HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultType is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultType
LSP: Generating Completions for prefix: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultType
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
Model:13.887
 =:13.2426	rejected
Html:11.3859
Grid:10.8315
View:10.6398
M:10.5893
Action:9.92143
E:9.66162
 in:9.45678	rejected
T:9.4411
=:9.36467	rejected
V:8.96998
String:8.95458
Mo:8.93705
List:8.80073
 :8.65931	rejected
(:8.55058	rejected
Mode:8.48433

:8.1745	rejected
HTML:8.12663
Mod:8.04084

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModel

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModel
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModel>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ
   (FreeTypeVariable
      "HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModel"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModel
Nature of error: Type variable HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModel is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModel
LSP: Generating Completions for prefix: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModel
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
Action:16.084
 =:13.6577	rejected
Act:13.0922
Model:11.3353
A:11.0762
Actions:10.8388
View:10.7772
Html:10.736
Result:10.3289
Ac:10.23
Grid:9.8221
V:9.7519
Type:9.50602
=:9.46676	rejected
E:9.18857
List:9.16304
Res:9.12877
M:8.94594
At:8.94123
 in:8.77971	rejected
 :8.77347	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelAction

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelAction
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelAction>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ
   (FreeTypeVariable
      "HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelAction"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelAction
Nature of error: Type variable HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelAction is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelAction
LSP: Generating Completions for prefix: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelAction
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
Result:15.3871
Res:14.5934
 =:11.8696	rejected
Re:11.6985
R:10.945
Model:10.838
Rest:9.9985
Results:9.98763
Type:9.40574
Action:9.36598
Response:9.19355
Rep:9.08477
Ref:8.81314
result:8.77449
Reset:8.76499
M:8.69028
=:8.67482	rejected
A:8.5731
Mode:8.42504
E:8.33518
Mod:8.14802

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResult

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResult
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResult>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ
   (FreeTypeVariable
      "HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResult"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResult
Nature of error: Type variable HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResult is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResult
LSP: Generating Completions for prefix: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResult
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
Type:16.4918
 =:13.5215	rejected
T:13.2353
Typ:12.6819
Model:12.4822
Ty:12.0003
Action:11.507
type:10.913
Types:10.8974
ype:10.473
View:10.0594
t:10.0369
Grid:9.95536
Mode:9.68833
M:9.54663
=:9.53121	rejected
Actions:9.37437
TY:9.28289
ty:9.24773
ViewModel:9.0765
Result:9.07303

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultType

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultType
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultType>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ
   (FreeTypeVariable
      "HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultType"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultType
Nature of error: Type variable HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultType is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultType
LSP: Generating Completions for prefix: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultType
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
Model:13.5617
 =:12.952	rejected
Html:12.0514
View:10.7725
Grid:10.6171
M:10.3694
 in:9.53061	rejected
E:9.52504
Action:9.31363
String:9.13392
T:9.09219
=:9.08752	rejected
V:8.80196
Mo:8.74197
HTML:8.70171
 :8.45297	rejected
Em:8.25259
(:8.23956	rejected
Mode:7.99236
List:7.98927
G:7.93034

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultTypeModel

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultTypeModel
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultTypeModel>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ
   (FreeTypeVariable
      "HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultTypeModel"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultTypeModel
Nature of error: Type variable HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultTypeModel is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultTypeModel
LSP: Generating Completions for prefix: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultTypeModel
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
Action:16.3891
Act:13.5084
 =:13.4944	rejected
Model:11.5179
A:11.3844
View:11.1967
Html:10.9349
Actions:10.8354
Ac:10.6285
Result:10.2809
V:10.1917
Grid:10.0682
E:9.70485
=:9.45412	rejected
Type:9.41594
List:9.25083
Element:9.1975
M:9.11434
Res:9.08078
Em:8.99755
Mode:8.88523

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultTypeModelAction

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultTypeModelAction
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultTypeModelAction>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ
   (FreeTypeVariable
      "HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultTypeModelAction"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultTypeModelAction
Nature of error: Type variable HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultTypeModelAction is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultTypeModelAction
LSP: Generating Completions for prefix: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultTypeModelAction
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
Result:15.6595
Res:14.5216
 =:11.7635	rejected
Re:11.6119
R:11.1881
Model:11.1314
Rest:9.98745
Results:9.98599
Type:9.45655
Action:9.28957
Response:9.06724
Rep:9.05565
M:8.99961
Reset:8.98358
Ref:8.91409
result:8.77237
=:8.74758	rejected
A:8.64939
Mode:8.55778
E:8.54227
Mod:8.2169

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultTypeModelActionResult

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultTypeModelActionResult
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultTypeModelActionResult>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ
   (FreeTypeVariable
      "HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultTypeModelActionResult"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultTypeModelActionResult
Nature of error: Type variable HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultTypeModelActionResult is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultTypeModelActionResult
LSP: Generating Completions for prefix: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultTypeModelActionResult
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
Type:16.8907
T:13.6317
 =:13.5546	rejected
Typ:12.8116
Model:12.666
Ty:12.1154
type:11.4541
Action:11.4008
Types:11.325
t:10.6658
ype:10.2796
Grid:10.1116
View:10.1039
=:9.82879	rejected
ty:9.69742
Actions:9.68442
M:9.68332
Mode:9.591
TY:9.50033
typ:9.32403
 in:9.26554	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultTypeModelActionResultType

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultTypeModelActionResultType
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultTypeModelActionResultType>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ
   (FreeTypeVariable
      "HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultTypeModelActionResultType"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultTypeModelActionResultType
Nature of error: Type variable HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultTypeModelActionResultType is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultTypeModelActionResultType
LSP: Generating Completions for prefix: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultTypeModelActionResultType
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
Model:13.6974
 =:12.7517	rejected
Html:12.2334
View:10.7942
Grid:10.6615
 in:10.3644	rejected
M:10.0384
E:9.47863
Action:9.2707
=:9.07269	rejected
T:8.90003
String:8.83695
HTML:8.73519
Mo:8.69297
V:8.57827
 :8.34792	rejected
Em:8.18173
(:8.14524	rejected
List:8.01381
Mode:7.97752

:7.9733	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultTypeModelActionResultTypeModel

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultTypeModelActionResultTypeModel
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultTypeModelActionResultTypeModel>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ
   (FreeTypeVariable
      "HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultTypeModelActionResultTypeModel"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultTypeModelActionResultTypeModel
Nature of error: Type variable HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultTypeModelActionResultTypeModel is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultTypeModelActionResultTypeModel
LSP: Generating Completions for prefix: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultTypeModelActionResultTypeModel
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
Action:16.4455
Act:13.5023
 =:13.3948	rejected
Model:11.4299
A:11.3738
View:11.3482
Html:10.8298
Actions:10.7057
Ac:10.6167
V:10.343
Grid:10.2661
Result:10.2152
E:9.75185
=:9.36942	rejected
Element:9.29746
List:9.29018
Type:9.25544
M:9.11923
Res:9.06176
State:9.03965
Em:8.99565

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultTypeModelActionResultTypeModelAction

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultTypeModelActionResultTypeModelAction
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultTypeModelActionResultTypeModelAction>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ
   (FreeTypeVariable
      "HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultTypeModelActionResultTypeModelAction"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultTypeModelActionResultTypeModelAction
Nature of error: Type variable HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultTypeModelActionResultTypeModelAction is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultTypeModelActionResultTypeModelAction
LSP: Generating Completions for prefix: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultTypeModelActionResultTypeModelAction
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
Result:15.6766
Res:14.6605
 =:11.5767	rejected
Re:11.4526
R:11.1827
Model:11.0717
Rest:10.1507
Results:9.84469
Type:9.11154

:9.0496	rejected
Reset:9.01582
Action:9.00475
Rep:8.98643
result:8.93778
M:8.88434
Response:8.86111
Ref:8.82699
=:8.62254	rejected
E:8.56047
Mode:8.24791
A:8.24565

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in
  
let view: Model -> HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultTypeModelActionResultTypeModelActionResult

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => (updateGrid(grid, row, col, selectedEmoji) ,selectedEmoji, availableEmojis)
    | ClearCell(row, col) => 
        let grid = updateGrid(grid, row, col, "") in
          (grid, selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid) ,selectedEmoji, availableEmojis)
    | FillRow(rowToFill) => 
        let grid = fillRowInGrid(grid, rowToFill, selectedEmoji) in
          (grid, selectedEmoji, availableEmojis) end in

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultTypeModelActionResultTypeModelActionResult>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ
   (FreeTypeVariable
      "HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultTypeModelActionResultTypeModelActionResult"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultTypeModelActionResultTypeModelActionResult
Nature of error: Type variable HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultTypeModelActionResultTypeModelActionResult is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultTypeModelActionResultTypeModelActionResult
LSP: Generating Completions for prefix: HtmlActionResultTypeModelActionResultTypeModelActionResultTypeHtmlModelActionResulModelActionResulModelActionResulModelActionResultModelActionResulModelActionResulModelActionResulModelActionResultTypeModelActionResultTypeModelActionResultTypeModelActionResultTypeModelActionResult
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
Type:16.8462
 =:13.5963	rejected
T:13.3419
Model:12.7959
Typ:12.2933
Ty:11.6988
Action:11.6191
type:11.5167
Types:11.2853
t:10.6685
ype:10.6212
Grid:10.5565
Actions:10.1101
View:10.0649

:9.97978	rejected
=:9.85122	rejected
Row:9.74098
Mode:9.70473
M:9.67537
V:9.38979
Result:9.35083
