

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((Model, Action) -> Model)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((Model, Action) -> Model)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:18.206
 fun:17.7266
 :16.6542
    :13.6801
  :13.6608
   :13.5554
 function:13.2417	rejected
                :12.9429
 (:12.3215
      :11.9996
 \:11.8668	rejected
        :11.5471
     :11.4724
         :11.0756
            :11.0429
 match:10.9433	rejected
	:10.9051	rejected
          :10.8512
 #:10.658	rejected
             :10.6049
 {:10.3904	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =


LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((Model, Action) -> Model)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((Model, Action) -> Model)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 :19.3266
   :16.8366
 fun:16.3646
  :15.0914

:14.8473
fun:14.466
    :13.4796
	:13.258	rejected
 let:12.9453
     :12.1675
let:12.0329
#:11.5486	rejected
      :11.3365
 func:11.3294	rejected
func:11.1278	rejected
(*:11.0189	prefix accepted:(
(:11.0189
 match:10.9031	rejected
match:10.7867	rejected
 switch:10.6599	rejected
       :10.6478

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
 

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
 
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((Model, Action) -> Model)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((Model, Action) -> Model)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 fun:20.8762
 let:14.7807
 match:12.6966	rejected
 (:12.6416
 function:12.5476	rejected
 switch:12.2412	rejected
 #:11.8769	rejected
 (*:11.674	prefix accepted: (
 {:11.2721	rejected
 |:11.0077	rejected
 func:10.7422	rejected
 f:10.2072
 //:10.0736	rejected
 lambda:10.055	rejected
 proc:10.0373	rejected
 ((:9.86111	prefix accepted: (
 self:9.86105	rejected
 fn:9.78153	rejected
 ~:9.75935	rejected
 if:9.74108
 model:9.48368

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 model:16.5655
 (:16.4124
 m:16.1156
 ((:15.0048	prefix accepted: (
 {:13.8016	rejected
 ({:13.5451	prefix accepted: (
 state:13.3815
 old:13.2141
 mo:12.1043
 prev:12.0415
 [:11.7551
(:11.689
 current:11.6329
 s:11.359
 st:11.3223
 init:11.2113
 x:11.1298
 t:11.0295
 md:10.7659
 mode:10.7616
((:10.6243	prefix accepted:(

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized pattern
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: (([[String]], String, [String]), (SelectEmoji(String) + StampEmoji((Int, Int)) + ClearCell((Int, Int)) + ClearGrid + FillRow(Int)))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in
  LSP: Info: BidiCtx: Cls: Parenthesized pattern
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Parenthesized pattern
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: (([[String]], String, [String]), (SelectEmoji(String) + StampEmoji((Int, Int)) + ClearCell((Int, Int)) + ClearGrid + FillRow(Int)))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in
  LSP: Info: BidiCtx: Cls: Parenthesized pattern
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "()" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= completions | new-tokens

Top 20 Logits:
grid:17.1706
model:15.0447
old:13.7832
g:13.4469
m:12.8239
current:12.2839
em:11.7197
prev:11.3726
state:11.3397
_,:11.259	prefix accepted:_
emo:10.6226
p:10.2829
((:10.2687	prefix accepted:(

:10.2118
curr:10.1181
x:9.95739
cur:9.77702
init:9.73778
gs:9.67178
initial:9.59276
 grid:9.52008

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <grid>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {grid: (Model, Action), update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: grid
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: grid
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
,:18.1236
_:12.8089
0:12.5013
Model:12.0481
 ,:11.9546
1:11.8182
',:11.8172	rejected
_,:11.403	prefix accepted:_
Old:11.3958
State:11.2817
::11.2285	rejected
Init:10.9808
 as:10.6849	rejected
Before:10.5392
M:10.5101
To:10.4614
 ::10.2759	rejected
In:10.0926
2:9.52497
E:9.46956
,(:9.34999	prefix accepted:,

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: (([[String]], String, [String]), (SelectEmoji(String) + StampEmoji((Int, Int)) + ClearCell((Int, Int)) + ClearGrid + FillRow(Int)))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {grid: Model, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: (([[String]], String, [String]), (SelectEmoji(String) + StampEmoji((Int, Int)) + ClearCell((Int, Int)) + ClearGrid + FillRow(Int)))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {grid: Model, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {grid: Model, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 selected:15.7351
 current:14.4194
 em:13.7951
 sel:13.1677
 cur:12.9245
 curr:12.4851
 selection:11.9999
 e:11.8642
 _,:11.6347	prefix accepted: _
 select:11.3031
 currently:11.1049
selected:11.0297
 prev:10.4767
 old:10.4237
 s:10.1602
 active:10.1075
 c:9.98871
emo:9.80507
 chosen:9.59139
current:9.5486
 last:9.30573

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selected

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selected
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <selected>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {selected: Action, grid: Model, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: selected
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: selected
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
E:19.4713
,:16.7407
_:16.7394
Em:15.9093
emo:13.03
Char:11.9303
Color:11.0164
Value:10.9429
 ,:10.6396
Item:10.6285
Cell:10.5203
_,:10.3648	prefix accepted:_
EM:9.91523
em:9.85771
G:9.55227
Image:9.46119
S:9.43538
Val:9.425
Model:9.37372
-:9.33297	rejected
T:9.29125

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedE

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedE
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <selectedE>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {selectedE: Action, grid: Model, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: selectedE
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: selectedE
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
mo:25.755
lem:15.5936
,:14.0057
omo:12.1336
emo:12.1229
MO:12.116
mu:11.4823
o:11.0971
mm:11.0171
sm:10.1752
imo:10.1515
mi:10.1211
Mo:9.91603
mt:9.86806
md:9.83809
mod:9.7959
ma:9.7435
le:9.59761
no:9.30386
мо:9.22868	rejected
mon:9.21145

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmo

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmo
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <selectedEmo>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {selectedEmo: Action, grid: Model, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: selectedEmo
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: selectedEmo
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
ji:23.2719
ij:15.8544
,:15.3292
jo:13.5862
iji:12.4949
j:12.1318
J:10.8756
ii:10.7935
i:10.6886
 ji:10.6562	rejected
yi:10.2125
je:10.0311
jih:9.90477
qi:9.76767
 ,:9.67861
ijo:8.92604
ci:8.83182
ja:8.65438
ip:8.48661
yj:8.48161
jin:8.1888

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <selectedEmoji>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {selectedEmoji: Action, grid: Model, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: selectedEmoji
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: selectedEmoji
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
,:18.9489
 ,:12.9671
In:12.084
),:11.8821
_,:11.077	prefix accepted:_
Before:11.0725
To:10.9906
',:10.9783	rejected
Id:10.5916
Name:10.5891
Or:10.5025
Index:10.4957
P:10.2299
1:10.1698
Value:10.1235
::10.0497	rejected
Option:10.0019
Model:9.9091
0:9.79937
 as:9.73698	rejected
Opt:9.65922

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: (?, ?, ?)
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Prod [(Var "Model"); (Var "Action")]);
           syn =
           (Prod [(Unknown Internal); (Unknown Internal); (Unknown Internal)])})))
  LSP: Info: Typing Context: {selectedEmoji: ?, grid: ?, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in
  LSP: Info: ALL errors:
Error in term:
  (grid, selectedEmoji, ?)
Nature of error: Expecting type (Model, Action) but got inconsistent type (?, ?, ?)
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: (?, ?, ?)
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Prod [(Var "Model"); (Var "Action")]);
           syn =
           (Prod [(Unknown Internal); (Unknown Internal); (Unknown Internal)])})))
  LSP: Info: Typing Context: {selectedEmoji: ?, grid: ?, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in
  LSP: Info: ALL errors:
Error in term:
  (grid, selectedEmoji, ?)
Nature of error: Expecting type (Model, Action) but got inconsistent type (?, ?, ?)
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {selectedEmoji: ?, grid: ?, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in
  LSP: Info: ALL errors:
Error in term:
  (grid, selectedEmoji, ?)
Nature of error: Expecting type (Model, Action) but got inconsistent type (?, ?, ?)
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 available:16.4354
 em:14.87
 all:13.7688
 avail:11.6832
 av:11.5372
 possible:11.3609
 select:11.3237
 valid:11.1179
 _:11.0434
 allowed:10.8957
 list:10.5978
 remaining:10.5791
 _):10.4608	prefix accepted: _
 un:10.2342
 _,:9.70125	prefix accepted: _
 options:9.58678
 e:9.35574
 other:9.31271
 emot:9.17772
 a:9.08674
 choices:8.97032

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, available

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, available
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <available>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {available: ?, selectedEmoji: ?, grid: ?, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in
  LSP: Info: ALL errors:
Error in term:
  (grid, selectedEmoji, available)
Nature of error: Expecting type (Model, Action) but got inconsistent type (?, ?, ?)
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: available
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: available
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | "," | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
Em:20.9219
E:16.8543
),:15.2116
):13.2837
_:12.4545
List:11.6799
,:11.1668
Options:11.0086
em:10.3876
G:10.1466
Selected:9.97522
Grid:9.93232
S:9.82491
Cho:9.69336
F:9.61553
EM:9.37972
M:9.27777
Items:9.19501
P:9.1189
In:9.07574
)::8.98623	prefix accepted:)

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEm

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEm
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <availableEm>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {availableEm: ?, selectedEmoji: ?, grid: ?, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in
  LSP: Info: ALL errors:
Error in term:
  (grid, selectedEmoji, availableEm)
Nature of error: Expecting type (Model, Action) but got inconsistent type (?, ?, ?)
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: availableEm
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: availableEm
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | "," | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
oj:22.3854
jo:14.3347
os:13.4522
otic:12.2155
otes:11.6747
j:11.6223
ij:11.5283
og:11.3744
js:11.3724
jos:10.9705
),:10.1565
ijo:9.97693
ot:9.97567
ok:9.88169
op:9.50012
):9.43644
ote:9.30568
em:9.00574
oo:8.95605
ps:8.79078
ji:8.72406

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmoj

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmoj
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <availableEmoj>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {availableEmoj: ?, selectedEmoji: ?, grid: ?, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in
  LSP: Info: ALL errors:
Error in term:
  (grid, selectedEmoji, availableEmoj)
Nature of error: Expecting type (Model, Action) but got inconsistent type (?, ?, ?)
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: availableEmoj
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: availableEmoj
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | "," | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
is:23.5639
ies:15.3044
il:12.7475
),:12.4669
ii:11.7326
):11.7147
Is:11.5156
iss:11.0769
ip:10.7565
lis:10.6465
l:10.5741
ie:10.5163
ios:10.2307
os:9.39512
ij:9.22015
tis:9.20495
isi:9.17194
ise:9.16222
ic:9.16137
es:9.13369
icons:9.11814

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <availableEmojis>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {availableEmojis: ?, selectedEmoji: ?, grid: ?, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in
  LSP: Info: ALL errors:
Error in term:
  (grid, selectedEmoji, availableEmojis)
Nature of error: Expecting type (Model, Action) but got inconsistent type (?, ?, ?)
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: availableEmojis
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: availableEmojis
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | "," | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
),:19.6889
):14.6449
 as:14.1733	rejected
,:12.6021
 ),:11.3335
 ::10.804
 =:10.5807	rejected
::10.3385
)::10.1817	prefix accepted:)
)=:10.0799	prefix accepted:)
_:10.0321
=:9.81921	rejected
List:9.72789
),(:9.66595	prefix accepted:),
'),:9.05847	rejected
In:9.05146
As:8.94014
)->:8.32978	prefix accepted:)
 :8.31266
To:8.24312
),\:8.22662	prefix accepted:),

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis),

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis),
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: (([[String]], String, [String]), (SelectEmoji(String) + StampEmoji((Int, Int)) + ClearCell((Int, Int)) + ClearGrid + FillRow(Int)))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: (([[String]], String, [String]), (SelectEmoji(String) + StampEmoji((Int, Int)) + ClearCell((Int, Int)) + ClearGrid + FillRow(Int)))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 action:16.8168
 a:15.6226
 act:14.493
 :11.7843
 (:11.683

:11.6499
 e:11.3972
 actions:11.1803
 x:11.0356
 ac:10.631
 msg:10.5175
action:10.5096
 next:10.4172
 event:10.2816
 new:10.1754
 message:9.95512
 m:9.81826
 input:9.65436
 current:9.56314
 _:9.54669
 v:9.50246

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <action>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: action
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: action
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | "->"
root ::= completions | new-tokens

Top 20 Logits:
 ->:18.5928
 :14.0908
->:14.0494
 =>:13.2387	rejected
_:11.9394
::11.7948	rejected

:11.7425
 =:11.1229	rejected
 ::11.0638	rejected
':10.8873	rejected
0:10.4784
 +:10.4556	rejected
  :10.4193
 →:10.3245	rejected
1:10.2275
,:10.1542
 -:9.77199
 -->:9.63667	prefix accepted: -
 {:9.61805	rejected
   :9.57969
2:9.32024

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Model, Action) -> Model)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:19.2003
 :17.6364
 match:15.4381	rejected
  :15.3512
   :15.2952
    :14.9517
 case:13.4687
      :13.1409
 (:12.9014
                :12.8283
        :12.3362
 {:12.2178	rejected
     :12.1372
 action:12.1074
         :11.9475
 #:11.8061	rejected
          :11.7111
	:11.6754	rejected
 let:11.6028
 (*:11.6019	prefix accepted: (
 ?:11.3277	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->


LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Model, Action) -> Model)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
   :21.1202
    :16.9628
 :16.1604
  :15.7784

:15.3489
     :15.016
      :14.4091
case:14.0902
       :13.3926
match:13.3786	rejected
        :13.3126
         :13.1944
	:13.1936	rejected
 case:12.0883
           :11.9161
 match:11.9097	rejected
          :11.8646
                :11.7953
#:11.1903	rejected
switch:11.1767	rejected
            :11.0152

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
   

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
   
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Model, Action) -> Model)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 case:18.7029
 match:16.9992	rejected
 let:15.2662
 switch:12.9739	rejected
 if:12.7743
 (:12.577
 print:12.2927	rejected
 #:11.2963	rejected
 action:11.1125
 {:11.0565	rejected
 (*:10.9805	prefix accepted: (
 begin:10.8422	rejected
 model:10.8261
 var:10.7202	rejected

:10.2165
 open:9.89012	rejected
 printf:9.71778	rejected
 pair:9.53622	rejected
 List:9.535	rejected
 fun:9.43754
 Model:9.37838	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <case end<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 action:18.4402
 selected:12.2468
 (:11.9252
 :11.8482

:10.6975
 Action:10.4192	rejected
 grid:10.2379
(:10.1847
 actions:10.1195	rejected
 !:10.1186
 not:9.99469	rejected
 let:9.93041
 ::9.92338	rejected
 s:9.84577
::9.7959	rejected
 @:9.70482	rejected
 update:9.69979
 List:9.64772	rejected
 show:9.55155	rejected
 type:9.54494
_:9.50457	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <action>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (SelectEmoji(String) + StampEmoji((Int, Int)) + ClearCell((Int, Int)) + ClearGrid + FillRow(Int))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: action
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Generating Completions for prefix: action
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:18.4624
 :17.305
 of:15.8482	rejected
  :14.9838
    :14.6047
      :13.5921
   :13.3955
                :12.9676
 in:12.8709	rejected
 with:12.7886	rejected
 {:12.6899	rejected
::12.6009
 |:12.5492
,:12.4846
     :12.2912
 ::12.1212
        :12.0957
         :11.8526
 match:11.8398	rejected
 #:11.8113	rejected
          :11.7318

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action


LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <action>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (SelectEmoji(String) + StampEmoji((Int, Int)) + ClearCell((Int, Int)) + ClearGrid + FillRow(Int))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
   :18.1025
    :16.1796
     :14.7705

:14.6513
      :14.0676
        :13.4082
  :13.3912
 :13.265
       :12.1093
         :11.9792
	:11.9004	rejected
|:11.6
          :11.4158
#:11.2752	rejected
 |:10.9521
                :10.766
            :10.6043
           :10.103
(*:10.0765	prefix accepted:(
             :9.82527
              :9.29058

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
   

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
   
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <action>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (SelectEmoji(String) + StampEmoji((Int, Int)) + ClearCell((Int, Int)) + ClearGrid + FillRow(Int))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:21.0229
 #:15.3355	rejected
 +:13.9619
 (*:13.9618	prefix accepted: (
 //:12.8054	prefix accepted: /
 match:12.3531	rejected
 ~:12.3362	rejected
 /*:11.8734	prefix accepted: /
 {:11.7074	rejected

:11.5579
 ||:11.5541	prefix accepted: |
 ##:11.1948	rejected
 /:12.8054
 <:10.9813
 *:10.9781
 (+:10.9753	prefix accepted: (
 `:10.9472	rejected
 #{:10.9317	rejected
 -:10.6489
 %:10.6117	rejected
 ::10.5023

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    |

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    |
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 Select:18.5865
 St:16.0524
 Clear:14.3744
 +:13.9389	rejected
 _:12.0101
 F:11.8787
 Action:11.6881	rejected
Select:11.5428
 (:11.4897
 :11.3252
 select:10.8137
 Selected:10.4204	rejected
 #:10.4125	rejected
 ~:9.8799	rejected
 None:9.87854	rejected
+:9.70513	rejected
 action:9.57045
St:9.3678
 @:9.23409	rejected
 Selection:9.14629	rejected
 Some:9.07234	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | Select

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | Select
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Select>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "Select"))))
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  Select
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Select
LSP: Generating Completions for prefix: Select
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Emoji"
root ::= completions

Top 20 Logits:
E:20.4054
(:13.1553	rejected
Em:11.6783
_:11.1529	rejected
New:10.9741	rejected
 em:10.6703	rejected
e:10.5904	rejected
 new:10.0445	rejected
emo:9.70821	rejected
Action:9.5878	rejected
(_:9.34518	rejected
A:8.97729	rejected
 E:8.94045	rejected
Next:8.34707	rejected
 (:8.22368	rejected
 a:8.13617	rejected
G:8.08842	rejected
Color:7.86363	rejected
First:7.78626	rejected
 e:7.68273	rejected
((:7.66384	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectE

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectE
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <SelectE>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "SelectE"))))
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  SelectE
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: SelectE
LSP: Generating Completions for prefix: SelectE
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "moji"
root ::= completions

Top 20 Logits:
mo:25.6211
emo:16.3701	rejected
MO:14.3907	rejected
omo:14.2158	rejected
mm:12.5011	rejected
мо:11.8815	rejected
 mo:11.8568	rejected
lem:11.6038	rejected
imo:11.5398	rejected
ma:11.3845	rejected
mu:11.3529	rejected
amo:11.3167	rejected
mi:11.3153	rejected
m:11.1338
mor:10.9553	rejected
mit:10.4544	rejected
Mo:10.428	rejected
cho:10.3648	rejected
no:10.2298	rejected
o:9.83502	rejected
po:9.81506	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmo

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmo
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <SelectEmo>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "SelectEmo"))))
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  SelectEmo
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: SelectEmo
LSP: Generating Completions for prefix: SelectEmo
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ji"
root ::= completions

Top 20 Logits:
ji:25.3898
 ji:14.1201	rejected
jo:14.1153	rejected
ij:12.9812	rejected
iji:12.9215	rejected
J:12.6565	rejected
je:12.4807	rejected
j:12.3099
ja:11.9106	rejected
yi:11.677	rejected
 Ji:11.58	rejected
(:10.9244	rejected
ju:10.8212	rejected
i:10.67	rejected
qi:10.2815	rejected
jih:9.77118	rejected
jin:9.71061	rejected
ii:9.35825	rejected
zi:9.33976	rejected
ci:9.28055	rejected
ui:9.25288	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <SelectEmoji>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (String -> (SelectEmoji(String) + StampEmoji((Int, Int)) + ClearCell((Int, Int)) + ClearGrid + FillRow(Int)))
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Var "Action");
           syn = (Arrow ((Var "Emoji"), (Var "Action")))})))
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  SelectEmoji
Nature of error: Expecting type Action but got inconsistent type (Emoji -> Action)
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: SelectEmoji
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: SelectEmoji
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
(:18.3473
 em:15.7419	rejected
 new:14.1074	rejected
 e:14.0282	rejected
(":12.9999	prefix accepted:(
(_:12.0666	rejected
 (:11.5351
 next:11.2116	rejected
 selected:11.1517	rejected
 x:10.2643	rejected
 s:9.9972	rejected
 a:9.71175	rejected
 chosen:9.46958	rejected
 selection:9.42915	rejected
 _:9.42655	rejected
 sel:9.36269	rejected
(::9.17867	prefix accepted:(
 :9.16204
(':9.06642	prefix accepted:(
 c:9.01399	rejected
 select:8.98	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (SelectEmoji(String) + StampEmoji((Int, Int)) + ClearCell((Int, Int)) + ClearGrid + FillRow(Int))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (SelectEmoji(String) + StampEmoji((Int, Int)) + ClearCell((Int, Int)) + ClearGrid + FillRow(Int))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Emoji
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Emoji
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "()" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= completions | new-tokens

Top 20 Logits:
emo:17.4298
new:16.2894
e:15.3269
selected:15.0801
em:14.078
next:13.3287
x:13.1146
s:12.3835
a:11.9476
select:11.5725
ch:10.8374
value:10.7502
sel:10.7455
target:10.7153
n:10.679
v:10.5868
c:10.5713
current:10.3934
Selected:10.3292	rejected
selection:10.1837
i:10.0445

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emo

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emo
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <emo>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Emoji
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {emo: Emoji, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Emoji
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: emo
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: emo
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
ji:22.169
):15.6181
ij:12.7418
jo:11.8837
_:11.7338
To:11.0488
iji:10.7343
 ji:10.7235	rejected
){:10.6111	prefix accepted:)
)::10.5674	prefix accepted:)
Name:10.4209
J:10.3639
)->:10.3517	prefix accepted:)
jih:10.1608
ja:9.97072
1:9.94435
je:9.89413
 ::9.60915	rejected
 ->:9.55967	rejected
Selected:9.37141
ii:9.3113

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <emoji>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Emoji
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {emoji: Emoji, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Emoji
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: emoji
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: emoji
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
):17.5974
To:15.0323
Selected:14.0349
'):13.8658	rejected
)::12.033	prefix accepted:)
Name:11.8724
In:11.7674
New:11.7554
)->:11.6183	prefix accepted:)
_:11.2621
Key:11.1484
From:11.1023
_):11.0961	prefix accepted:_
Id:10.7109
),:10.6897
Choice:10.3875
Selection:10.2804
Index:10.2582
::10.204	rejected
Value:10.149
T:9.85336

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji)

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (SelectEmoji(String) + StampEmoji((Int, Int)) + ClearCell((Int, Int)) + ClearGrid + FillRow(Int))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {emoji: Emoji, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:19.4704
  :14.5431
 ->:14.2704	rejected
    :14.1908
     :14.0975
      :14.035
 :13.7614
                :13.7135
       :13.7126
 when:13.5503	rejected
         :13.5073
        :13.4462
   :13.2512
          :13.1904
           :12.9968
 if:12.7699	rejected
             :12.7492
            :12.6212
              :12.3173

:12.2929
               :12.0146

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) =>

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) =>
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {emoji: Emoji, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: emoji action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "emoji" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 (:17.3858

:16.3901
 :15.991
 grid:14.8424
  :14.5108
                :13.6005
 if:13.4654
    :13.13
 [:12.672
            :12.5976
     :12.5472
 ?:12.522	rejected
      :12.3751
        :12.2688
 model:12.22
 ((:12.1635	prefix accepted: (
              :12.0538
 {:11.983	rejected
 #:11.9691	rejected
 List:11.9392	rejected
         :11.8395

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {emoji: Emoji, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {emoji: Emoji, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {emoji: Emoji, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: emoji action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: emoji action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "emoji" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
grid:18.0168

:15.6279
 grid:14.1584
?,:12.7821	rejected
model:12.7771
  :11.9872
List:11.6808	rejected
 :11.4678
#:11.2713	rejected
update:10.7101
f:10.7057
    :10.5893
Grid:10.5525	rejected
_,:10.4602	rejected
                :10.4026
g:10.2872
 ?:10.2343	rejected
selected:9.98663
 #:9.95663	rejected
#,:9.94122	rejected
   :9.86893

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <grid>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [[String]]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = (Var "Model"); syn = (Var "Grid")})))
  LSP: Info: Typing Context: {emoji: Emoji, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  grid
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: grid
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: grid
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: emoji action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:20.2559
 ,:14.3949
                :11.9195
      :11.5671
        :11.5519
       :11.5501
  :11.5233
    :11.5228
          :11.335
     :11.3193
::10.9915
.:10.9012	rejected
   :10.8737
            :10.8223
           :10.8141
 +:10.7273
             :10.6556
         :10.5936
,,:10.5193	prefix accepted:,
 :10.4079
              :10.3575

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model");
           syn = (Prod [(Var "Grid"); (Unknown Internal)])})))
  LSP: Info: Typing Context: {emoji: Emoji, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  grid, ?
Nature of error: Expecting type Model but got inconsistent type (Grid, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model");
           syn = (Prod [(Var "Grid"); (Unknown Internal)])})))
  LSP: Info: Typing Context: {emoji: Emoji, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  grid, ?
Nature of error: Expecting type Model but got inconsistent type (Grid, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {emoji: Emoji, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  grid, ?
Nature of error: Expecting type Model but got inconsistent type (Grid, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: emoji action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: emoji action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "emoji" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 em:20.1718
emo:12.593
 action:12.5799
 if:12.4639
 List:12.3021	rejected
 e:12.1089
 :11.7897
                :11.7413
  :11.2391
 select:11.0825
 Some:10.9676	rejected
    :10.8598
 Em:10.5746	rejected
 selected:10.4416
      :10.3469
       :10.3336
          :10.238

:10.1337
em:10.1268
         :10.1056
 (:10.1039

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, em

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, em
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <em>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "em"))
  LSP: Info: Typing Context: {emoji: Emoji, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  em
Nature of error: Variable em is not bound  
Error in term:
  grid, em
Nature of error: Expecting type Model but got inconsistent type (Grid, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: em
LSP: Generating Completions for prefix: em
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: emoji action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "oji"
root ::= completions

Top 20 Logits:
o:21.3675
oi:11.1529	rejected
mo:11.1161	rejected
oj:10.7091
jo:10.141	rejected
oto:10.1246	rejected
ji:9.67991	rejected
oo:9.59347	rejected
,:9.21141	rejected
po:9.08762	rejected
omo:8.9672	rejected
otion:8.95969	rejected
oin:8.71746	rejected
 o:8.65492	rejected

:8.56315	rejected
iji:8.32874	rejected
pto:8.2146	rejected
ajo:8.07898	rejected
ijo:7.9016	rejected
i:7.60507	rejected
emo:7.57762	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emo

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emo
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <emo>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "emo"))
  LSP: Info: Typing Context: {emoji: Emoji, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  emo
Nature of error: Variable emo is not bound  
Error in term:
  grid, emo
Nature of error: Expecting type Model but got inconsistent type (Grid, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: emo
LSP: Generating Completions for prefix: emo
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: emoji action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ji"
root ::= completions

Top 20 Logits:
ji:27.1663
iji:16.1608	rejected
jo:15.2377	rejected
 ji:14.7296	rejected
ja:14.3799	rejected
je:13.3072	rejected
ij:12.9697	rejected
jih:11.8934	rejected
,:11.6315	rejected
 Ji:11.5456	rejected
js:11.4706	rejected
ii:11.3073	rejected
ijo:11.2876	rejected
qi:10.9625	rejected
):10.8266	rejected
json:10.4776	rejected
ije:10.2661	rejected
yi:10.2251	rejected
J:10.148	rejected
ject:9.7767	rejected
ija:9.48257	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <emoji>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: String
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {emoji: Emoji, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  grid, emoji
Nature of error: Expecting type Model but got inconsistent type (Grid, Emoji)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: emoji
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: emoji
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: emoji action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:19.9216
 ,:14.3386
                :11.9831
):11.4321
',:11.3227	rejected
  :11.279
,\:10.8275	prefix accepted:,
 \:10.7942
 :10.4393
.:10.2397	rejected
    :10.2377
     :10.1944
 +:10.1649
   :10.0387
            :9.93446
),:9.90212	prefix accepted:)
      :9.88546
 @:9.85855
        :9.79775
             :9.78404
       :9.77869

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {emoji: Emoji, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {emoji: Emoji, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Emoji]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {emoji: Emoji, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: emoji action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: emoji action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "emoji" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 available:18.7661
 [:13.9219
  :13.1732
 :13.1597
available:12.8592
 List:12.7665	rejected
    :12.6535
 selected:12.5718
                :12.0941
     :12.0387
       :11.936
        :11.8806
         :11.5854
          :11.5083
   :11.3774
      :11.33
            :11.0546
 em:10.7686
 Em:10.6968	rejected
              :10.4242
 select:10.3206

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, available

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, available
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <available>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Emoji]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "available"))
  LSP: Info: Typing Context: {emoji: Emoji, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  available
Nature of error: Variable available is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: available
LSP: Generating Completions for prefix: available
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: emoji action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Emojis"
root ::= completions

Top 20 Logits:
Em:23.0389
E:12.9672
_:12.8659	rejected
em:11.9839	rejected
 Em:11.2088	rejected
):11.102	rejected
EM:10.9814	rejected
 em:10.4936	rejected
Om:9.96988	rejected
M:9.70169	rejected
List:9.55515	rejected
Im:9.47559	rejected
.:9.36021	rejected
Emp:9.11553	rejected
Er:9.06976	rejected
Sm:9.02374	rejected
G:8.99777	rejected
(:8.59947	rejected
Ed:8.54327	rejected
A:8.5273	rejected
Sim:8.51501	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEm

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEm
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <availableEm>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Emoji]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "availableEm"))
  LSP: Info: Typing Context: {emoji: Emoji, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  availableEm
Nature of error: Variable availableEm is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: availableEm
LSP: Generating Completions for prefix: availableEm
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: emoji action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ojis"
root ::= completions

Top 20 Logits:
oj:31.667
jos:18.1317	rejected
ij:15.8562	rejected
j:15.469	rejected
jo:15.2008	rejected
oz:15.1048	rejected
ok:14.086	rejected
o:13.3908
oi:13.1802	rejected
om:13.1502	rejected
ois:12.9924	rejected
jm:12.7338	rejected
oy:12.6924	rejected
uj:12.1088	rejected
os:12.0306	rejected
aj:11.9966	rejected
ej:11.9805	rejected
imos:11.6935	rejected
obj:11.4119	rejected
otos:11.2427	rejected
og:11.2137	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmoj

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmoj
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <availableEmoj>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Emoji]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "availableEmoj"))
  LSP: Info: Typing Context: {emoji: Emoji, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  availableEmoj
Nature of error: Variable availableEmoj is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: availableEmoj
LSP: Generating Completions for prefix: availableEmoj
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: emoji action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "is"
root ::= completions

Top 20 Logits:
is:25.5339
ins:17.5492	rejected
i:13.8982
ips:13.5303	rejected
ies:13.5161	rejected
Is:13.3511	rejected
ils:12.4464	rejected
ians:12.2755	rejected
iss:12.1009	rejected
ios:12.0129	rejected
ions:11.875	rejected
ij:11.8705	rejected
ias:11.7897	rejected
isi:11.7538	rejected
js:11.6025	rejected
ius:11.502	rejected
ís:11.212	rejected
 is:11.1435	rejected
si:11.1051	rejected
ists:11.073	rejected
irs:11.0136	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <availableEmojis>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Emoji]
  LSP: Info: Seft type: [String]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {emoji: Emoji, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: availableEmojis
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: availableEmojis
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: emoji action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
):21.324
 ):15.6302
),:15.3273	prefix accepted:)
);:14.7066	prefix accepted:)
)::13.6022	prefix accepted:)
)\:13.3927	prefix accepted:)
,:13.1908
)):13.0592
 +:12.4445

:11.6586
 :11.6343
 \:11.4444
).:11.3796	rejected
)|:11.3353	prefix accepted:)
)]:11.307	prefix accepted:)
  :11.264
)`:11.2211	prefix accepted:)
)(:11.1586	prefix accepted:)
                :10.7821
 *:10.781
 |:10.6171	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {emoji: Emoji, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:18.7221
 :15.9151
  :15.845
 #:15.1533	rejected
    :14.7822
                :14.6887
      :13.8489
     :13.665
        :13.5888
 in:13.4019	rejected
       :13.1821
   :13.1221
          :13.0096
         :12.9749
            :12.8663
           :12.6545
             :12.5221
 (*:12.4969	prefix accepted: (
              :12.4685
 end:12.4567
               :12.1061

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)


LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {emoji: Emoji, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
   :20.4004
    :17.7923

:16.4822
  :16.0209
        :15.6929
      :15.2056
                :15.1009
     :15.059
       :14.0849
	:13.9952	rejected
          :13.7732
#:13.7318	rejected
 :13.5656
            :13.5266
         :13.1441
              :12.76
|:12.2967
             :12.0082
           :11.78
               :11.71
(*:11.6659	prefix accepted:(

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
   

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
   
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {emoji: Emoji, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:21.7646
 #:15.9324	rejected
 (*:14.2425	prefix accepted: (

:13.7251
 //:12.4452	prefix accepted: /
 ##:11.5689	rejected
 |\:11.4942	prefix accepted: |
 +:11.2813
 ~:11.277	rejected
 /:12.4452
 \:11.1986
 ^:11.1495	rejected
 St:11.1405	rejected
 <:11.1097
 /*:11.0845	prefix accepted: /
 end:11.0425
 *:10.9553
 ||:10.7666	prefix accepted: |
 (**:10.7459	prefix accepted: (
	:10.7307	rejected
 (:14.2425

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    |

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    |
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 St:20.1117
 Clear:16.846
 F:15.8367
 _:13.5902
 stamp:11.0409
St:10.6897
 :10.5182
 Update:9.57149	rejected
  :9.4509
 (:9.35216
 st:9.33001
 #:9.31554	rejected
 clear:9.11578
 Set:9.08232	rejected
 Insert:8.74282	rejected
 _,:8.73442	prefix accepted: _
 Em:8.69444	rejected
 Add:8.6152	rejected
 Fil:8.56352
 Cle:8.38585
 Put:8.34054	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | St

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | St
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <St>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "St"))))
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  St
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: St
LSP: Generating Completions for prefix: St
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ampEmoji"
root ::= completions

Top 20 Logits:
amp:29.2311
am:16.1901
omp:14.7711	rejected
amps:14.4553	rejected
ample:13.5198	rejected
ap:13.4897	rejected
 amp:13.2371	rejected
ump:13.0533	rejected
ampf:12.652	rejected
rip:12.4895	rejected
ampa:12.3403	rejected
mp:12.1113	rejected
map:11.7546	rejected
AMP:11.622	rejected
ame:11.0903	rejected
emp:10.7816	rejected
arp:10.285	rejected
p:9.9223	rejected
amt:9.65519	rejected
amb:9.47501	rejected
d:9.46119	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | Stamp

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | Stamp
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Stamp>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "Stamp"))))
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  Stamp
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Stamp
LSP: Generating Completions for prefix: Stamp
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Emoji"
root ::= completions

Top 20 Logits:
E:23.5328
Em:13.9139
Cell:13.1237	rejected
(:12.9866	rejected
Grid:11.8096	rejected
At:10.6227	rejected
Empty:10.421	rejected
Over:10.3747	rejected
_:10.2748	rejected
  :10.1124	rejected
Row:9.95439	rejected
::9.93957	rejected
Selected:9.92223	rejected
Image:9.85589	rejected
 em:9.60176	rejected
Action:9.51311	rejected
 E:9.35095	rejected
 ::9.29391	rejected
 (:9.2691	rejected
In:9.21049	rejected
(_:9.08674	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampE

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampE
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <StampE>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "StampE"))))
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  StampE
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: StampE
LSP: Generating Completions for prefix: StampE
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "moji"
root ::= completions

Top 20 Logits:
mo:32.2722
MO:18.7874	rejected
mu:17.4146	rejected
emo:17.2589	rejected
omo:17.0812	rejected
мо:16.8768	rejected
mit:16.71	rejected
 mo:16.5141	rejected
lem:16.4082	rejected
mi:16.1944	rejected
mm:16.1705	rejected
imo:15.2282	rejected
ma:14.9512	rejected
mos:14.5107	rejected
me:14.1549	rejected
amo:13.7482	rejected
mor:13.6639	rejected
Mo:13.5864	rejected
mer:13.0709	rejected
no:13.0069	rejected
moz:12.9464	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmo

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmo
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <StampEmo>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "StampEmo"))))
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  StampEmo
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: StampEmo
LSP: Generating Completions for prefix: StampEmo
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ji"
root ::= completions

Top 20 Logits:
ji:31.6582
iji:18.1946	rejected
ij:17.5427	rejected
 ji:17.0669	rejected
je:16.9542	rejected
jo:16.5767	rejected
ja:16.3116	rejected
j:16.283
ju:14.3437	rejected
ii:13.99	rejected
js:13.3865	rejected
 Ji:13.3591	rejected
yi:13.2115	rejected
ije:12.7555	rejected
J:12.6551	rejected
jin:12.247	rejected
ijo:12.1967	rejected
xi:12.021	rejected
jih:11.8117	rejected
ci:11.8011	rejected
jan:11.675	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <StampEmoji>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ((Int, Int) -> (SelectEmoji(String) + StampEmoji((Int, Int)) + ClearCell((Int, Int)) + ClearGrid + FillRow(Int)))
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Var "Action");
           syn = (Arrow ((Prod [(Var "Row"); (Var "Col")]), (Var "Action")))})))
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  StampEmoji
Nature of error: Expecting type Action but got inconsistent type ((Row, Col) -> Action)
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: StampEmoji
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: StampEmoji
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
(:21.1667
 (:15.4963
(_:14.7271	rejected
((:14.557	prefix accepted:(
([:13.5375	prefix accepted:(
 row:13.4933	rejected
({:13.0393	prefix accepted:(
(":12.0473	prefix accepted:(
 r:12.022	rejected
  :11.6271
(-:11.3671	prefix accepted:(
 at:11.2962	rejected
 _:11.2557	rejected
 :11.1228
():11.0943	prefix accepted:(
 i:10.5485	rejected
   :10.5139
[:10.4748	rejected
       :10.4705
 x:10.4475	rejected
    :10.4307

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (SelectEmoji(String) + StampEmoji((Int, Int)) + ClearCell((Int, Int)) + ClearGrid + FillRow(Int))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (SelectEmoji(String) + StampEmoji((Int, Int)) + ClearCell((Int, Int)) + ClearGrid + FillRow(Int))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Row, Col)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: (Row, Col)
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "()" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= completions | new-tokens

Top 20 Logits:
row:20.3989
r:17.8379
x:15.6214
i:15.5518
y:14.5307
0:13.4475
1:12.4171
pos:12.3373
col:12.2736
Row:12.1221	rejected
selected:12.1106
2:12.0948
_,:11.8252	prefix accepted:_
3:11.8058
a:11.6607
rw:11.6426
idx:11.5272
at:11.3142
cell:11.108
n:11.0069
target:10.9214

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <row>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Row, Col)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {row: (Row, Col), action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: (Row, Col)
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: row
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: row
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
,:19.3344
To:16.6655
Id:14.8406
Index:14.5016
I:13.871
Pos:12.8544
 ,:12.826
',:12.7711	rejected
_:12.5149
N:12.1146
Selected:12.1064
Num:12.0766
::11.8689	rejected
No:11.8273
i:11.7176
_,:11.7076	prefix accepted:_
Number:11.6853
ID:11.5599
1:11.5516
St:11.5076
Position:11.0576

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Row, Col)
  LSP: Info: Seft type: (Int, Int)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Row, Col)
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Row, Col)
  LSP: Info: Seft type: (Int, Int)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Row, Col)
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Col
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Row, Col)
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 col:21.1683
col:16.328
 column:16.0085
  :14.1698
 :12.8225
 c:11.8227
 cell:11.3521
column:11.1358
   :10.7452
 row:10.7449
 coll:10.3478
 cols:10.2146
 cl:10.1367
 x:10.1321
 i:10.0736
 Col:9.99228	rejected
    :9.69249
 _):9.69001	prefix accepted: _
 columns:9.62094
 co:9.52151
 pos:9.43688

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <col>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Col
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Row, Col)
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: col
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: col
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
):20.664
)->:14.2961	prefix accepted:)
 ):14.1752
)=:14.0156	prefix accepted:)
),:13.2533
)|:13.1228	prefix accepted:)
,:13.0942
)::11.2657	prefix accepted:)
 as:10.7274	rejected
 +:10.6295	rejected
)):10.6162
'):10.1763	rejected
1:10.1175
);:10.0314	prefix accepted:)
um:10.0302
To:9.98602
)>:9.92833	prefix accepted:)
_:9.8031
 :9.77704
){:9.5784	prefix accepted:)
)':9.51185	prefix accepted:)

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col)

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (SelectEmoji(String) + StampEmoji((Int, Int)) + ClearCell((Int, Int)) + ClearGrid + FillRow(Int))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:19.0992
 :14.1598
 ->:13.764	rejected
  :13.5482
 if:12.6403	rejected
 when:12.6366	rejected

:12.4077
    :12.0882
   :11.5948
     :11.3895
      :11.0992
       :10.6197
=>:10.4217
        :10.3672
                :10.3238
         :10.0781
          :10.0524
 as:9.88969	rejected
 |:9.82049	rejected
 {:9.63981	rejected
           :9.43563

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) =>

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) =>
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "col" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "row" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 (:18.7714
 :17.2212

:16.8931
 update:16.0329
 let:14.9869
  :14.9816
 ((:14.8341	prefix accepted: (
 if:13.4164
(:13.1025
                :13.0746
    :12.9967
     :12.008
 #:11.9739	rejected
      :11.9032
 ([:11.8902	prefix accepted: (
 List:11.8439	rejected
   :11.7064
        :11.5573
       :11.1851
            :11.1556
 model:11.0448

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "col" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "row" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:21.5351
 (:18.6835
 update:16.6802
 ((:14.3849	prefix accepted: (
 #:14.1165	rejected
 let:13.9754
 if:13.6598
	:13.1653	rejected
 List:12.4937	rejected
 grid:12.4811
 (*:11.9786	prefix accepted: (
 ([:11.8497	prefix accepted: (
 //:11.7147	rejected
 begin:11.5438	rejected
 Update:11.4789	rejected
 <:11.4214	rejected
 #(:11.3446	rejected
 model:11.2946
 [(:11.2529	prefix accepted: [
1:11.1344
 [:11.2529

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 


LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "col" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "row" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
     :22.0213
       :20.9787
      :19.5763
        :17.6798
         :17.5069
    :16.4116
           :16.0149
          :15.4627
                :15.3818
	:15.0853	rejected
             :14.732
            :14.6593
   :14.5116
               :14.4821
              :13.8885

:12.7435
  :12.5931
#:12.4244	rejected
 :11.3303
(:9.72979
//:9.25061	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
     

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
     
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "col" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "row" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 let:21.4811
 (:20.4997
 if:18.9378
 update:18.3325
 ((:16.4656	prefix accepted: (
 #:16.3513	rejected
 List:15.9919	rejected
 match:15.3252	rejected
 begin:15.195	rejected
 case:14.9141
 clear:14.8941
 ([:14.8746	prefix accepted: (
 (*:14.7746	prefix accepted: (
 print:14.5986	rejected
 model:14.3038
 [(:14.1603	prefix accepted: [
 grid:14.0286
 //:13.5832	rejected
 assert:13.5632	rejected
 St:13.4874
 Model:13.4801	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "col" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "row" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
update:19.0033

:15.5004
 update:15.4284
 :12.9223
grid:12.1926
  :12.0799
List:12.0101	rejected
if:11.5275
model:11.2894
 grid:10.4982
Grid:10.483	rejected
E:10.1358	rejected
                :10.1121
Update:10.0123	rejected
clear:9.96173
let:9.80947
updated:9.8004	rejected
    :9.77272
#:9.63896	rejected
 List:9.56851	rejected
action:9.52617

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (update

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (update
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <update>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ((([[String]], String, [String]), (SelectEmoji(String) + StampEmoji((Int, Int)) + ClearCell((Int, Int)) + ClearGrid + FillRow(Int))) -> ([[String]], String, [String]))
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model");
           syn =
           (Arrow ((Prod [(Var "Model"); (Var "Action")]), (Var "Model")))})))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  update
Nature of error: Expecting type Model but got inconsistent type ((Model, Action) -> Model)
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: update
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: update
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Grid"
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= completions | new-tokens

Top 20 Logits:
Grid:24.6971
(:14.7912
_:14.6197	rejected
G:14.119
In:12.636	rejected
Row:12.045	rejected
Cell:11.9474	rejected
Graph:11.759	rejected
Model:11.7102	rejected
grid:11.5563	rejected
E:11.4824	rejected
GridView:11.4743	rejected
 Grid:11.4378	rejected
GR:11.318	rejected
Gr:11.0603
 grid:10.9518	rejected
At:10.7347	rejected
::10.6933
Group:10.587	rejected
Grad:10.5561	rejected
Selected:10.2852	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <updateGrid>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (([[String]], Int, Int, String) -> [[String]])
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model");
           syn =
           (Arrow (
              (Prod [(Var "Grid"); (Var "Row"); (Var "Col"); (Var "Emoji")]),
              (Var "Grid")))})))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid
Nature of error: Expecting type Model but got inconsistent type ((Grid, Row, Col, Emoji) -> Grid)
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: updateGrid
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: updateGrid
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
(:20.7332
 grid:14.3895	rejected
 (:14.2895
((:13.772	prefix accepted:(
!(:12.5386	prefix accepted:!
?(:12.0521	rejected
(?:11.9567	prefix accepted:(
[:11.8967	rejected
(!:11.8553	prefix accepted:(

:11.5827
::11.2169
([:11.2119	prefix accepted:(
 ?:11.1253	rejected
,:11.1225
.:11.0385	rejected
(*:10.8002	prefix accepted:(
.(:10.5936	rejected
  :10.5772
<:10.5085
(@:10.4594	prefix accepted:(
 !:10.0154

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [[String]]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = (Var "Model"); syn = (Var "Grid")})))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(?)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [[String]]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = (Var "Model"); syn = (Var "Grid")})))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(?)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(?)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "col" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "row" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
grid:20.356
row:14.5682
 grid:14.5674

:14.4613
selected:13.1718
clear:12.8764
model:12.5295
update:12.0566
action:12.0333
g:11.641
x:11.577	rejected
copy:11.2224	rejected
0:10.9582
List:10.9443	rejected
#:10.7536	rejected
  :10.6647
f:10.6519
if:10.5674
Grid:10.4553	rejected
 :10.3519
s:10.1911

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <grid>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Seft type: [[String]]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana =
           (Prod [(Var "Grid"); (Var "Row"); (Var "Col"); (Var "Emoji")]);
           syn = (Var "Grid")})))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  grid
Nature of error: Expecting type (Grid, Row, Col, Emoji) but got inconsistent type Grid  
Error in term:
  updateGrid(grid)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: grid
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: grid
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:21.2556
 ,:14.3494
 row:13.433	rejected
::12.8486
.:11.4083	rejected
,(:11.0982	prefix accepted:,
)(:10.9943	prefix accepted:)
 =:10.5899
,,:10.3791	prefix accepted:,
 ::10.1821
,\:10.1281	prefix accepted:,
=:9.44163
 ?:9.38562	rejected
 @:9.30876
!,:9.25921	prefix accepted:!
 +:9.20306
),:9.18561	prefix accepted:)
@:9.0914
):10.9943
_:8.99863	rejected
 /*:8.95702	prefix accepted: /

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Seft type: ([[String]], ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana =
           (Prod [(Var "Grid"); (Var "Row"); (Var "Col"); (Var "Emoji")]);
           syn = (Prod [(Var "Grid"); (Unknown Internal)])})))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(grid, ?)
Nature of error: Expecting type Model but got inconsistent type Grid  
Error in term:
  grid, ?
Nature of error: Expecting type (Grid, Row, Col, Emoji) but got inconsistent type (Grid, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Seft type: ([[String]], ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana =
           (Prod [(Var "Grid"); (Var "Row"); (Var "Col"); (Var "Emoji")]);
           syn = (Prod [(Var "Grid"); (Unknown Internal)])})))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(grid, ?)
Nature of error: Expecting type Model but got inconsistent type Grid  
Error in term:
  grid, ?
Nature of error: Expecting type (Grid, Row, Col, Emoji) but got inconsistent type (Grid, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(grid, ?)
Nature of error: Expecting type Model but got inconsistent type Grid  
Error in term:
  grid, ?
Nature of error: Expecting type (Grid, Row, Col, Emoji) but got inconsistent type (Grid, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "col" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "row" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 row:21.3548
row:14.5642
 col:13.251
 :12.5545
 Row:12.4591	rejected
 (:11.2689
 Int:11.2161	rejected
 List:11.095	rejected
 int:10.7706
  :10.6208
 ro:10.4582

:10.378
 ?:10.2879	rejected
 i:9.94708
 selected:9.77362
col:9.60552
 grid:9.25956
 r:9.15288
 rows:9.12955	rejected
    :9.03303
 Em:8.93066	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <row>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(grid, row)
Nature of error: Expecting type Model but got inconsistent type Grid  
Error in term:
  grid, row
Nature of error: Expecting type (Grid, Row, Col, Emoji) but got inconsistent type (Grid, Row)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: row
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: row
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:20.1553
 -:15.8511
 ,:14.4837
 +:14.3496
-:14.1801
To:14.0084	rejected
+:12.7147
 %:12.387	rejected
 as:11.2808	rejected
%:11.2795	rejected
::11.2764
.:10.8894	rejected
 ?:10.2242	rejected
 *:9.96786
 col:9.74041	rejected
 mod:9.66129	rejected
?,:9.59814	rejected
 /:9.42898
 ::9.23758
,\:9.15384	prefix accepted:,
Int:9.09492	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Seft type: ([[String]], Int, ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana =
           (Prod [(Var "Grid"); (Var "Row"); (Var "Col"); (Var "Emoji")]);
           syn = (Prod [(Var "Grid"); (Var "Row"); (Unknown Internal)])})))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(grid, row, ?)
Nature of error: Expecting type Model but got inconsistent type Grid  
Error in term:
  grid, row, ?
Nature of error: Expecting type (Grid, Row, Col, Emoji) but got inconsistent type (Grid, Row, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Seft type: ([[String]], Int, ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana =
           (Prod [(Var "Grid"); (Var "Row"); (Var "Col"); (Var "Emoji")]);
           syn = (Prod [(Var "Grid"); (Var "Row"); (Unknown Internal)])})))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(grid, row, ?)
Nature of error: Expecting type Model but got inconsistent type Grid  
Error in term:
  grid, row, ?
Nature of error: Expecting type (Grid, Row, Col, Emoji) but got inconsistent type (Grid, Row, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(grid, row, ?)
Nature of error: Expecting type Model but got inconsistent type Grid  
Error in term:
  grid, row, ?
Nature of error: Expecting type (Grid, Row, Col, Emoji) but got inconsistent type (Grid, Row, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "col" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "row" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 col:21.1172
col:15.3418
 :13.7683
  :11.8722
 row:11.4402
 Col:11.2911	rejected
 column:11.0958	rejected
 co:10.3829
 cl:10.2608
    :10.2466

:10.0983
 (:9.80423
 cols:9.78964	rejected
   :9.78385
 c:9.696
 int:9.58162
 ,:9.31838	rejected
 -:9.27752
	:9.27572	rejected
 _,:9.19951	rejected
                :9.09212

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <col>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(grid, row, col)
Nature of error: Expecting type Model but got inconsistent type Grid  
Error in term:
  grid, row, col
Nature of error: Expecting type (Grid, Row, Col, Emoji) but got inconsistent type (Grid, Row, Col)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: col
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: col
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:21.6428
 ,:15.333
 selected:12.3208	rejected
),:11.4436	prefix accepted:)
 +:11.2601
.:10.8986	rejected
 -:10.877
::10.4223
 :9.63918
,,:9.36096	prefix accepted:,
.,:9.28512	rejected
,\:9.26914	prefix accepted:,
+:9.26671
,(:9.16532	prefix accepted:,
):11.4436
,":8.96105	prefix accepted:,
 ::8.79573
-:8.77908
 =:8.72952
  :8.65085
 *:8.55939

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Seft type: ([[String]], Int, Int, String)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(grid, row, col, ?)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Seft type: ([[String]], Int, Int, String)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(grid, row, col, ?)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Emoji
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(grid, row, col, ?)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "col" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "row" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 selected:20.6838
selected:13.4171
 :12.3139
 f:11.0025
 s:10.8714
 select:10.755
 if:10.7283
 ":10.6205
 em:10.5535	rejected
 List:10.3831	rejected
 grid:9.96607
  :9.9376

:9.92897
 Em:9.71595	rejected
 (:9.69626
 Selected:9.60806	rejected
 !:9.48356
 sel:9.44276
 Some:9.43705	rejected
 available:9.35301
 ?:9.33667	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selected

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selected
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <selected>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Emoji
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "selected"))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(grid, row, col, selected)
Nature of error: Expecting type Model but got inconsistent type Grid  
Error in term:
  selected
Nature of error: Variable selected is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: selected
LSP: Generating Completions for prefix: selected
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Emoji"
root ::= completions

Top 20 Logits:
E:22.1306
Em:12.9299
_:12.1407	rejected
),:11.86	rejected
EM:10.622	rejected
 E:10.5692	rejected
emo:9.88692	rejected
em:9.85816	rejected
G:9.6078	rejected
Model:9.46227	rejected
Grid:9.22632	rejected
Empty:9.2101	rejected
Value:9.16999	rejected
.:9.08628	rejected
Element:9.04771	rejected
 em:8.99974	rejected
)):8.9141	rejected
 =:8.90059	rejected
e:8.76565	rejected
()),:8.73987	rejected
Cell:8.72102	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedE

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedE
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <selectedE>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Emoji
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "selectedE"))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(grid, row, col, selectedE)
Nature of error: Expecting type Model but got inconsistent type Grid  
Error in term:
  selectedE
Nature of error: Variable selectedE is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: selectedE
LSP: Generating Completions for prefix: selectedE
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "moji"
root ::= completions

Top 20 Logits:
mo:29.7786
imo:19.1934	rejected
omo:18.2064	rejected
emo:18.0002	rejected
MO:16.6454	rejected
мо:16.2888	rejected
jo:14.9537	rejected
 mo:14.9014	rejected
mu:14.3224	rejected
mm:14.2715	rejected
po:14.1675	rejected
ermo:13.4445	rejected
Mo:13.4055	rejected
no:13.3694	rejected
meno:13.1844	rejected
oo:12.9414	rejected
amo:12.9372	rejected
ko:12.4648	rejected
go:12.386	rejected
cho:12.2885	rejected
o:12.2241	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmo

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmo
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <selectedEmo>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Emoji
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "selectedEmo"))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  selectedEmo
Nature of error: Variable selectedEmo is not bound  
Error in term:
  updateGrid(grid, row, col, selectedEmo)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: selectedEmo
LSP: Generating Completions for prefix: selectedEmo
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ji"
root ::= completions

Top 20 Logits:
ji:28.491
 ji:16.8156	rejected
yi:15.8708	rejected
ja:15.6331	rejected
jih:15.4173	rejected
iji:15.2936	rejected
 Ji:13.8113	rejected
jo:13.4048	rejected
ei:13.0884	rejected
je:12.4856	rejected
xi:12.1042	rejected
json:11.0746	rejected
jin:10.8695	rejected
ји:10.8521	rejected
ii:10.6632	rejected
qi:10.6596	rejected
i:10.3936	rejected
J:10.2904	rejected
ij:10.2649	rejected
ai:10.2645	rejected
jem:10.1271	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <selectedEmoji>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Emoji
  LSP: Info: Seft type: String
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(grid, row, col, selectedEmoji)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: selectedEmoji
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: selectedEmoji
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
),:20.004	prefix accepted:)
):20.004
)):12.7071
),\:12.6997	prefix accepted:)
 ),:12.4022	prefix accepted: )
)),:12.3954	prefix accepted:))
,:12.1984
),(:11.6782	prefix accepted:)
)[:10.2443	prefix accepted:)

:10.2087
::10.1916
()),:10.1002	prefix accepted:(
);:10.0089	prefix accepted:)
).:9.71047	rejected
)::9.64289	prefix accepted:)
.:9.46722	rejected
[:9.45542	rejected
 :9.24492
)(:9.16679	prefix accepted:)
 +:9.07781
)\:9.07561	prefix accepted:)
Rejected the highest logit candidate ), with logit -inf

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [[String]]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = (Var "Model"); syn = (Var "Grid")})))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(grid, row, col, selectedEmoji)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
 ,:16.3158

:15.1949
 :13.2519
  :12.724
 \:11.9972
    :11.2491
 grid:11.2271	rejected
 ::11.033
                :10.901
 |:10.828	rejected
   :10.6987
 #:10.6154	rejected
 as:10.2616	rejected
      :10.1178
 model:10.0735	rejected
       :9.78572
        :9.708
 :::9.70446
 (:9.59493
     :9.56943
:::9.56104

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)


LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [[String]]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = (Var "Model"); syn = (Var "Grid")})))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(grid, row, col, selectedEmoji)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
      :19.8821
       :18.9734
     :18.9456
    :16.4861
         :16.0126
                :15.8986
        :15.8056
   :15.3939
           :14.6257
             :14.0191
          :13.9344
	:13.9308	rejected
,:13.6605
               :13.5411
            :13.2665
  :13.2503
              :12.7738
 :12.6554

:11.3529
 ,:10.9124
#:10.7917	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
       

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
       
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [[String]]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = (Var "Model"); syn = (Var "Grid")})))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(grid, row, col, selectedEmoji)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
 ,:19.0224
 grid:16.4583	rejected
 (:14.7864
 ::13.363
 |:13.0983	rejected
 #:12.8998	rejected
 selected:12.7589	rejected
 (*:12.3419	prefix accepted: (
 handle:12.3075	rejected
 model:12.1827	rejected
 :::11.8599
 update:11.8087	rejected
 //:11.6657	prefix accepted: /
 .:11.4824	rejected
 if:11.4522	rejected
 List:11.1723	rejected
	:11.1393	rejected
 row:11.091	rejected
 @:11.0123
 [:10.9888	rejected

:10.9424

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        ,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        ,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model");
           syn = (Prod [(Var "Grid"); (Unknown Internal)])})))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(grid, row, col, selectedEmoji), ?
Nature of error: Expecting type Model but got inconsistent type (Grid, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model");
           syn = (Prod [(Var "Grid"); (Unknown Internal)])})))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(grid, row, col, selectedEmoji), ?
Nature of error: Expecting type Model but got inconsistent type (Grid, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(grid, row, col, selectedEmoji), ?
Nature of error: Expecting type Model but got inconsistent type (Grid, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "col" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "row" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 selected:17.0098
selected:16.4141
 :12.6673

:12.3835
 available:10.612
  :10.5379
 Selected:9.74168	rejected
 select:9.65685
 (:9.52374
 em:9.51691	rejected
 Em:8.91337	rejected
                :8.90958
available:8.57867
 grid:8.5712
 update:8.43534
   :8.3869
 if:8.33502
 ":8.29869
Selected:8.20412	rejected
 \:8.20395	rejected
 List:8.19476	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selected

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selected
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <selected>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "selected"))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(grid, row, col, selectedEmoji), selected
Nature of error: Expecting type Model but got inconsistent type (Grid, ?)  
Error in term:
  selected
Nature of error: Variable selected is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: selected
LSP: Generating Completions for prefix: selected
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Emoji"
root ::= completions

Top 20 Logits:
E:21.987
Em:12.9809
_:12.6892	rejected
emo:11.6812	rejected
,:10.5584	rejected
 em:10.0615	rejected
EM:10.0259	rejected
em:9.98503	rejected

:9.86388	rejected
 E:9.55363	rejected
G:9.4121	rejected
Index:9.09067	rejected
Color:9.06414	rejected
Empty:9.03362	rejected
Value:9.02833	rejected
T:8.91417	rejected
Cell:8.81114	rejected
X:8.6845	rejected
S:8.68239	rejected
Row:8.63323	rejected
Selected:8.57017	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedE

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedE
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <selectedE>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "selectedE"))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(grid, row, col, selectedEmoji), selectedE
Nature of error: Expecting type Model but got inconsistent type (Grid, ?)  
Error in term:
  selectedE
Nature of error: Variable selectedE is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: selectedE
LSP: Generating Completions for prefix: selectedE
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "moji"
root ::= completions

Top 20 Logits:
mo:29.9874
MO:18.9602	rejected
omo:17.9312	rejected
emo:17.6707	rejected
jo:17.5583	rejected
imo:17.2085	rejected
мо:16.8753	rejected
Mo:15.8898	rejected
o:15.7419	rejected
 mo:15.0478	rejected
m:15.0339
mit:14.3729	rejected
amo:14.3499	rejected
po:14.2764	rejected
cho:14.0563	rejected
no:13.9801	rejected
mos:13.3653	rejected
ma:13.0056	rejected
mu:12.9433	rejected
go:12.7601	rejected
ermo:12.7257	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmo

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmo
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <selectedEmo>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "selectedEmo"))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(grid, row, col, selectedEmoji), selectedEmo
Nature of error: Expecting type Model but got inconsistent type (Grid, ?)  
Error in term:
  selectedEmo
Nature of error: Variable selectedEmo is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: selectedEmo
LSP: Generating Completions for prefix: selectedEmo
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ji"
root ::= completions

Top 20 Logits:
ji:31.4538
 ji:18.0019	rejected
jin:17.7849	rejected
jo:17.7464	rejected
j:17.5134
iji:16.1849	rejected
jih:15.798	rejected
je:15.057	rejected
jen:14.6446	rejected
ja:14.3953	rejected
xi:14.3123	rejected
jp:14.3008	rejected
ju:14.1001	rejected
jet:14.0575	rejected
 Ji:14.0395	rejected
jar:13.8894	rejected
chi:13.8125	rejected
ји:13.162	rejected
jpg:13.1285	rejected
js:13.0144	rejected
jer:12.8179	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <selectedEmoji>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: String
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(grid, row, col, selectedEmoji), selectedEmoji
Nature of error: Expecting type Model but got inconsistent type (Grid, Emoji)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: selectedEmoji
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: selectedEmoji
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:20.7803

:19.9779
 :17.4359
  :16.4975
 ,:15.1083
    :14.8068
                :14.7805
      :13.8778
 #:13.746	rejected
   :13.6364
        :13.3645
          :13.0761
):13.041
         :12.7726
     :12.7369
            :12.7312
 +:12.45
             :12.2931
              :12.2581
       :12.1321
               :12.0568

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Emoji]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "col" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "row" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 available:18.9171

:15.9628
 :15.8042
available:13.5594
  :13.1498
 [:11.7117
    :11.5019
                :11.3534
        :10.787
 av:10.6248
   :10.618
 selected:10.484
 #:10.3026	rejected
 avail:10.2786
      :10.102
     :9.92371
         :9.89785
            :9.6084
 List:9.56346	rejected
          :9.56313
 \:9.41823	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, available

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, available
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <available>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Emoji]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "available"))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  available
Nature of error: Variable available is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: available
LSP: Generating Completions for prefix: available
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Emojis"
root ::= completions

Top 20 Logits:
Em:23.3107
E:13.2862
_:12.3832	rejected
em:11.8301	rejected
EM:11.2161	rejected
 Em:11.1835	rejected
):10.6148	rejected
Om:10.4416	rejected
Emp:10.3231	rejected
M:10.1728	rejected
Im:10.1628	rejected

:10.1427	rejected
 em:9.93289	rejected
Er:9.65716	rejected
Sm:9.63732	rejected
Rem:9.48736	rejected
Tem:9.45141	rejected
G:9.39937	rejected
A:9.33206	rejected
En:9.09855	rejected
Sim:9.08078	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEm

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEm
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <availableEm>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Emoji]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "availableEm"))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  availableEm
Nature of error: Variable availableEm is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: availableEm
LSP: Generating Completions for prefix: availableEm
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ojis"
root ::= completions

Top 20 Logits:
oj:28.4627
jos:15.8274	rejected
jo:13.6776	rejected
ij:13.5671	rejected
ijo:12.3379	rejected
os:11.9197	rejected
j:11.8693	rejected
ot:11.516	rejected
otos:10.9298	rejected
ois:10.4371	rejected
otic:10.1593	rejected

:10.0892	rejected
ok:9.72207	rejected
jp:9.19595	rejected
osh:9.05277	rejected
uj:9.02905	rejected
ej:8.99003	rejected
jor:8.98975	rejected
 ej:8.88844	rejected
o:8.87456
voj:8.83151	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmoj

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmoj
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <availableEmoj>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Emoji]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "availableEmoj"))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  availableEmoj
Nature of error: Variable availableEmoj is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: availableEmoj
LSP: Generating Completions for prefix: availableEmoj
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "is"
root ::= completions

Top 20 Logits:
is:26.433
ins:16.5411	rejected
iss:14.1836	rejected
Is:13.3929	rejected
ies:12.9623	rejected
ius:12.5175	rejected
i:12.4585
ios:12.4099	rejected
ips:12.373	rejected
ij:12.3379	rejected
js:12.3018	rejected
isf:12.2866	rejected
ias:12.2324	rejected
irs:12.2201	rejected
 is:12.1368	rejected
ís:11.5851	rejected
ims:11.5634	rejected
ils:11.5429	rejected
isan:11.3821	rejected
isu:11.1038	rejected
ists:11.0966	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <availableEmojis>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Emoji]
  LSP: Info: Seft type: [String]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: availableEmojis
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: availableEmojis
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
):22.0923
 ):18.8553

:18.8363
 :16.0766
  :15.9882
),:15.4545	prefix accepted:)
,:15.1644
)):14.8694
    :14.2888
                :13.9933
      :13.767
);:13.4565	prefix accepted:)
        :13.3668
   :13.1897
 #:12.9557	rejected
          :12.6158
     :12.5174
)\:12.4279	prefix accepted:)
         :12.3783
            :12.3428
)]:12.3425	prefix accepted:)

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:19.5491
  :16.7988
 :16.5387
    :15.4855
      :15.0885
 #:14.4414	rejected
        :14.3512
   :13.844
                :13.671
          :13.1834
         :13.0983
     :12.9723
            :12.8842
       :12.7931
           :12.4052
              :12.0529
 in:11.8032	rejected
             :11.6436
               :11.5145
 (*:10.9349	prefix accepted: (
	:10.7709	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)


LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
   :19.4377
    :16.0476
      :15.1228
  :15.1149
        :14.8516

:14.7424
     :14.0522
       :13.7564
         :13.4625
          :13.1726
                :12.8492
            :12.7714
 :12.7674
#:12.3695	rejected
	:12.2631	rejected
           :12.0966
              :11.51
             :11.4107
|:11.3047
               :11.0335
(*:10.0577	prefix accepted:(

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
   

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
   
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:22.4272
 #:16.0644	rejected
 (*:13.6431	prefix accepted: (
 //:13.099	prefix accepted: /

:13.0158
 Clear:12.741	rejected
 case:11.9985	rejected
 clear:11.9839	rejected
	:11.7876	rejected
 /*:11.5226	prefix accepted: /
 /:13.099
 end:11.3227
 (:13.6431
 ||:10.9246	prefix accepted: |
 -:10.6098
 |\:10.5847	prefix accepted: |
 ~:10.5323	rejected
 +:10.5307
 <:10.4723
 ##:10.4112	rejected
 if:10.3913	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    |

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    |
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 Clear:21.2455
 F:17.4131
 _:13.6725
Clear:12.2369
 :11.8829
 St:10.7794
 clear:10.6081
 Cle:10.4701
 Fil:10.1973
 Select:10.0795
  :9.86181
 Remove:9.81855	rejected
 Update:9.59172	rejected
 #:9.4129	rejected
 Set:9.35409	rejected
 Res:9.09348	rejected
 Make:9.01015	rejected
 (:8.93493
 Em:8.88284	rejected
 Delete:8.75666	rejected
 Add:8.67216	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | Clear

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | Clear
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Clear>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "Clear"))))
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  Clear
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Clear
LSP: Generating Completions for prefix: Clear
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Cell" | "Grid"
root ::= completions

Top 20 Logits:
Cell:24.0192
Grid:19.2947
Row:16.3158	rejected
E:14.1695	rejected
Cells:14.0365	rejected
Column:13.2151	rejected
All:13.0493	rejected
GridView:12.6085	rejected
cell:12.5496	rejected
Color:12.4426	rejected
Card:12.1919	rejected
Game:12.0593	rejected
Group:12.0181	rejected
Cache:12.0047	rejected
G:11.9163
Circ:11.9085	rejected
Graph:11.8968	rejected
Col:11.8683	rejected
CE:11.7977	rejected
Graphics:11.6801	rejected
 Cell:11.6732	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <ClearCell>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ((Int, Int) -> (SelectEmoji(String) + StampEmoji((Int, Int)) + ClearCell((Int, Int)) + ClearGrid + FillRow(Int)))
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Var "Action");
           syn = (Arrow ((Prod [(Var "Row"); (Var "Col")]), (Var "Action")))})))
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  ClearCell
Nature of error: Expecting type Action but got inconsistent type ((Row, Col) -> Action)
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: ClearCell
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: ClearCell
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
(:21.7677
 (:16.4232
(_:16.2906	rejected
((:14.0346	prefix accepted:(
 _:13.2658	rejected
([:12.836	prefix accepted:(
():12.6522	prefix accepted:(
 ->:11.7909	rejected
 =>:11.7707
 row:11.6827	rejected
 :11.6682
  :11.6289
[:11.0726	rejected
({:10.9613	prefix accepted:(
 (_:10.5495	rejected
(":10.4182	prefix accepted:(
 =:10.2855
 c:10.1512	rejected
 cell:10.1347	rejected
(-:10.0444	prefix accepted:(
 x:9.9843	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (SelectEmoji(String) + StampEmoji((Int, Int)) + ClearCell((Int, Int)) + ClearGrid + FillRow(Int))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (SelectEmoji(String) + StampEmoji((Int, Int)) + ClearCell((Int, Int)) + ClearGrid + FillRow(Int))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Row, Col)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: (Row, Col)
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "()" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= completions | new-tokens

Top 20 Logits:
row:21.012
r:17.6673
i:15.7881
x:15.0415
_,:14.8676	prefix accepted:_
0:14.0628
col:13.206
cell:13.0481
y:12.9448
 row:12.4021
rw:12.2551
a:12.0893
1:12.0581
Row:12.0488	rejected
idx:11.975
3:11.7446
rc:11.5749
m:11.52
2:11.4852
rows:11.3721
grid:11.2666

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <row>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Row, Col)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {row: (Row, Col), action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: (Row, Col)
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: row
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: row
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
,:20.7366
To:16.322
 ,:13.656
',:12.4804	rejected
Clear:12.4368
Index:12.0009
C:11.8636
I:11.8561
Id:11.803
_,:11.4785	prefix accepted:_
1:11.4752
Pos:11.1688
2:11.0561
_:11.4785
At:10.8709
::10.6436	rejected
i:10.6196
Of:10.5238
.:10.311	rejected
0:10.0989
Col:9.72093

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Row, Col)
  LSP: Info: Seft type: (Int, Int)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Row, Col)
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Row, Col)
  LSP: Info: Seft type: (Int, Int)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Row, Col)
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Col
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Row, Col)
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 col:20.7454
col:17.4953
 column:14.1022
 :12.9289
 c:11.7282
 cell:11.4616
 coll:11.45
 _):11.4101	prefix accepted: _
 Col:11.3397	rejected
 cols:11.119
 row:11.0231
 cl:10.6003
  :10.5859
 _:11.4101
 co:10.0084
 i:9.94408
 x:9.14735
 pos:9.14474
 j:8.91376
 clear:8.84635
 idx:8.83064

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <col>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Col
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Row, Col)
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: col
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: col
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
):22.0931
)=:15.9277	prefix accepted:)
)->:15.7377	prefix accepted:)
 ):15.4062
),:12.9221
)):12.2009
,:11.6872
)>:11.4775	prefix accepted:)
 =>:11.3772	rejected
)|:11.3526	prefix accepted:)
)::11.3089	prefix accepted:)
 as:11.2564	rejected
To:10.9181
'):10.4603	rejected
){:10.4071	prefix accepted:)
_):10.4025	prefix accepted:_
)':10.2082	prefix accepted:)
)":10.1188	prefix accepted:)
1:10.0822
)]:9.87318	prefix accepted:)
 :9.82511

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col)

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (SelectEmoji(String) + StampEmoji((Int, Int)) + ClearCell((Int, Int)) + ClearGrid + FillRow(Int))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:20.3855
 ->:15.6386	rejected
 :15.5825
  :15.1125
    :12.8186
   :12.5581

:12.3161
      :11.8034
=>:11.2623
 when:11.229	rejected
 =:11.0488
     :10.965
        :10.8908
         :10.642
 if:10.5465	rejected
                :10.4974
          :10.4948
       :10.1122
 ==:10.0564	prefix accepted: =
            :9.95621
 >:9.91902	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "col" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "row" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 :19.3979

:18.4307
  :17.4284
 (:17.09
 update:15.05
    :14.6053
   :13.8452
      :13.7135
 ((:13.6929	prefix accepted: (
                :13.5058
 clear:13.3989
        :12.8502
     :12.8282
         :12.6399
(:12.5341
            :12.2832
          :12.0604
       :11.9755
               :11.964
             :11.7836
              :11.7209

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "col" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "row" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:22.5237
 #:17.5294	rejected
 (:16.7878
 update:15.546
	:15.3275	rejected
 #(:14.1115	rejected
 (*:13.3765	prefix accepted: (
 clear:12.7853
 ((:12.6395	prefix accepted: (
 //:12.5021	rejected
 let:11.8171
 *:11.7854	rejected
 
:11.696	rejected
 if:11.3669
 ?:11.341	rejected
 \:11.079	rejected
 <:10.9067	rejected
 ##:10.8415	rejected
 {:10.755	rejected
1:10.7458
 `(:10.6836	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  


LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "col" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "row" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
     :23.6109
      :22.3185
    :20.3336
       :20.2541
         :19.0778
        :19.0645
   :17.5156
           :17.1115
	:16.8767	rejected
          :16.8563
            :15.7709
             :15.4523
                :15.2266
               :14.5727
              :14.3341
  :14.2338
#:14.2111	rejected
 :14.1637

:13.6019
(:11.8172
//:11.0015	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
     

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
     
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "col" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "row" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 (:22.1595
 let:20.3847
 update:18.3989
 if:17.8055
 ((:17.5012	prefix accepted: (
 case:16.6279
 clear:16.4422
 #:16.3067	rejected
 List:16.2365	rejected
 begin:15.2635	rejected
 ([:15.0892	prefix accepted: (
 (*:14.9366	prefix accepted: (
 match:14.3505	rejected
 grid:13.6642
 [(:13.4172	prefix accepted: [
 [:13.4172
 print:12.7399	rejected
 try:12.6705	rejected
 #(:12.6362	rejected
 (":12.6069	prefix accepted: (
 Grid:12.251	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "col" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "row" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
update:18.6014
List:15.4528	rejected
 update:15.3665
clear:14.5961

:14.2479
let:13.3495
if:12.209
 List:12.1876	rejected
grid:12.0867
 :11.8733
case:11.7007
fill:11.2703
 clear:10.3878
replace:10.3717	rejected
  :10.343
 (:10.2351
list:10.0609	rejected
remove:9.80118	rejected
#:9.7343	rejected
Update:9.72949	rejected
((:9.72001	prefix accepted:(

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (update

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (update
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <update>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ((([[String]], String, [String]), (SelectEmoji(String) + StampEmoji((Int, Int)) + ClearCell((Int, Int)) + ClearGrid + FillRow(Int))) -> ([[String]], String, [String]))
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model");
           syn =
           (Arrow ((Prod [(Var "Model"); (Var "Action")]), (Var "Model")))})))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  update
Nature of error: Expecting type Model but got inconsistent type ((Model, Action) -> Model)
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: update
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: update
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Grid"
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= completions | new-tokens

Top 20 Logits:
Grid:22.3376
(:14.4365
Cell:13.2736	rejected
_:12.7685	rejected
Row:11.8953	rejected
 Grid:11.8674	rejected
Graph:11.6624	rejected
Clear:11.2845	rejected
E:11.0047	rejected
In:10.9183	rejected
GridView:10.8768	rejected
G:10.7037
At:10.6994	rejected
Group:10.2887	rejected
 grid:10.264	rejected
GR:10.1757	rejected
grid:10.0697	rejected
Gr:10.0274
Empty:10.0045	rejected
With:9.90439	rejected
Game:9.75892	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <updateGrid>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (([[String]], Int, Int, String) -> [[String]])
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model");
           syn =
           (Arrow (
              (Prod [(Var "Grid"); (Var "Row"); (Var "Col"); (Var "Emoji")]),
              (Var "Grid")))})))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid
Nature of error: Expecting type Model but got inconsistent type ((Grid, Row, Col, Emoji) -> Grid)
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: updateGrid
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: updateGrid
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
(:22.5418
 (:14.8124
((:14.6584	prefix accepted:(

:14.6273
(":13.5744	prefix accepted:(
(!:13.0489	prefix accepted:(
([:12.4098	prefix accepted:(
[:11.7867	rejected
 :11.6262
  :11.5688
 grid:11.5148	rejected
(*:11.2306	prefix accepted:(
():11.1506	prefix accepted:(
    :11.138
,:11.0142
(?:10.8525	prefix accepted:(
   :10.8238
(_:10.7756	rejected
!(:10.6209	prefix accepted:!
::10.4403
(),:10.4012	prefix accepted:(

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [[String]]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = (Var "Model"); syn = (Var "Grid")})))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(?)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [[String]]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = (Var "Model"); syn = (Var "Grid")})))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(?)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(?)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "col" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "row" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
grid:21.659
 grid:15.2564
clear:14.8049

:14.5117
update:13.9763
model:12.8202
List:11.4271	rejected
g:11.4028
row:11.0152
 :10.9836
remove:10.5534	rejected
Grid:10.4571	rejected
list:10.4146	rejected
fill:10.3772
selected:10.3386
x:10.3285	rejected
  :10.3242
gr:10.2061
get:10.0822	rejected
if:9.87472
delete:9.84808	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <grid>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Seft type: [[String]]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana =
           (Prod [(Var "Grid"); (Var "Row"); (Var "Col"); (Var "Emoji")]);
           syn = (Var "Grid")})))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  grid
Nature of error: Expecting type (Grid, Row, Col, Emoji) but got inconsistent type Grid  
Error in term:
  updateGrid(grid)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: grid
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: grid
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:21.4538
 ,:13.7007
::12.1361

:11.9123
,":11.4109	prefix accepted:,
,,:11.1343	prefix accepted:,
,(:10.7537	prefix accepted:,
.:10.6189	rejected
 :10.4559
),:9.76997	prefix accepted:)
):9.76997
 =:9.34093
,\:9.31911	prefix accepted:,
 ::9.25904
  :9.20807
 ?:8.98633	rejected
,[:8.7404	prefix accepted:,
",:8.73352	rejected
',:8.69749	rejected
    :8.6868
 row:8.62673	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Seft type: ([[String]], ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana =
           (Prod [(Var "Grid"); (Var "Row"); (Var "Col"); (Var "Emoji")]);
           syn = (Prod [(Var "Grid"); (Unknown Internal)])})))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(grid, ?)
Nature of error: Expecting type Model but got inconsistent type Grid  
Error in term:
  grid, ?
Nature of error: Expecting type (Grid, Row, Col, Emoji) but got inconsistent type (Grid, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Seft type: ([[String]], ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana =
           (Prod [(Var "Grid"); (Var "Row"); (Var "Col"); (Var "Emoji")]);
           syn = (Prod [(Var "Grid"); (Unknown Internal)])})))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(grid, ?)
Nature of error: Expecting type Model but got inconsistent type Grid  
Error in term:
  grid, ?
Nature of error: Expecting type (Grid, Row, Col, Emoji) but got inconsistent type (Grid, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(grid, ?)
Nature of error: Expecting type Model but got inconsistent type Grid  
Error in term:
  grid, ?
Nature of error: Expecting type (Grid, Row, Col, Emoji) but got inconsistent type (Grid, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "col" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "row" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 row:20.6159
row:14.8968
 :13.8284
 col:12.3605
 i:11.427
 Row:11.3461	rejected

:10.9971
  :10.9651
 (:10.8243
 r:10.292
    :10.2452
   :9.92023
 ro:9.84917
 rows:9.56575	rejected
 Int:9.55532	rejected
 int:9.39951
 ":9.30862
 ,:9.2156	rejected
 x:9.10915	rejected
 _,:8.99641	rejected
      :8.9031

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <row>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(grid, row)
Nature of error: Expecting type Model but got inconsistent type Grid  
Error in term:
  grid, row
Nature of error: Expecting type (Grid, Row, Col, Emoji) but got inconsistent type (Grid, Row)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: row
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: row
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:20.9059
 ,:13.9873
To:13.3852	rejected
 +:12.5917
 col:11.4089	rejected
+:11.1311
 -:10.8262

:10.2425
::9.71557
.:9.39388	rejected
 :9.2793
 To:9.14279	rejected
 %:9.06517	rejected
-:8.65817
 *:8.44802
 to:8.42122	rejected
,,:8.35236	prefix accepted:,
 ?:8.32908	rejected
 as:8.01087	rejected
,\:7.93685	prefix accepted:,
 =:7.86172

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Seft type: ([[String]], Int, ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana =
           (Prod [(Var "Grid"); (Var "Row"); (Var "Col"); (Var "Emoji")]);
           syn = (Prod [(Var "Grid"); (Var "Row"); (Unknown Internal)])})))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(grid, row, ?)
Nature of error: Expecting type Model but got inconsistent type Grid  
Error in term:
  grid, row, ?
Nature of error: Expecting type (Grid, Row, Col, Emoji) but got inconsistent type (Grid, Row, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Seft type: ([[String]], Int, ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana =
           (Prod [(Var "Grid"); (Var "Row"); (Var "Col"); (Var "Emoji")]);
           syn = (Prod [(Var "Grid"); (Var "Row"); (Unknown Internal)])})))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(grid, row, ?)
Nature of error: Expecting type Model but got inconsistent type Grid  
Error in term:
  grid, row, ?
Nature of error: Expecting type (Grid, Row, Col, Emoji) but got inconsistent type (Grid, Row, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(grid, row, ?)
Nature of error: Expecting type Model but got inconsistent type Grid  
Error in term:
  grid, row, ?
Nature of error: Expecting type (Grid, Row, Col, Emoji) but got inconsistent type (Grid, Row, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "col" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "row" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 col:21.1759
col:15.6664
 :13.7982
 row:11.6581
 Col:11.069	rejected
 column:11.0045	rejected
  :10.6065
 c:10.2738

:10.2731
 co:10.0372
 cols:9.99366	rejected
 cl:9.84304
 coll:9.75925	rejected
 ,:9.45512	rejected
    :9.15522
   :9.09058
 i:8.89099
 int:8.8758
	:8.87537	rejected
 _,:8.74343	rejected
 -:8.51897

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <col>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(grid, row, col)
Nature of error: Expecting type Model but got inconsistent type Grid  
Error in term:
  grid, row, col
Nature of error: Expecting type (Grid, Row, Col, Emoji) but got inconsistent type (Grid, Row, Col)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: col
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: col
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:21.495
,":17.5942	prefix accepted:,
 ,:14.4681
 :13.3474
 "",:13.043	rejected
),:11.9817	prefix accepted:)
::11.6325
 ":11.5472	rejected
,,:11.4395	prefix accepted:,
):11.9817
.:10.8989	rejected
",:10.7698	rejected
,':10.5891	prefix accepted:,
 -:10.4487
 _,:10.4038	rejected

:10.0835
,\:10.0212	prefix accepted:,
 "":9.85952	rejected
 ""):9.82187	rejected
 ::9.5883
,(:9.41766	prefix accepted:,

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Seft type: ([[String]], Int, Int, String)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(grid, row, col, ?)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Seft type: ([[String]], Int, Int, String)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(grid, row, col, ?)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Emoji
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(grid, row, col, ?)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "col" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "row" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 ""):19.6044	prefix accepted: ""
 ":17.5295
 "":19.6044
 """:11.7391	prefix accepted: ""
 ?:11.7321	rejected
 "",:11.4899	prefix accepted: ""
 selected:11.4338
 :11.3809
 "-:11.1366
 [:10.7861
 empty:10.6498	rejected
 "_:10.4441
 ''):10.3706	rejected
 "<:10.2145
 [":10.1605	prefix accepted: [
 "\:10.0716
 "...:10.0698
 Em:9.96056	rejected
 _):9.95048	rejected
 default:9.86611	rejected
 "):9.83378
Rejected the highest logit candidate  "") with logit -inf

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, ""

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, ""
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <"">
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: String literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Emoji
  LSP: Info: Seft type: String
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(grid, row, col, )
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Col, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: ""
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: ""
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
)):14.1346
 ):13.9222
),:13.8126	prefix accepted:)
 ),:13.6802	prefix accepted: )

:13.5278
)::12.957	prefix accepted:)
 as:11.5031	rejected
),(:11.4463	prefix accepted:)
 :11.2899
:::11.2842
 :::10.7648
],:10.7404	rejected
 /*:10.1058	prefix accepted: /
 ::9.83926
 +:9.7483
  :9.74343
},:9.55305	rejected
    :9.51991
),\:9.47645	prefix accepted:)
))):9.40987	prefix accepted:))
   :9.21894

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, ""))

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, ""))
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(grid, row, col, )
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:17.9498
 :15.7501
  :14.1378
 #:13.6038	rejected
    :13.5807
      :13.2999
 ,:12.9561
   :12.873
        :12.7447
#,:12.3004	rejected
 grid:12.1909	rejected
         :11.8463
          :11.8245
                :11.8079
            :11.7389
     :11.6979
),:11.6873	rejected
       :11.4702
           :11.1294
 (:10.9365
(:10.8209

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(grid, row, col, )
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:20.4204
 #:18.0317	rejected
 ,:15.5207
 grid:13.7545	rejected
 *:13.6858
 in:13.4465	rejected
 //:13.3086	prefix accepted: /
 \:13.2795
 (*:13.0505	prefix accepted: (
 #(:12.5926	rejected
 (:13.0505
	:12.2651	rejected
 ::12.1892
 +:12.0296
#,:12.0113	rejected
,":11.9051	prefix accepted:,
 _,:11.8984	rejected
 as:11.8909	rejected
 >:11.8158
 <:11.5727
 ->:11.5335	prefix accepted: -

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 


LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(grid, row, col, )
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
       :20.1891
   :19.8833
     :19.2522
      :17.936
        :16.881
         :16.4233
    :16.2851
                :15.2948
           :15.2735
	:14.7869	rejected
          :14.6309
             :14.1696

:13.6634
               :13.579
            :13.4935
  :13.3886
 :13.0605
              :12.9015
,:12.0497
#:11.4017	rejected
//:10.6681	prefix accepted:/

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
       

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
       
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  updateGrid(grid, row, col, )
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 ,:18.1232
 grid:17.44	rejected
 (:15.6152
 _,:13.3562	rejected
 if:13.258	rejected
 update:12.9996	rejected
 #:12.887	rejected
 +:12.5648
 ((:12.5379	prefix accepted: (
 (*:12.5208	prefix accepted: (
 ?:12.4231	rejected
 >:11.5533
 (\:11.1964	prefix accepted: (
 .:11.1729	rejected
 -:11.135
 ::11.1189
 row:11.0978	rejected
 *:10.919
 [:10.7615	rejected
 ->:10.7508	prefix accepted: -
 ),:10.6713	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        ,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        ,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model");
           syn = (Prod [(Var "Grid"); (Unknown Internal)])})))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  (updateGrid(grid, row, col, )), ?
Nature of error: Expecting type Model but got inconsistent type (Grid, ?)
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model");
           syn = (Prod [(Var "Grid"); (Unknown Internal)])})))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  (updateGrid(grid, row, col, )), ?
Nature of error: Expecting type Model but got inconsistent type (Grid, ?)
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  (updateGrid(grid, row, col, )), ?
Nature of error: Expecting type Model but got inconsistent type (Grid, ?)
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "col" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "row" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 selected:17.3153
selected:14.9345
 (:12.6387
 :11.7323
 "",:11.6991	prefix accepted: ""
 grid:11.4433
 available:10.5563
 update:10.3644
 select:10.3492
 (":10.2109	prefix accepted: (
(:10.1779
 ":9.81031
 em:9.72541	rejected
 Em:9.68263	rejected

:9.62698
 model:9.4477
 Selected:9.32965	rejected
,:9.27829	rejected
 "":11.6991
 _,:8.89997	rejected
 selection:8.66548	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selected

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selected
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <selected>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "selected"))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  selected
Nature of error: Variable selected is not bound  
Error in term:
  (updateGrid(grid, row, col, )), selected
Nature of error: Expecting type Model but got inconsistent type (Grid, ?)
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: selected
LSP: Generating Completions for prefix: selected
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Emoji"
root ::= completions

Top 20 Logits:
E:20.1246
Em:11.8734
emo:11.382	rejected
,:10.6901	rejected
_:10.1948	rejected
Cell:9.72196	rejected
 em:9.625	rejected
EM:9.46584	rejected
 E:9.23454	rejected
em:8.90234	rejected
Grid:8.74516	rejected
Empty:8.54422	rejected
G:8.4806	rejected
Row:8.2618	rejected
C:7.98512	rejected
Image:7.92798	rejected

:7.92142	rejected
e:7.88353	rejected
 Em:7.69378	rejected
Model:7.5508	rejected
X:7.48686	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedE

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedE
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <selectedE>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "selectedE"))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  selectedE
Nature of error: Variable selectedE is not bound  
Error in term:
  (updateGrid(grid, row, col, )), selectedE
Nature of error: Expecting type Model but got inconsistent type (Grid, ?)
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: selectedE
LSP: Generating Completions for prefix: selectedE
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "moji"
root ::= completions

Top 20 Logits:
mo:26.5224
emo:16.3942	rejected
omo:14.6903	rejected
MO:14.4616	rejected
imo:14.0126	rejected
мо:13.1704	rejected
 mo:13.1031	rejected
Mo:12.9251	rejected
m:12.733
mu:12.6336	rejected
no:12.2697	rejected
mm:12.1429	rejected
mi:11.4586	rejected
mor:11.4209	rejected
my:11.3339	rejected
jo:11.2454	rejected
ma:11.0945	rejected
moz:10.9868	rejected
model:10.8648	rejected
amo:10.8535	rejected
po:10.8197	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmo

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmo
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <selectedEmo>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "selectedEmo"))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  selectedEmo
Nature of error: Variable selectedEmo is not bound  
Error in term:
  (updateGrid(grid, row, col, )), selectedEmo
Nature of error: Expecting type Model but got inconsistent type (Grid, ?)
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: selectedEmo
LSP: Generating Completions for prefix: selectedEmo
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ji"
root ::= completions

Top 20 Logits:
ji:24.2995
iji:13.9648	rejected
 ji:13.8519	rejected
ij:12.7118	rejected
jo:12.6643	rejected
yi:12.1634	rejected
jih:12.0545	rejected
j:11.5964
i:11.2563	rejected
je:10.4125	rejected
,:10.389	rejected
 Ji:10.2048	rejected
J:9.66772	rejected
ii:9.59395	rejected
ei:9.1249	rejected
ja:9.06668	rejected
jin:8.76233	rejected

:8.69457	rejected
e:8.53902	rejected
qi:8.42495	rejected
xi:8.26207	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <selectedEmoji>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: String
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  (updateGrid(grid, row, col, )), selectedEmoji
Nature of error: Expecting type Model but got inconsistent type (Grid, Emoji)
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: selectedEmoji
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Generating Completions for prefix: selectedEmoji
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
,:20.2887

:14.6858
 ,:14.18
),:13.8542	rejected
 :12.9476
):11.6931	rejected
 available:11.4753	rejected
  :11.2961
 +:10.9636
::10.885
",:10.5736	rejected
,,:10.5711	prefix accepted:,
.:10.4791	rejected
    :10.4507
   :10.4283
 ::10.1016
 =:9.95065
                :9.64088
 *:9.61995
',:9.55759	rejected
 (*:9.4826	prefix accepted: (

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Emoji]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "col" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "row" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 available:19.0029
available:14.215
 :13.1371

:11.7653
 av:11.5208
 avail:11.4642
 grid:10.2348
 selected:10.2326
 a:10.0971
 em:10.0871	rejected
  :10.0662
 [:9.9543
 Em:9.76417	rejected
 (:9.75272
 []:9.71991
 Av:9.48786	rejected
    :9.22537
 ":9.02452
   :8.89028
 [":8.85862	prefix accepted: [
 List:8.83137	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, available

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, available
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <available>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Emoji]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "available"))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  available
Nature of error: Variable available is not bound
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: available
LSP: Generating Completions for prefix: available
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Emojis"
root ::= completions

Top 20 Logits:
Em:21.249
E:12.0599
em:10.8572	rejected
 Em:10.8474	rejected
_:10.7215	rejected
EM:10.2016	rejected
 em:9.91232	rejected

:9.83534	rejected
Emp:9.73835	rejected
M:9.31628	rejected
Om:9.27229	rejected
Im:9.07551	rejected
 :8.9948	rejected
):8.97512	rejected
Er:8.89446	rejected
G:8.60591	rejected
.:8.59287	rejected
Sm:8.55689	rejected
Empty:8.51334	rejected
A:8.34285	rejected
S:8.28792	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEm

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEm
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <availableEm>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Emoji]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "availableEm"))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  availableEm
Nature of error: Variable availableEm is not bound
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: availableEm
LSP: Generating Completions for prefix: availableEm
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ojis"
root ::= completions

Top 20 Logits:
oj:26.6427
jos:15.9263	rejected
jo:14.8851	rejected
ijo:12.4427	rejected
j:11.6854	rejected
ij:11.6674	rejected

:10.9998	rejected
ois:10.8525	rejected
o:10.2255
ot:9.57817	rejected
 jo:9.43776	rejected
uj:9.40727	rejected
otos:9.30852	rejected
os:9.30199	rejected
 :9.22665	rejected
jp:8.97416	rejected
Jo:8.53718	rejected
oz:8.28263	rejected
 o:8.27438	rejected
aj:8.21841	rejected
jas:8.10542	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmoj

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmoj
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <availableEmoj>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Emoji]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "availableEmoj"))
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  availableEmoj
Nature of error: Variable availableEmoj is not bound
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: availableEmoj
LSP: Generating Completions for prefix: availableEmoj
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "is"
root ::= completions

Top 20 Logits:
is:26.5622
Is:14.3781	rejected
ies:13.7079	rejected
 is:12.4908	rejected
ims:11.6085	rejected
ис:11.4279	rejected
isi:11.4061	rejected
ises:11.2573	rejected
ins:11.2536	rejected
isu:11.1042	rejected
lis:11.0092	rejected
i:10.9739

:10.7766	rejected
ij:10.7282	rejected
irs:10.4669	rejected
ips:10.4276	rejected
ios:10.2527	rejected
ii:10.0598	rejected
isan:9.88601	rejected
isp:9.68623	rejected
ius:9.6535	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <availableEmojis>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Emoji]
  LSP: Info: Seft type: [String]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: availableEmojis
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Generating Completions for prefix: availableEmojis
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: col row action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
):19.28	rejected

:17.2993
),:15.2934	rejected
 :14.6971
 ):14.3804	rejected
)):13.6235	rejected
  :13.6186
    :13.0946
      :12.6185
);:12.3331	rejected
   :12.2662
,:12.1165
        :11.909
}:11.8685	rejected
                :11.5701
     :11.5073
))):11.1643	rejected
 #:11.0903	rejected
).:10.9591	rejected
)]:10.8402	rejected
]:10.84	rejected
Rejected the highest logit candidate ) with logit -inf

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis


LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <availableEmojis>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Emoji]
  LSP: Info: Seft type: [String]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
   :19.3934
    :15.3571
     :14.6331
      :14.4924
        :13.948
       :13.65
  :13.5737

:13.282
 :12.9414
         :12.3939
          :11.7464
                :11.5051
	:11.4736	rejected
           :11.4212
            :10.9687
#:10.7346	rejected
|:10.2006
):9.97578	rejected
             :9.97184
               :9.9231
              :9.81844

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
   

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
   
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <availableEmojis>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Emoji]
  LSP: Info: Seft type: [String]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {col: Col, row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:21.4954
 #:14.3837	rejected
 ):13.6902	rejected
 end:13.0155
 Clear:12.8556	rejected
 case:12.3902	rejected
 }:12.2331	rejected
 (*:12.1977	prefix accepted: (
 //:11.9244	prefix accepted: /

:11.8426
 clear:11.5915	rejected
 ():11.5552	prefix accepted: (
 in:11.4307	rejected
 ,:11.2586
 (:12.1977
 ]:10.6045	rejected
 /:11.9244
 if:10.4575	rejected
 ||:10.2176	prefix accepted: |
 .:10.0872	rejected
	:10.0262	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    |

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    |
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 Clear:19.2662
 F:16.6383
 _:12.7832
Clear:12.5189
 :12.1317
 St:11.7572
 Cle:10.4051
 clear:10.389
 Select:10.2463
 (:9.354
 Fil:9.31907
 #:9.18632	rejected
 Update:9.15437	rejected
 Res:8.97344	rejected
 Set:8.96929	rejected
  :8.88483
 Remove:8.65687	rejected
 Em:8.62309	rejected
 Create:8.55443	rejected
 Full:8.37465	rejected
	:8.26868	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | F

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | F
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <F>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "F"))))
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  F
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: F
LSP: Generating Completions for prefix: F
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "illRow"
root ::= completions

Top 20 Logits:
ill:23.1849
ills:11.7647	rejected
i:11.698
it:11.5438	rejected
lip:11.4865	rejected
ille:10.974	rejected
ll:10.4609	rejected
iller:10.22	rejected
illing:10.1028	rejected
etch:9.87682	rejected
Fill:9.70172	rejected
unc:9.56062	rejected
Ill:9.53705	rejected
irm:9.49756	rejected
old:9.34646	rejected
ocus:9.3152	rejected
loor:9.27443	rejected
fill:9.23706	rejected
resh:9.22427	rejected
illi:8.97917	rejected
ell:8.93742	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | Fill

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | Fill
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Fill>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "Fill"))))
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  Fill
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Fill
LSP: Generating Completions for prefix: Fill
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Row"
root ::= completions

Top 20 Logits:
Row:22.9069
Grid:12.9585	rejected
row:12.7486	rejected
Cell:12.5818	rejected
Rows:12.3673	rejected
E:11.5808	rejected
 Row:10.749	rejected
R:10.7254
All:10.6906	rejected
(:10.6692	rejected
Empty:10.5077	rejected
_:10.4181	rejected
With:10.2069	rejected
Ro:10.1421
Col:10.0213	rejected
ROW:9.74498	rejected
r:9.69257	rejected
Column:9.58939	rejected
Selected:9.51062	rejected
Cells:9.48307	rejected
Em:9.22336	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <FillRow>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (Int -> (SelectEmoji(String) + StampEmoji((Int, Int)) + ClearCell((Int, Int)) + ClearGrid + FillRow(Int)))
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Var "Action");
           syn = (Arrow ((Var "Row"), (Var "Action")))})))
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  FillRow
Nature of error: Expecting type Action but got inconsistent type (Row -> Action)
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: FillRow
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: FillRow
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
(:19.7368
 row:13.995	rejected
 (:13.7176
(_:13.4533	rejected
 r:12.4715	rejected
((:11.2277	prefix accepted:(
():10.7248	prefix accepted:(
({:10.6196	prefix accepted:(
 fill:10.4435	rejected
 em:10.4273	rejected
 ->:10.0473	rejected
 :10.0345
::9.97858	rejected
 col:9.82806	rejected
 =:9.76654
 _:9.71946	rejected
 i:9.60255	rejected
 =>:9.59204
([:9.47358	prefix accepted:(
  :9.25727
 cell:9.19607	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (SelectEmoji(String) + StampEmoji((Int, Int)) + ClearCell((Int, Int)) + ClearGrid + FillRow(Int))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (SelectEmoji(String) + StampEmoji((Int, Int)) + ClearCell((Int, Int)) + ClearGrid + FillRow(Int))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Row
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Row
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "()" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= completions | new-tokens

Top 20 Logits:
row:18.6712
r:15.9774
i:14.5498
selected:13.9163
n:13.8646
idx:13.8135
index:13.2543
fill:12.9703
target:12.6863
col:12.3687
filled:12.3228
y:12.2131
x:11.9955
to:11.7816
num:11.6082
line:11.4809
which:11.1745
the:11.0504
rows:10.9707
a:10.9334
f:10.8839

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(row

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(row
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <row>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Row
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {row: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Row
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: row
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: row
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
To:18.7417
):18.5326
Index:14.6977
Number:14.0224
Num:13.957
Id:13.766
No:12.743
Fil:12.4485
to:11.8987
Selected:11.8942
)=:11.8587	prefix accepted:)
Of:11.8443
)->:11.7417	prefix accepted:)
I:11.6508
_:11.6291
N:11.541
T:11.3883
,:11.256
),:11.2558
ID:11.1994
Fill:11.0914

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowTo

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowTo
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <rowTo>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Row
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {rowTo: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Row
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: rowTo
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: rowTo
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
Fill:23.267
Clear:18.0448
St:16.4841
Be:15.9622
Fil:15.0767
F:14.1904
Update:13.7618
fill:13.3566
Select:13.3198
FI:13.117
Change:13.0084
Paint:12.9987
Replace:12.9342
Empty:12.8447
):12.6802
Set:12.6688
Add:12.6128
Use:12.2294
Full:12.1873
Re:12.1748
C:12.0997

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <rowToFill>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Row
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Row
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: rowToFill
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: rowToFill
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
):19.8966
)->:14.8922	prefix accepted:)
In:14.8442
)=:14.7703	prefix accepted:)
With:14.4525
 ):13.7953
,:13.4944
),:12.8803
 =>:11.9272	rejected
::11.3456	rejected
Index:11.2918
)::11.1711	prefix accepted:)
And:11.0805
Em:11.0411
_):10.7784	prefix accepted:_
 ->:10.7432	rejected
with:10.1937
Id:10.1585
E:10.0457
)>:9.97675	prefix accepted:)
_:10.7784

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill)

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (SelectEmoji(String) + StampEmoji((Int, Int)) + ClearCell((Int, Int)) + ClearGrid + FillRow(Int))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:19.7817
 ->:15.3195	rejected
 :15.1074
  :13.5168
    :12.7858

:12.769
   :12.4142
      :11.583
     :10.8596
 =:10.8277
        :10.6918
                :10.4173
         :10.3493
=>:10.2812
          :10.1949
 :=:10.1752	rejected
 when:10.129	rejected
       :9.85692
 ==:9.8376	prefix accepted: =
 ==>:9.69791	prefix accepted: =
 >:9.69635	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "rowToFill" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 :19.0115

:18.3133
  :17.5863
 (:16.8858
    :15.7833
   :15.2123
 fill:14.7309
      :14.5369
                :14.4988
     :13.6713
        :13.5409
         :13.3348
            :13.0485
 update:12.8427
       :12.6925
          :12.6324
             :12.6039
 clear:12.4892
(:12.4233
           :12.3776
              :12.3642

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>


LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "rowToFill" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
     :21.426
      :19.8649
       :18.5178
    :17.9915
         :17.137
        :16.9977
   :15.5193
           :15.148
          :14.7724
	:14.1701	rejected
                :14.0709
            :13.8857
             :13.6391
               :13.2245
 :12.9531
              :12.834
  :12.8033
#:12.7954	rejected

:12.6205
(:11.5547
 (:10.3301

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
     

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
     
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "rowToFill" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 (:21.9367
 fill:19.3304
 let:19.0132
 ((:16.2805	prefix accepted: (
 if:15.8968
 clear:15.8263
 #:15.6124	rejected
 update:15.4283
 List:15.1409	rejected
 [:13.8146
 ([:13.6281	prefix accepted: (
 (*:13.5619	prefix accepted: (
 print:13.3656	rejected
 grid:13.1828
 case:12.9183
 #(:12.9025	rejected
 [(:12.889	prefix accepted: [
 assert:12.7477	rejected
 return:12.7326	rejected
 {:12.4814	rejected
 ,:12.3677	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "rowToFill" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
fill:21.1352
 fill:15.8501

:14.2366
clear:13.3129
update:13.0837
grid:12.5584
List:12.5414	rejected
 :11.5443
if:10.7196
Fill:10.5881
 update:10.4434
fil:10.4166
  :10.2937
filter:9.89955	rejected
let:9.89923
 grid:9.87909
f:9.7769
 (:9.67231
 clear:9.65282
 List:9.64274	rejected
filled:9.47989	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fill

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fill
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <fill>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "fill"))
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fill
Nature of error: Variable fill is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: fill
LSP: Generating Completions for prefix: fill
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "RowInGrid"
root ::= completions

Top 20 Logits:
Row:21.6732
Rows:14.2947	rejected
row:13.7108	rejected
_:13.1792	rejected
Ro:13.1144
l:12.8256	rejected
R:12.5804
Grid:12.5003	rejected
In:11.7146	rejected
(:11.1661	rejected
r:11.133	rejected
RO:11.1188	rejected
E:10.5953	rejected
Rule:10.5797	rejected
ing:10.5153	rejected
ROW:10.481	rejected
ow:10.4138	rejected
t:10.4054	rejected
With:10.3862	rejected
s:10.1068	rejected
 Row:10.0331	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRow

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRow
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <fillRow>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "fillRow"))
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fillRow
Nature of error: Variable fillRow is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: fillRow
LSP: Generating Completions for prefix: fillRow
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "InGrid"
root ::= completions

Top 20 Logits:
In:23.6991
in:15.1902	rejected
(:14.8157	rejected
Grid:11.9422	rejected
IN:11.6659	rejected
Int:11.3624	rejected
With:11.225	rejected
Empty:11.131	rejected
Of:10.999	rejected
From:10.7469	rejected
I:10.7423
Ind:10.4495	rejected
::10.369	rejected
To:10.0049	rejected
Row:9.96306	rejected
On:9.95795	rejected
n:9.91982	rejected
_:9.88054	rejected
For:9.85081	rejected
ing:9.74212	rejected
Index:9.7275	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowIn

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowIn
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <fillRowIn>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "fillRowIn"))
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fillRowIn
Nature of error: Variable fillRowIn is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: fillRowIn
LSP: Generating Completions for prefix: fillRowIn
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Grid"
root ::= completions

Top 20 Logits:
Grid:21.7774
G:14.8078
grid:13.8421	rejected
GR:13.3525	rejected
Gr:13.1077
Group:12.9439	rejected
Row:12.8701	rejected
Graph:12.5792	rejected
Grad:12.2098	rejected
g:11.966	rejected
GridView:11.9331	rejected
GB:11.581	rejected
List:11.1703	rejected
(:10.9656	rejected
 Grid:10.4481	rejected
GL:10.3279	rejected
F:10.1543	rejected
Column:10.0127	rejected
Model:9.98489	rejected
R:9.96904	rejected
Green:9.78826	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <fillRowInGrid>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (([[String]], Int, String) -> [[String]])
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model");
           syn =
           (Arrow ((Prod [(Var "Grid"); (Var "Row"); (Var "Emoji")]),
              (Var "Grid")))})))
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fillRowInGrid
Nature of error: Expecting type Model but got inconsistent type ((Grid, Row, Emoji) -> Grid)
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: fillRowInGrid
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: fillRowInGrid
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
(:20.7701
 grid:14.5969	rejected
 (:14.327
((:13.9975	prefix accepted:(

:13.9545
,:12.2921
 :11.8109
)(:11.6651	prefix accepted:)
(),:11.6218	prefix accepted:(
::11.5113
():11.4368	prefix accepted:(
):11.6651
()):10.9771	prefix accepted:(
  :10.7843
(":10.7334	prefix accepted:(
(*:10.6128	prefix accepted:(
(!:10.6031	prefix accepted:(
([:10.5203	prefix accepted:(
    :10.0036
[:9.98637	rejected
),:9.91435	prefix accepted:)

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [[String]]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = (Var "Model"); syn = (Var "Grid")})))
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  fillRowInGrid(?)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [[String]]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = (Var "Model"); syn = (Var "Grid")})))
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  fillRowInGrid(?)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Grid, Row, Emoji)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  fillRowInGrid(?)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "rowToFill" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
grid:19.9977

:14.7128
 grid:14.342
clear:13.6629
model:13.422
row:13.1794
update:12.5012
selected:12.4328
g:12.1421
fill:11.3125
 :11.2891
available:10.688
Grid:10.5672	rejected
,:10.4622	rejected
list:10.4148	rejected
gr:10.3748
  :10.3007
_,:10.2753	rejected
0:10.2525
List:10.2197	rejected
x:10.1979	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <grid>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Grid, Row, Emoji)
  LSP: Info: Seft type: [[String]]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana = (Prod [(Var "Grid"); (Var "Row"); (Var "Emoji")]);
           syn = (Var "Grid")})))
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  grid
Nature of error: Expecting type (Grid, Row, Emoji) but got inconsistent type Grid  
Error in term:
  fillRowInGrid(grid)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: grid
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: grid
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:20.2039
),:13.0947	prefix accepted:)
 ,:12.8743
 row:12.743	rejected

:12.4879
::11.8478
):13.0947
)):10.9469
 :10.7629
.:10.6853	rejected
,,:10.5342	prefix accepted:,
)),:10.5219	prefix accepted:))
)(:10.1171	prefix accepted:)
 ::9.88306
(),:9.38808	prefix accepted:(
  :9.3656
 =:8.99565
To:8.93697	rejected
',:8.90476	rejected
,(:8.90057	prefix accepted:,
row:8.90055	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Grid, Row, Emoji)
  LSP: Info: Seft type: ([[String]], ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana = (Prod [(Var "Grid"); (Var "Row"); (Var "Emoji")]);
           syn = (Prod [(Var "Grid"); (Unknown Internal)])})))
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  grid, ?
Nature of error: Expecting type (Grid, Row, Emoji) but got inconsistent type (Grid, ?)  
Error in term:
  fillRowInGrid(grid, ?)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Grid, Row, Emoji)
  LSP: Info: Seft type: ([[String]], ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana = (Prod [(Var "Grid"); (Var "Row"); (Var "Emoji")]);
           syn = (Prod [(Var "Grid"); (Unknown Internal)])})))
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  grid, ?
Nature of error: Expecting type (Grid, Row, Emoji) but got inconsistent type (Grid, ?)  
Error in term:
  fillRowInGrid(grid, ?)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  grid, ?
Nature of error: Expecting type (Grid, Row, Emoji) but got inconsistent type (Grid, ?)  
Error in term:
  fillRowInGrid(grid, ?)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "rowToFill" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 row:18.6058
row:13.2083
 :12.4425
 selected:11.6119
 Row:11.1016	rejected
 ro:10.7991

:10.501
 (:10.3996
 em:10.3275	rejected
 available:10.0834
 i:10.0547
 col:9.70528	rejected
 r:9.55665
 ,:9.53267	rejected
 fill:9.52822
 grid:9.47621
  :9.28352
 action:9.11582
 Em:9.0887	rejected
 ):9.05804	rejected
 to:8.83969	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, row

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, row
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <row>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "row"))
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  row
Nature of error: Variable row is not bound  
Error in term:
  grid, row
Nature of error: Expecting type (Grid, Row, Emoji) but got inconsistent type (Grid, ?)  
Error in term:
  fillRowInGrid(grid, row)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: row
LSP: Generating Completions for prefix: row
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ToFill"
root ::= completions

Top 20 Logits:
To:20.6943
,:14.8643	rejected
T:14.1059
to:13.628	rejected
),:12.1908	rejected
_:11.4843	rejected
):11.1366	rejected
t:10.9627	rejected
TO:10.9401	rejected
Index:10.8433	rejected
 to:10.7916	rejected
Top:10.5592	rejected
 +:10.559	rejected
 -:10.4357	rejected
-:10.3231	rejected
)):10.1711	rejected
Of:9.70083	rejected
Col:9.54943	rejected
::9.46519	rejected
 To:9.4419	rejected
+:9.40139	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowTo

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowTo
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <rowTo>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "rowTo"))
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  grid, rowTo
Nature of error: Expecting type (Grid, Row, Emoji) but got inconsistent type (Grid, ?)  
Error in term:
  rowTo
Nature of error: Variable rowTo is not bound  
Error in term:
  fillRowInGrid(grid, rowTo)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: rowTo
LSP: Generating Completions for prefix: rowTo
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Fill"
root ::= completions

Top 20 Logits:
Fill:21.1714
Fi:12.7763
Find:12.6189	rejected
F:12.5507
Filter:12.2546	rejected
Full:12.2261	rejected
fill:12.0673	rejected
Fil:11.6083
Equal:11.5405	rejected
Fail:11.0369	rejected
Fl:11.0154	rejected
Paint:10.8644	rejected
 fill:10.8444	rejected
Fetch:10.7769	rejected
Clear:10.6169	rejected
Draw:10.5391	rejected
St:10.4396	rejected
Field:10.1326	rejected
Write:9.99088	rejected
Copy:9.95947	rejected
Flow:9.88544	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <rowToFill>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  grid, rowToFill
Nature of error: Expecting type (Grid, Row, Emoji) but got inconsistent type (Grid, Row)  
Error in term:
  fillRowInGrid(grid, rowToFill)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: rowToFill
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: rowToFill
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:19.1741
),:15.141	prefix accepted:)
):15.141
)):13.1931
 -:12.712
)),:12.5627	prefix accepted:))
 ,:12.1914
 +:10.7453
 selected:10.6534	rejected

:10.5118
::10.1881
-:10.052
))):9.92413	prefix accepted:))
 :9.85638
,,:9.61364	prefix accepted:,
.:9.55656	rejected
)(:9.28231	prefix accepted:)
)::8.8211	prefix accepted:)
 ::8.72168
);:8.41813	prefix accepted:)
+:8.40418

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Grid, Row, Emoji)
  LSP: Info: Seft type: ([[String]], Int, String)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  fillRowInGrid(grid, rowToFill, ?)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Grid, Row, Emoji)
  LSP: Info: Seft type: ([[String]], Int, String)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  fillRowInGrid(grid, rowToFill, ?)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Emoji
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  fillRowInGrid(grid, rowToFill, ?)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "rowToFill" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 selected:17.7397
selected:13.1348
 :12.6497
 ":12.1126

:11.7362
 "":11.4364
 ""):11.3465	prefix accepted: ""
 em:11.2092	rejected
 select:10.3322
 grid:10.3252
 available:10.2745
 s:10.1794
 Em:9.7742	rejected
 "",:9.53846	prefix accepted: ""
  :9.49317
 Selected:9.41315	rejected
 model:9.141
 sele:9.08966
 sel:9.08443
 current:8.93513	rejected
 se:8.64915

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selected

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selected
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <selected>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Emoji
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "selected"))
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  selected
Nature of error: Variable selected is not bound  
Error in term:
  fillRowInGrid(grid, rowToFill, selected)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: selected
LSP: Generating Completions for prefix: selected
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Emoji"
root ::= completions

Top 20 Logits:
E:20.763
Em:13.1933
emo:10.9606	rejected
_:10.9225	rejected
),:10.7736	rejected
)):10.6265	rejected
 E:10.2802	rejected
EM:9.88519	rejected
Empty:9.78155	rejected
):9.75279	rejected
 em:9.75193	rejected
Grid:9.56493	rejected
em:9.49793	rejected
G:9.11456	rejected
Cell:9.07185	rejected
Element:8.81754	rejected
.:8.7614	rejected
 Em:8.75341	rejected
Model:8.686	rejected
e:8.67362	rejected
)),:8.418	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedE

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedE
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <selectedE>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Emoji
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "selectedE"))
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  fillRowInGrid(grid, rowToFill, selectedE)
Nature of error: Expecting type Model but got inconsistent type Grid  
Error in term:
  selectedE
Nature of error: Variable selectedE is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: selectedE
LSP: Generating Completions for prefix: selectedE
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "moji"
root ::= completions

Top 20 Logits:
mo:27.2219
omo:18.5565	rejected
imo:15.6452	rejected
emo:15.5697	rejected
mm:14.4855	rejected
MO:13.7602	rejected
o:13.5811	rejected
no:13.4598	rejected
мо:13.1655	rejected
jo:12.8944	rejected
mu:12.6996	rejected
 mo:12.6848	rejected
mi:12.4668	rejected
oo:12.2476	rejected
mor:11.9627	rejected
my:11.875	rejected
ermo:11.4347	rejected
amo:11.4115	rejected
m:11.2677
po:11.2654	rejected
Mo:10.8971	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmo

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmo
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <selectedEmo>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Emoji
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "selectedEmo"))
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  selectedEmo
Nature of error: Variable selectedEmo is not bound  
Error in term:
  fillRowInGrid(grid, rowToFill, selectedEmo)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: selectedEmo
LSP: Generating Completions for prefix: selectedEmo
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ji"
root ::= completions

Top 20 Logits:
ji:27.862
iji:15.6131	rejected
jo:15.4389	rejected
 ji:15.0981	rejected
j:13.1298
jih:12.8578	rejected
J:12.5518	rejected
ja:12.2295	rejected
yi:12.0894	rejected
xi:11.807	rejected
 Ji:11.7484	rejected
jin:11.3522	rejected
jp:10.7228	rejected
qi:10.5998	rejected
zi:10.1976	rejected
ju:10.1093	rejected
je:10.0306	rejected
ui:9.9264	rejected
json:9.91983	rejected
oli:9.83153	rejected
ij:9.55663	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <selectedEmoji>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Emoji
  LSP: Info: Seft type: String
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  fillRowInGrid(grid, rowToFill, selectedEmoji)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Grid, Row, Emoji)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: selectedEmoji
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: selectedEmoji
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
),:18.6835	prefix accepted:)
)):17.1623
):18.6835
)),:15.5706	prefix accepted:))
))):12.8131	prefix accepted:))
,:11.3646
));:10.9603	prefix accepted:))
 ):10.6234
)))):10.322	prefix accepted:))
 ),:10.1911	prefix accepted: )
 :10.1646
)));:10.1637	prefix accepted:))

:9.69177
)).:9.51632	prefix accepted:)
);:9.46427	prefix accepted:)
)]:9.40166	prefix accepted:)
))::9.37859	prefix accepted:))
))]:9.25987	prefix accepted:))
),(:9.02827	prefix accepted:)
)(:8.41588	prefix accepted:)
)){:8.39064	prefix accepted:))
Rejected the highest logit candidate ), with logit -inf

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [[String]]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = (Var "Model"); syn = (Var "Grid")})))
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fillRowInGrid(grid, rowToFill, selectedEmoji)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:

:19.9492
 :18.1347
  :15.9005
    :15.0185
 ,:14.5639
 ):14.5148
      :14.3372
   :14.1035
                :13.6354
        :13.1863
     :12.893
         :12.4641
          :12.4148
       :12.3508
 #:12.211	rejected
            :12.0749
           :11.957
              :11.6255
             :11.5336
 \:11.4938
 ),:11.4838	prefix accepted: )

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)


LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [[String]]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = (Var "Model"); syn = (Var "Grid")})))
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fillRowInGrid(grid, rowToFill, selectedEmoji)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
       :22.1882
      :20.6461
         :20.4709
        :19.9104
     :19.0534
           :17.6546
          :17.3542
    :16.4622
                :16.2306
   :16.0014
             :15.8613
               :15.606
            :15.321
	:14.7149	rejected
              :14.6591
  :14.0951
 :13.6583
,:12.3596

:12.2559
 ,:10.0007
#:9.96602	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
       

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
       
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [[String]]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = (Var "Model"); syn = (Var "Grid")})))
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fillRowInGrid(grid, rowToFill, selectedEmoji)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
 ,:21.0692
 grid:16.1219	rejected
 ):14.2023
 ),:14.1509	prefix accepted: )
 (:13.1054
 update:12.8931	rejected
 ::12.799
 #:12.596	rejected
 selected:12.371	rejected
 _,:11.8814	rejected
 .:11.6661	rejected
 },:11.6469	rejected
 row:11.4191	rejected
 (*:10.9201	prefix accepted: (
 updated:10.7847	rejected
 ?:10.6874	rejected
 ;:10.6023	rejected
 [:10.5673	rejected
 select:10.5659	rejected
 model:10.3867	rejected
 *:10.3786

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        ,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        ,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model");
           syn = (Prod [(Var "Grid"); (Unknown Internal)])})))
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fillRowInGrid(grid, rowToFill, selectedEmoji), ?
Nature of error: Expecting type Model but got inconsistent type (Grid, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model");
           syn = (Prod [(Var "Grid"); (Unknown Internal)])})))
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fillRowInGrid(grid, rowToFill, selectedEmoji), ?
Nature of error: Expecting type Model but got inconsistent type (Grid, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fillRowInGrid(grid, rowToFill, selectedEmoji), ?
Nature of error: Expecting type Model but got inconsistent type (Grid, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "rowToFill" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 selected:18.6636
selected:15.9637
 :12.8947
 grid:11.7863
 select:11.5568
 "",:10.9923	prefix accepted: ""
 em:10.9773	rejected
 s:10.0906
 ":9.89196
 sel:9.7363
 available:9.73127
 row:9.70465
 sele:9.65061
 Selected:9.56513	rejected
 (:9.40508
 fill:9.38713
 se:9.20481
 selection:9.09089	rejected

:8.98874
  :8.90886
 model:8.81421

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selected

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selected
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <selected>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "selected"))
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fillRowInGrid(grid, rowToFill, selectedEmoji), selected
Nature of error: Expecting type Model but got inconsistent type (Grid, ?)  
Error in term:
  selected
Nature of error: Variable selected is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: selected
LSP: Generating Completions for prefix: selected
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Emoji"
root ::= completions

Top 20 Logits:
E:21.3677
Em:13.1934
emo:11.7759	rejected
,:10.2456	rejected
EM:9.70765	rejected
 E:9.69243	rejected
_:9.63963	rejected
em:9.43002	rejected
Cell:9.3103	rejected
Empty:9.248	rejected
 em:9.10954	rejected
G:8.93996	rejected
e:8.61486	rejected
X:8.53727	rejected
O:8.47372	rejected
Grid:8.45451	rejected
 Em:8.29049	rejected
R:8.13112	rejected
.:8.02672	rejected
Emp:8.00188	rejected
Selected:7.99495	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedE

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedE
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <selectedE>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "selectedE"))
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fillRowInGrid(grid, rowToFill, selectedEmoji), selectedE
Nature of error: Expecting type Model but got inconsistent type (Grid, ?)  
Error in term:
  selectedE
Nature of error: Variable selectedE is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: selectedE
LSP: Generating Completions for prefix: selectedE
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "moji"
root ::= completions

Top 20 Logits:
mo:28.3776
omo:20.7369	rejected
emo:17.5398	rejected
imo:16.5613	rejected
amo:14.8685	rejected
 mo:14.232	rejected
o:13.7215	rejected
MO:13.6535	rejected
mu:13.6394	rejected
jo:13.3205	rejected
mm:13.1902	rejected
ermo:13.1834	rejected
oo:12.7485	rejected
no:12.6944	rejected
Mo:12.2616	rejected
ismo:12.114	rejected
мо:12.111	rejected
ino:11.7914	rejected
cho:11.3602	rejected
neo:11.2934	rejected
pio:11.1719	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmo

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmo
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <selectedEmo>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "selectedEmo"))
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fillRowInGrid(grid, rowToFill, selectedEmoji), selectedEmo
Nature of error: Expecting type Model but got inconsistent type (Grid, ?)  
Error in term:
  selectedEmo
Nature of error: Variable selectedEmo is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: selectedEmo
LSP: Generating Completions for prefix: selectedEmo
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ji"
root ::= completions

Top 20 Logits:
ji:29.003
iji:19.3887	rejected
 ji:16.1229	rejected
ij:16.0829	rejected
yi:15.3675	rejected
jih:13.8333	rejected
ja:13.8225	rejected
ii:13.1458	rejected
i:13.0821	rejected
j:12.8726
jo:12.8624	rejected
 Ji:12.844	rejected
ije:12.2515	rejected
ijo:12.2406	rejected
xi:11.7934	rejected
jin:11.7461	rejected
qi:11.6929	rejected
J:11.6279	rejected
ija:11.3163	rejected
je:11.1458	rejected
ei:11.0547	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <selectedEmoji>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: String
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fillRowInGrid(grid, rowToFill, selectedEmoji), selectedEmoji
Nature of error: Expecting type Model but got inconsistent type (Grid, Emoji)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: selectedEmoji
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: selectedEmoji
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:21.0214

:14.811
 ,:14.7566
),:13.5698	prefix accepted:)
 :12.7301
):13.5698
  :12.2013
.:10.9887	rejected
,,:10.979	prefix accepted:,
 +:10.906
 available:10.7776	rejected
    :10.1866
::10.0007
   :9.99996
                :9.83097
 *:9.68654
      :9.33346
 ::9.23093
 ):9.09799
        :9.00704
;:8.92536	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Emoji]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "rowToFill" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 available:19.5641
available:14.585
 :13.612
 av:12.1718
 avail:11.3418

:11.3013
 [:11.0944
  :11.0489
 grid:10.9994
 selected:10.5185
 a:10.5172
 []:9.49155
 List:9.42173	rejected
 Av:9.35833	rejected
 row:9.30661
 list:9.29364	rejected
 em:9.12805	rejected
 Em:8.82449	rejected
    :8.77009
 fill:8.65177
 ""):8.50901	prefix accepted: ""

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, available

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, available
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <available>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Emoji]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "available"))
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  available
Nature of error: Variable available is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: available
LSP: Generating Completions for prefix: available
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Emojis"
root ::= completions

Top 20 Logits:
Em:22.0788
E:12.0884
em:11.8286	rejected
 Em:11.0976	rejected
EM:10.9675	rejected
Emp:10.4659	rejected
):10.3589	rejected
_:10.2283	rejected
Im:10.1031	rejected
M:9.87146	rejected
Om:9.8597	rejected
Empty:9.74282	rejected
 em:9.35989	rejected
Er:9.24459	rejected

:9.22497	rejected
Sm:8.94495	rejected
G:8.87455	rejected
m:8.66503	rejected
.:8.55647	rejected
Tem:8.47134	rejected
S:8.37636	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEm

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEm
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <availableEm>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Emoji]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "availableEm"))
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  availableEm
Nature of error: Variable availableEm is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: availableEm
LSP: Generating Completions for prefix: availableEm
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ojis"
root ::= completions

Top 20 Logits:
oj:31.8752
jos:20.0742	rejected
jo:17.4408	rejected
oz:16.654	rejected
o:15.0319
j:14.3263	rejected
ij:14.3001	rejected
oy:14.0763	rejected
osh:13.9807	rejected
os:13.9305	rejected
ois:13.8652	rejected
oi:13.7978	rejected
uj:13.6814	rejected
ijo:13.15	rejected
ox:13.0727	rejected
obj:12.8813	rejected
jor:12.814	rejected
aj:12.3366	rejected
ot:12.0844	rejected
jon:11.9916	rejected
ji:11.9202	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmoj

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmoj
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <availableEmoj>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Emoji]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "availableEmoj"))
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  availableEmoj
Nature of error: Variable availableEmoj is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: availableEmoj
LSP: Generating Completions for prefix: availableEmoj
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "is"
root ::= completions

Top 20 Logits:
is:27.9505
ins:17.5775	rejected
ies:15.941	rejected
ios:15.41	rejected
iss:15.1779	rejected
Is:14.4349	rejected
ises:14.2847	rejected
ias:13.4229	rejected
isf:13.1978	rejected
isu:13.0778	rejected
isan:12.9096	rejected
ris:12.8525	rejected
ips:12.8499	rejected
IS:12.3914	rejected
ise:12.3418	rejected
ys:12.1845	rejected
lis:12.1612	rejected
irs:12.0953	rejected
isi:11.987	rejected
iv:11.8705	rejected
ish:11.8598	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <availableEmojis>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Emoji]
  LSP: Info: Seft type: [String]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: availableEmojis
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: availableEmojis
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: rowToFill action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
):21.8731

:18.5264
 ):18.0033
),:16.4009	prefix accepted:)
  :16.0542
 :15.2284
    :14.7368
      :14.2233
);:14.1287	prefix accepted:)
)):14.1026
        :13.9152
   :13.3358
,:13.2698
                :13.0093
     :12.7282
          :12.4265
)]:12.4257	prefix accepted:)
         :12.2031
       :12.1139
).:12.1117	rejected
            :12.0377

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:19.1859
  :16.5999
 :16.1216
    :15.3533
      :14.9147
        :14.7761
   :13.6741
                :12.9887
     :12.8035
       :12.6682
          :12.551
         :12.5117
 in:12.3644	rejected
            :12.0975
           :11.7128
 #:11.6945	rejected
              :11.6318
 end:11.577
             :11.0136
               :10.9514
	:10.9363	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)


LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
   :18.3746
  :14.6531
    :14.6007
        :14.0647
      :13.6924
     :13.466
end:13.162
 :13.1392

:13.0636
       :12.9768
         :11.9347
	:11.7703	rejected
#:11.5918	rejected
                :11.3015
|:11.2674
          :11.1985
           :10.9526
            :10.8855
 end:10.3979
(*:9.98349	prefix accepted:(
             :9.85845

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
   

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
   
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {rowToFill: Row, action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:20.4375
 end:15.815
 #:15.367	rejected
 Clear:15.1678	rejected
 in:13.6162	rejected
 (*:13.1631	prefix accepted: (
 clear:13.118	rejected
 //:12.5112	prefix accepted: /
 else:12.1501	rejected
 case:11.729	rejected
 _:11.5732	rejected
 }:11.2786	rejected
 ~:11.2256	rejected
 <:11.2121
 action:11.004	rejected
 +:10.9891

:10.9804
 @:10.7818
 /:12.5112
 *:10.7797
 {:10.7062	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    |

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    |
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 Clear:21.2325
 _:15.3316
Clear:13.9769
 :12.4119
 clear:11.9308
 Cle:10.4996
_:10.3155
  :10.1467
 F:9.87486
>:9.816	rejected
 Select:9.68577
 St:9.679
 #:9.52201	rejected
 Update:9.33429	rejected
 Action:9.17153	rejected
 ?:9.03131	rejected
 x:8.96808
 other:8.90916
 C:8.89492
 :8.81892	rejected
 @:8.81441	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | Clear

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | Clear
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Clear>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "Clear"))))
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  Clear
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Clear
LSP: Generating Completions for prefix: Clear
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Cell" | "Grid"
root ::= completions

Top 20 Logits:
Grid:20.535
Cell:13.4819
All:12.8201	rejected
G:12.5294
GR:12.044	rejected
grid:11.7426	rejected
Row:11.5349	rejected
 Grid:11.2184	rejected
Gr:11.1227
GridView:11.0486	rejected
E:10.9736	rejected
 grid:10.9431	rejected
_:10.662	rejected
Graph:10.576	rejected
():9.97429	rejected
Group:9.72484	rejected
Grad:9.53038	rejected
Screen:9.42807	rejected
(:9.28688	rejected
Column:9.26527	rejected
Graphics:9.26072	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <ClearGrid>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (SelectEmoji(String) + StampEmoji((Int, Int)) + ClearCell((Int, Int)) + ClearGrid + FillRow(Int))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: ClearGrid
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: ClearGrid
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:18.1139
 ->:13.895	rejected
():13.6977	prefix accepted:(
 :13.0944
=>:12.5379
  :11.9605
    :11.0985
        :10.925
      :10.8724

:10.7918
 ():10.6677	prefix accepted: (
(:13.6977
         :10.4592
   :10.3186
 as:10.2956	rejected
          :10.2614
 =:9.88268
     :9.77843
 _:9.74734	rejected
       :9.70797
                :9.56157

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid =>

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid =>
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 (:18.3745
 :17.4402

:17.2326
  :16.4834
 clear:16.201
 model:13.6829
 ((:13.6787	prefix accepted: (
    :13.502
 let:13.2303
                :13.2213
 ([:13.1372	prefix accepted: (
   :12.8531
 update:12.7669
      :12.7021
 grid:12.6917
(:12.5879
        :12.3791
            :12.231
         :12.0441
              :11.8286
     :11.8007

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
clear:20.4287

:15.2101
 clear:15.1257
grid:13.7407
empty:13.019	rejected
List:11.6973	rejected
 :11.6688
[]:11.2645
update:11.2435
Clear:11.1479
model:10.8371
  :10.8165
 grid:10.5352
#:10.4307	rejected
clean:10.3391	rejected
cle:10.0634
([:9.9855	prefix accepted:(
new:9.85552	rejected
default:9.77584	rejected
(),:9.75981	prefix accepted:()
fill:9.7181

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clear

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clear
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <clear>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "clear"))
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  clear
Nature of error: Variable clear is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: clear
LSP: Generating Completions for prefix: clear
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Grid"
root ::= completions

Top 20 Logits:
Grid:20.3595
G:14.2528
_:13.0752	rejected
grid:12.2888	rejected
Graph:12.0743	rejected
GR:11.9656	rejected
(),:11.8398	rejected
()):11.3753	rejected
(:11.3261	rejected
():11.1811	rejected
Gr:11.1277
Model:11.1181	rejected
Empty:10.9985	rejected
 grid:10.8536	rejected
GridView:10.7692	rejected
,:10.6375	rejected
Cell:10.636	rejected
Row:10.4259	rejected
):10.3373	rejected
 Grid:10.0749	rejected
Group:10.0491	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <clearGrid>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]] -> [[String]])
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model");
           syn = (Arrow ((Var "Grid"), (Var "Grid")))})))
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  clearGrid
Nature of error: Expecting type Model but got inconsistent type (Grid -> Grid)
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: clearGrid
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: clearGrid
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
(:18.8317
 grid:17.3251	rejected
(),:14.5283	prefix accepted:(
():12.9275	prefix accepted:(
()):12.9228	prefix accepted:(
,:12.9062
 (:12.0529
):11.8182
([:10.849	prefix accepted:(
((:10.6677	prefix accepted:(
 :10.3751
),:10.2846	prefix accepted:)
::10.2521
 model:10.1938	rejected
)(:10.0524	prefix accepted:)
(":9.97956	prefix accepted:(
[:9.91327	rejected

:9.64289
(!:9.32711	prefix accepted:(
(*:9.32252	prefix accepted:(
()),:9.10023	prefix accepted:(

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [[String]]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = (Var "Model"); syn = (Var "Grid")})))
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  clearGrid(?)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [[String]]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = (Var "Model"); syn = (Var "Grid")})))
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  clearGrid(?)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Grid
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  clearGrid(?)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Grid
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
grid:20.0913
model:14.738
 grid:13.3852
3:13.0929
update:12.7675
g:12.3876
List:12.1644	rejected
[]:11.6415
clear:11.6167

:11.4937
available:11.2815
0:11.2764
Model:11.0916	rejected
Grid:11.0786	rejected
1:11.052
empty:10.8293	rejected
selected:10.7895
size:10.7835	rejected
init:10.7087	rejected
x:10.3799	rejected
5:10.3184

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <grid>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Grid
  LSP: Info: Seft type: [[String]]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  clearGrid(grid)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Grid
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: grid
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: grid
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
),:20.1852	prefix accepted:)
)):17.1441
):20.1852
)),:14.2118	prefix accepted:))
,:13.3468
))):11.6893	prefix accepted:))
);:11.2383	prefix accepted:)
));:10.9508	prefix accepted:))

:10.6596
)::10.0073	prefix accepted:)
),(:9.99497	prefix accepted:)
)]:9.82788	prefix accepted:)
)).:9.70571	prefix accepted:)
)))):9.62155	prefix accepted:))
)(:9.51179	prefix accepted:)
 ),:9.4961	prefix accepted: )
 :9.23457
).:9.15709	rejected
)[:9.01376	prefix accepted:)
))::8.98637	prefix accepted:))
)));:8.93523	prefix accepted:))
Rejected the highest logit candidate ), with logit -inf

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [[String]]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = (Var "Model"); syn = (Var "Grid")})))
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  clearGrid(grid)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:

:17.7755
 :17.3235
  :15.0853
 ,:14.5807
    :13.5022
 #:12.6985	rejected
                :12.5556
   :12.5457
      :12.5337
        :11.8167
 ):11.739
     :11.5034
          :11.2148
         :11.1782
       :11.102
            :10.8178
 ::10.7199
             :10.5256
           :10.5155
 grid:10.4924	rejected
 //:10.377	prefix accepted: /

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)


LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [[String]]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = (Var "Model"); syn = (Var "Grid")})))
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  clearGrid(grid)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
       :18.7777
                :18.0498
     :17.415
      :16.6207
         :16.4574
        :15.5379
           :15.0908
               :14.4332
   :14.4229
    :14.2674
             :13.893
          :13.7609
 :13.375
            :13.0502
              :13.0289
	:12.512	rejected
  :12.3747
,:10.7788

:10.0926
#:9.58479	rejected
 ,:8.15409

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
       

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
       
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [[String]]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = (Var "Model"); syn = (Var "Grid")})))
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  clearGrid(grid)
Nature of error: Expecting type Model but got inconsistent type Grid
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
 ,:21.0675
 grid:14.7745	rejected
 #:14.4761	rejected
 ),:14.138	prefix accepted: )
 ):14.138
 (:13.8515
 ::13.4178
 _,:12.4174	rejected
 [:12.3662	rejected
 (*:12.3425	prefix accepted: (
 update:12.1649	rejected
 ",:12.0305	rejected
 },:11.8422	rejected
 ?:11.7113	rejected
 .:11.7022	rejected
 selected:11.4084	rejected
 clear:11.4065	rejected
 model:11.3913	rejected
 *:11.1192
 List:11.0744	rejected
 "",:11.0709	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        ,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        ,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model");
           syn = (Prod [(Var "Grid"); (Unknown Internal)])})))
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  clearGrid(grid), ?
Nature of error: Expecting type Model but got inconsistent type (Grid, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model");
           syn = (Prod [(Var "Grid"); (Unknown Internal)])})))
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  clearGrid(grid), ?
Nature of error: Expecting type Model but got inconsistent type (Grid, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  clearGrid(grid), ?
Nature of error: Expecting type Model but got inconsistent type (Grid, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 selected:17.4619
selected:14.9951
 "",:13.4938	prefix accepted: ""
 :13.1946
 ":13.1643
 "":13.4938
 ?:10.9372	rejected
 select:10.9275
 em:10.4029	rejected
 ""):9.89871	prefix accepted: ""
 Em:9.85107	rejected
 default:9.59609	rejected
 grid:9.55019
 s:9.44254
  :9.29513
 available:9.23532
 (:9.20755
 model:9.0936
 empty:9.08689	rejected
 Selected:8.9221	rejected
 clear:8.88887

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selected

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selected
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <selected>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "selected"))
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  clearGrid(grid), selected
Nature of error: Expecting type Model but got inconsistent type (Grid, ?)  
Error in term:
  selected
Nature of error: Variable selected is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: selected
LSP: Generating Completions for prefix: selected
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Emoji"
root ::= completions

Top 20 Logits:
E:20.7694
Em:11.8878
emo:11.7767	rejected
,:10.6281	rejected
_:10.3563	rejected
 em:9.7944	rejected
 E:9.47449	rejected
EM:9.47159	rejected
Empty:9.2662	rejected
em:9.09896	rejected
G:8.6569	rejected
e:8.59578	rejected
Grid:8.34527	rejected
.:8.3365	rejected
Cell:8.21314	rejected
Model:7.97092	rejected
 Em:7.8864	rejected
O:7.79525	rejected
Image:7.68658	rejected
Default:7.6817	rejected
Emp:7.65417	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedE

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedE
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <selectedE>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "selectedE"))
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  clearGrid(grid), selectedE
Nature of error: Expecting type Model but got inconsistent type (Grid, ?)  
Error in term:
  selectedE
Nature of error: Variable selectedE is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: selectedE
LSP: Generating Completions for prefix: selectedE
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "moji"
root ::= completions

Top 20 Logits:
mo:28.8069
emo:19.0031	rejected
omo:17.0205	rejected
imo:16.8387	rejected
lem:16.0504	rejected
MO:15.9568	rejected
мо:15.9187	rejected
mm:15.8923	rejected
mu:15.5478	rejected
amo:14.6551	rejected
mi:14.3178	rejected
o:14.3166	rejected
mit:14.197	rejected
 mo:14.1291	rejected
jo:13.8809	rejected
ma:13.6743	rejected
oo:13.4631	rejected
mor:13.0081	rejected
vo:12.9727	rejected
meno:12.8962	rejected
no:12.7899	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmo

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmo
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <selectedEmo>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "selectedEmo"))
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  clearGrid(grid), selectedEmo
Nature of error: Expecting type Model but got inconsistent type (Grid, ?)  
Error in term:
  selectedEmo
Nature of error: Variable selectedEmo is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: selectedEmo
LSP: Generating Completions for prefix: selectedEmo
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ji"
root ::= completions

Top 20 Logits:
ji:26.4825
 ji:14.9701	rejected
ja:14.1963	rejected
jo:12.9028	rejected
iji:12.8697	rejected
ju:12.6591	rejected
jih:12.3722	rejected
je:11.7589	rejected
 Ji:11.6218	rejected
yi:11.4769	rejected
ei:11.2689	rejected
jp:11.2664	rejected
js:11.0477	rejected
json:10.3204	rejected
xi:10.0469	rejected
hui:9.95721	rejected
jin:9.82478	rejected
J:9.71352	rejected
jed:9.56869	rejected
ject:9.47308	rejected
,:9.40369	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <selectedEmoji>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: String
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  clearGrid(grid), selectedEmoji
Nature of error: Expecting type Model but got inconsistent type (Grid, Emoji)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: selectedEmoji
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: selectedEmoji
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:20.7034

:14.6127
 ,:14.6025
 :13.6267
),:12.661	prefix accepted:)
  :11.8209
):12.661
 +:11.4158
 available:11.1579	rejected
::10.8449
.:10.637	rejected
,,:10.5443	prefix accepted:,
 =:10.4105
 ::10.1045
    :10.0414
                :9.89789
 (*:9.83485	prefix accepted: (
   :9.79777
 #:9.3561	rejected
      :9.27629
 *:9.2678

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Emoji]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "availableEmojis" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "grid" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "selectedEmoji" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 available:19.397
 :14.7667
available:14.7181
 av:11.8497
 [:11.7937

:11.4854
  :10.881
 avail:10.7375
 a:10.0742
 []:9.96105
 grid:9.84154
 em:9.77064	rejected
 [":9.55648	prefix accepted: [
 selected:9.54455
 List:9.46692	rejected
 Av:9.4111	rejected
 Em:9.21267	rejected
 [],:9.14864	prefix accepted: []
 list:9.04356	rejected
 ""):8.98669	prefix accepted: ""
    :8.93372

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, available

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, available
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <available>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Emoji]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "available"))
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  available
Nature of error: Variable available is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: available
LSP: Generating Completions for prefix: available
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Emojis"
root ::= completions

Top 20 Logits:
Em:22.5474
em:14.2795	rejected
 Em:14.0232	rejected
E:13.9693
 em:12.8968	rejected
Im:12.8671	rejected
Empty:12.5747	rejected
Ex:12.0306	rejected
Emp:11.6631	rejected
El:11.4769	rejected
Ed:11.4573	rejected
En:10.995	rejected
Ent:10.9655	rejected
EM:10.831	rejected
Er:10.6906	rejected
Om:10.586	rejected
Est:10.5857	rejected
Rem:10.5436	rejected
Equ:10.5289	rejected
Am:10.5043	rejected
Col:10.4889	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEm

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEm
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <availableEm>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Emoji]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "availableEm"))
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  availableEm
Nature of error: Variable availableEm is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: availableEm
LSP: Generating Completions for prefix: availableEm
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ojis"
root ::= completions

Top 20 Logits:
oj:31.6213
jos:17.3993	rejected
jo:16.059	rejected
oz:15.5469	rejected
o:15.2561
oi:14.5181	rejected
ois:14.3923	rejected
j:14.0888	rejected
ij:13.8513	rejected
ijo:13.7722	rejected
oy:13.3578	rejected
uj:13.2327	rejected
ot:12.9081	rejected
obj:12.8919	rejected
og:12.7551	rejected
aj:12.7221	rejected
yj:12.5367	rejected
jpg:12.4161	rejected
os:11.9662	rejected
ajo:11.8749	rejected
ok:11.6452	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmoj

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmoj
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <availableEmoj>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Emoji]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "availableEmoj"))
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  availableEmoj
Nature of error: Variable availableEmoj is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: availableEmoj
LSP: Generating Completions for prefix: availableEmoj
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "is"
root ::= completions

Top 20 Logits:
is:28.179
Is:16.7897	rejected
ies:16.5752	rejected
i:16.0416
ir:15.177	rejected
ins:15.0769	rejected
irs:14.325	rejected
ises:13.6939	rejected
ios:13.3098	rejected
ias:13.2101	rejected
iss:13.1495	rejected
isi:13.0934	rejected
ish:12.8597	rejected
ism:12.7925	rejected
ise:12.7631	rejected
ist:12.6933	rejected
if:12.6918	rejected
ists:12.2223	rejected
us:12.2188	rejected
ís:12.207	rejected
ings:12.124	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <availableEmojis>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Emoji]
  LSP: Info: Seft type: [String]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: availableEmojis
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: availableEmojis
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action availableEmojis selectedEmoji grid update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
):19.891
 ):16.7196

:15.8759
 end:14.8537	rejected
 :14.5708
),:13.4678	prefix accepted:)
)):12.9827
 in:12.761	rejected
  :12.567
,:12.325
);:12.0123	prefix accepted:)
    :11.0044
)]:10.9566	prefix accepted:)
                :10.4515
)":10.2212	prefix accepted:)
   :10.2202
      :10.1134
)*:9.98472	prefix accepted:)
)|:9.88957	prefix accepted:)
        :9.76891
)`:9.76121	prefix accepted:)

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis)

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 end:17.5486

:15.8617
 :15.7834
 in:14.8893	rejected
  :13.7266
end:12.7764
    :12.4396
      :12.1359
        :11.7695
                :11.5355
   :11.2101
 #:10.6475	rejected
          :10.5247
     :10.5138
         :10.4875
            :10.4736
       :9.91747
           :9.61945
             :9.46582
              :9.43819
in:9.39909	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <case end>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Case expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, availableEmojis: [Emoji], selectedEmoji: Emoji, grid: Grid, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Model, Action) -> Model)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "in"
root ::= new-tokens

Top 20 Logits:
 in:18.916
 :16.4753

:15.9487
  :14.2954
    :12.2498
   :11.2848
      :11.2345
;:11.1629	rejected
in:10.9009
 #:10.8073	rejected
        :10.6886
                :10.3053
     :10.0251
 end:9.73555	rejected
         :9.62061
 with:9.32318	rejected
       :9.24738
	:9.23601	rejected
 ;;:9.22684	rejected
;;:9.19155	rejected
#:9.1787	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:18.8457
 :17.3535
  :16.0242
    :14.514
      :13.7315
   :13.022
        :12.4118
                :12.3611
          :12.0651
     :11.8899
       :11.4333
         :11.3645
            :11.3277
           :11.3135
 #:11.163	rejected
              :11.1482
	:11.0973	rejected
             :10.4737
               :10.1531
`:9.98406	rejected
;:9.40358	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in


LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
  :19.0746

:18.7951
    :17.4014
      :16.6564
 :16.3716
        :15.9329
```:15.2083	rejected
#:15.1266	rejected
                :14.8221
   :14.1926
          :14.1563
            :13.9724
     :13.7641
              :13.6433
         :13.4232
       :13.3755
           :12.9749
	:12.9658	rejected
let:12.9259
"":12.6626
             :12.556

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:21.1787
 #:15.0159	rejected
	:14.467	rejected
 ```:13.9142	rejected
 let:13.3229
 *:12.4454	rejected
 (*:12.1821	prefix accepted: (
 """:12.1455	prefix accepted: ""
 }:11.9498	rejected
 *):11.7634	rejected
:11.5785	rejected
 type:11.5336
 {:11.3147	rejected
 model:11.2313
 `:11.2299	rejected
 */:11.2126	rejected
 ###:11.0897	rejected
 ":11.0516
​:11.0005	rejected
1:10.9476
 ;;:10.9307	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  


LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
#:15.7147	rejected
let:15.1264
type:13.5534

:12.7193
  :12.2784
 :12.1793
(*:10.8603	prefix accepted:(
module:10.3372	rejected
 #:10.1297	rejected
    :10.1119
open:9.95941	rejected
model:9.93633
##:9.64935	rejected
fun:9.47915
################:9.41983	rejected
{:9.28905	rejected
 let:8.9955
print:8.99471	rejected
```:8.95664	rejected
   :8.91837
import:8.7172	rejected
Rejected the highest logit candidate # with logit -inf

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:19.6204
 #:16.6295	rejected
 let:15.8318
 type:14.1489
 (*:13.0471	prefix accepted: (
	:12.7804	rejected
 *:12.3917	rejected
 model:12.1729
1:12.1375
 ###:12.09	rejected
0:11.9181
 ##:11.6686	rejected
 ```:11.6361	rejected
 {:11.5662	rejected
:11.4967	rejected
 case:11.4592
 -:11.1745
 fun:11.1637
 module:11.0687	rejected
 /*:10.971	rejected
 #[:10.8935	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  


LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
#:15.4931	rejected
let:14.5977
type:13.3124
 :12.9426
  :12.6386

:12.2536
(*:10.6031	prefix accepted:(
    :10.5456
 #:10.4127	rejected
module:10.3576	rejected
##:10.3196	rejected
################:10.0604	rejected
model:9.3684
{:9.32426	rejected
open:9.26352	rejected
import:9.03748	rejected
```:9.02806	rejected
   :8.98531
                :8.98144
      :8.96671
####:8.7621	rejected
Rejected the highest logit candidate # with logit -inf

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 view:13.3584
 select:11.2242
 get:11.0415
 main:10.8766
 model:10.8402
 em:10.6623
 render:10.5375
 string:10.3014
 init:10.2978
 draw:10.255
 is:9.78253
 stamp:9.77175
 equal:9.68096
 grid:9.59179
 action:9.57031
 eq:9.44302
 Em:9.41565	rejected
 make:9.38755
 update:9.32504
 actions:9.15862
 print:9.12866

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <model>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {model: ?, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: model
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: model
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
_:15.7872
::12.5015
ToString:12.398
View:12.1522
 =:12.0711
2:11.9829
To:11.3451
Init:10.9188
Eq:10.3608
Get:9.90642
Equal:9.87544
Equals:9.69369
Sub:9.62117
Is:9.56532
 ::9.53033
ToList:9.42322
Of:9.20487
Update:9.07991
,:8.96622
And:8.92199
view:8.92004

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <model_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {model_: ?, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: model_
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: model_
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
view:15.8239
init:15.3504
to:15.1946
eq:14.8756
update:14.2476
equal:13.8123
toString:13.6926
subscribe:13.4398
action:13.4351
of:13.1605
sub:13.1522
get:12.8688
string:12.591
draw:12.2684
test:12.1988
display:12.1481
render:12.0842
select:11.9644
actions:11.8891
st:11.8629
json:11.8429

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <model_init>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {model_init: ?, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: model_init
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: model_init
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
::14.047
 =:13.208
_:11.8247
2:11.3447
 ::10.2416
():9.46943	prefix accepted:(
()::9.23831	prefix accepted:(
With:9.01398
'::8.94016	rejected
':8.85167	rejected
,:8.59047
1:8.57773
View:8.43752
 :7.88482
0:7.78912
Test:7.77435
:(:7.74234	prefix accepted::
Model:7.63647
 ():7.58841	prefix accepted: (
 in:7.47556	rejected
V:7.3735

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init:

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init:
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >:<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Annotation
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {model_init: ?, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Annotation
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {model_init: ?, update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty type hole
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex or complete: :
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: :
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ":"
new-tokens ::= whitespace | "(" | "()" | "+" | "Action" | "Bool" | "Col" | "Emoji" | "Float" | "Grid" | "Int" | "Model" | "Row" | "String" | "[" | constructor
root ::= completions | new-tokens

Top 20 Logits:
 Model:16.7994
 Grid:11.772
 (:11.4515
 ():11.242
 Int:10.9634
Model:10.7077
 ?:10.6619	rejected
 :10.5082
 [:10.3405
 Em:10.3354
 M:9.72572
 =:9.42142	rejected
 State:9.41516
 {:9.39523	rejected
 model:9.3827	rejected
 Unit:9.3615
 [[:9.26478	prefix accepted: [
 String:9.21844
 Option:9.107
 ((:9.08352	prefix accepted: (
 int:8.81023	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init: Model

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init: Model
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Model>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: Model
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Model
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Grid Col Row Emoji () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
new-tokens ::= whitespace | "(" | "+" | "," | "->" | "="
root ::= completions | new-tokens

Top 20 Logits:
 =:18.3375
 :13.2487
 in:11.7564	rejected

:11.4706
 ->:11.3617
=:10.4749
():10.4215	prefix accepted:(
                :10.4161
    :10.3646
  :10.261
 *:9.96876	rejected
     :9.81767
,:9.73954
 ~:9.69908	rejected
2:9.5725
   :9.41118
 :=:9.3797	rejected
      :9.36126
;:9.35869	rejected
:9.33859
<:9.2267	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init: Model =

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init: Model =
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 (:16.9002
 :16.0368
 ([:14.8193	prefix accepted: (

:14.696
 [:12.5136
 ?:12.4072	rejected
 ...:12.3185	rejected
 ((:12.2783	prefix accepted: (
 update:12.1182
 in:11.9862
 init:11.7168	rejected
 (":11.7159	prefix accepted: (
 fun:11.5812
 ({:11.579	prefix accepted: (
 {:11.5536	rejected
 [(:11.1432	prefix accepted: [
  :11.0756
 ():10.9191
 model:10.8463
 #:10.8032	rejected
 let:10.6489

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init: Model = (

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init: Model = (
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[String]], String, [String])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:

:16.761
 :13.4838
[[:13.1832	prefix accepted:[
 #:12.007	rejected
[":11.7177	prefix accepted:[
 [:11.4327
#:11.3835	rejected
  :11.186
?,:11.1661	rejected
empty:10.937	rejected
([:10.8051	prefix accepted:(
model:10.773
    :10.6287
[]:10.5866
 ?:10.313	rejected
 [[:10.3121	prefix accepted: [
                :10.2641
List:10.2425	rejected
grid:10.0677	rejected
init:9.9439	rejected
   :9.74739

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init: Model = (


LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init: Model = (

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 :19.7709
   :14.7466
 [:13.9406
  :13.8942
[:13.6816
     :13.0993
	:12.6665	rejected

:12.6106
    :12.4698
#:12.088	rejected
[":11.7028	prefix accepted:[
 [":11.5602	prefix accepted: [
                :11.4968
[[:11.3383	prefix accepted:[
 #:11.2491	rejected
       :10.7569
      :10.6759
 [[:10.6068	prefix accepted: [
":10.4175
 let:10.4102
([:10.3725	prefix accepted:(

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init: Model = (
 

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init: Model = (
 
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 [:19.2185
 [[:14.7671	prefix accepted: [
 List:13.9008	rejected
 #:13.8886	rejected
 [],:13.3132	prefix accepted: []
 init:13.2273	rejected
 [":13.2133	prefix accepted: [
 ?:12.6804	rejected
 ([:12.4824	prefix accepted: (
 (:12.4824
 let:11.9471
 grid:11.9386	rejected
 []:13.3132
 Em:11.4697	rejected
 {:11.4221	rejected
 Grid:11.4082	rejected
 ":11.2759
 Array:10.885	rejected
 [(:10.7723	prefix accepted: [
 (*:10.7007	prefix accepted: (
 initial:10.6324	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init: Model = (
  [

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init: Model = (
  [
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <[ ]<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model"); syn = (List (Unknown Internal))})))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) in
  LSP: Info: ALL errors:
Error in term:
  ?
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model"); syn = (List (Unknown Internal))})))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) in
  LSP: Info: ALL errors:
Error in term:
  ?
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) in
  LSP: Info: ALL errors:
Error in term:
  ?
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-convex or complete: [
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: [
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "]"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
[":19.3333	prefix accepted:[
 [":13.8998	prefix accepted: [

:13.8924
[]:11.8774
 #:11.5915	rejected
                :11.4254
 :11.3693
[':11.3166	prefix accepted:[
#:11.0751	rejected
 [:13.8998
(":10.747	prefix accepted:(
  :10.4522
List:9.9237	rejected
   :9.61627
|:9.50223	rejected
     :9.43898
    :9.28466
        :9.19522
      :9.03566
 //:8.92655	rejected
          :8.66202
Rejected the highest logit candidate [" with logit -inf

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init: Model = (
  [[

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init: Model = (
  [[
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <[ ]<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ] ) in
  LSP: Info: ALL errors:
Error in term:
  ?
Nature of error: Expecting type Model but got inconsistent type [[?]]
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ] ) in
  LSP: Info: ALL errors:
Error in term:
  ?
Nature of error: Expecting type Model but got inconsistent type [[?]]
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ] ) in
  LSP: Info: ALL errors:
Error in term:
  ?
Nature of error: Expecting type Model but got inconsistent type [[?]]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-convex or complete: [
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: [
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "]"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
],:12.9643	prefix accepted:]
[":11.6778	prefix accepted:[
?,:11.5975	rejected
 "",:11.4733	prefix accepted: ""
0:11.4265
(":11.2548	prefix accepted:(
?:11.2542	rejected
],[:10.9695	prefix accepted:]
�:10.9439	rejected
1:10.9434
",":10.8317
None:10.7405	rejected
“:10.7131	rejected
 ":10.5126
",:9.91902
];:9.82317	prefix accepted:]
_,:9.81802	rejected
E:9.76606	rejected

:9.56513
 ?:9.11041	rejected
#:8.93471	rejected
Rejected the highest logit candidate ], with logit -inf

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init: Model = (
  [[]

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init: Model = (
  [[]
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) in
  LSP: Info: ALL errors:
Error in term:
  
Nature of error: Expecting type Model but got inconsistent type [[?]]
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-concave or complete: []
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: []
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "]"
root ::= new-tokens

Top 20 Logits:

:13.1293
[":11.4606	rejected
 ::11.3441
:::11.1584
[]:10.9541	rejected
                :10.928
#:10.8096	rejected
 #:10.7669	rejected
 :10.7468
],:10.7089	prefix accepted:]
 ,:10.6193
 @:10.5153
 in:10.4497	rejected
@:10.3808
 ],:9.86282	prefix accepted: ]
 [":9.70963	rejected
    :9.69652
  :9.67339
 :::9.66446
 //:9.65797	prefix accepted: /
 |:9.63835	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init: Model = (
  [[]                

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init: Model = (
  [[]                
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) in
  LSP: Info: ALL errors:
Error in term:
  
Nature of error: Expecting type Model but got inconsistent type [[?]]
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "]"
root ::= new-tokens

Top 20 Logits:
    :15.4799
     :15.2934
 #:15.2427	rejected
                :15.1604
      :14.9887
             :14.6685
        :14.6035
            :14.5937
         :14.587
          :14.4587
              :14.4176
               :14.4061
           :14.3935
  :14.2561
   :14.1881
 :14.1066
       :13.4797

:10.9412
 ,:10.6997
 ],:10.2948	prefix accepted: ]
 ]:10.2948

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init: Model = (
  [[]                    

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init: Model = (
  [[]                    
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) in
  LSP: Info: ALL errors:
Error in term:
  
Nature of error: Expecting type Model but got inconsistent type [[?]]
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "]"
root ::= new-tokens

Top 20 Logits:
 #:20.14	rejected

:15.6934
 ,:14.3347
 (*:13.8945	prefix accepted: (
 \:13.4311
 #[:13.3704	rejected
 //:13.3168	prefix accepted: /
 ::13.204
 ],:13.0068	prefix accepted: ]
 ]:13.0068
 []:12.5338	rejected
 ;:12.352	rejected
 in:12.3172	rejected
 ##:12.2007	rejected
 |:12.1651	rejected
 [],:12.0851	rejected
 <:11.9709
 *:11.9397
 --:11.8711	prefix accepted: -
 (:13.8945
 /*:11.776	prefix accepted: /
Rejected the highest logit candidate  # with logit -inf

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init: Model = (
  [[]                    


LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init: Model = (
  [[]                    

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) in
  LSP: Info: ALL errors:
Error in term:
  
Nature of error: Expecting type Model but got inconsistent type [[?]]
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "]"
root ::= new-tokens

Top 20 Logits:
 :15.3091
   :14.4494
  :14.2538
     :13.1147
]):12.6237	prefix accepted:]
],:12.5768	prefix accepted:]
    :12.5759

:11.9231
                :11.7698
      :11.6969
#:11.696	rejected
]:12.6237
end:11.0639	rejected
 ]:10.9999
```:10.6982	rejected
        :10.5517
 ],:10.5371	prefix accepted: ]
,:10.5176
let:10.3409	rejected
               :10.3188
             :10.3174

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init: Model = (
  [[]                    
 

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init: Model = (
  [[]                    
 
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) in
  LSP: Info: ALL errors:
Error in term:
  
Nature of error: Expecting type Model but got inconsistent type [[?]]
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "]"
root ::= new-tokens

Top 20 Logits:
 ],:14.1757	prefix accepted: ]
 ,:14.168
 ]:14.1757
 [":13.7929	rejected
 |:12.4977	rejected
 [:12.3708	rejected
 []:12.2647	rejected
 #:11.9168	rejected
 [],:11.7412	rejected
 List:11.7188	rejected
 for:11.3772	rejected
 //:10.9891	prefix accepted: /
 let:10.9626	rejected
 ::10.9409
 [[:10.7278	rejected
 +:10.6237
 ...:10.1484	rejected
 ":10.068	rejected
 grid:10.0364	rejected
 in:10.0011	rejected
 .:9.96347	rejected
Rejected the highest logit candidate  ], with logit -inf

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init: Model = (
  [[]                    
  ,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init: Model = (
  [[]                    
  ,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [[?]]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model");
           syn = (List (List (Unknown Internal)))})))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) in
  LSP: Info: ALL errors:
Error in term:
  , ?
Nature of error: Expecting type Model but got inconsistent type [[?]]
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [[?]]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model");
           syn = (List (List (Unknown Internal)))})))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) in
  LSP: Info: ALL errors:
Error in term:
  , ?
Nature of error: Expecting type Model but got inconsistent type [[?]]
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) in
  LSP: Info: ALL errors:
Error in term:
  , ?
Nature of error: Expecting type Model but got inconsistent type [[?]]
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
[":13.5197	prefix accepted:[
[]:13.4125
 []:11.9949
 [":11.5968	prefix accepted: [
[:13.5197
 [:11.5968
                :9.73929
[':9.64269	prefix accepted:[

:9.31428
 [],:9.26438	prefix accepted: []
[(:8.66693	prefix accepted:[
 :8.57894
(:8.18406
List:8.14483	rejected
"":8.00126
  :7.94715
 List:7.91299	rejected
 ":7.90673
[,:7.88995	prefix accepted:[
 "":7.7981
 [(:7.73847	prefix accepted: [
Rejected the highest logit candidate [" with logit -inf

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init: Model = (
  [[]                    
  ,[

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init: Model = (
  [[]                    
  ,[
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <[ ]<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ] ) in
  LSP: Info: ALL errors:
Error in term:
  , ?
Nature of error: Expecting type Model but got inconsistent type [[?]]
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ] ) in
  LSP: Info: ALL errors:
Error in term:
  , ?
Nature of error: Expecting type Model but got inconsistent type [[?]]
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ] ) in
  LSP: Info: ALL errors:
Error in term:
  , ?
Nature of error: Expecting type Model but got inconsistent type [[?]]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-convex or complete: [
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: [
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "]"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
],:13.0731	prefix accepted:]
?:11.508	rejected
(":11.4716	prefix accepted:(
],[:11.2146	prefix accepted:]
[":11.0237	prefix accepted:[
 ":10.7928
?,:10.4114	rejected
[]:10.384
0:10.1212

:10.0511
 "":10.0099
1:9.99744
<:9.99545	rejected
];:9.90184	prefix accepted:]
                :9.85441
",":9.6939
 ]:9.48981	rejected
�:9.37369	rejected
 "",:9.26226	prefix accepted: ""
List:9.21347	rejected
`:9.06078	rejected
Rejected the highest logit candidate ], with logit -inf

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init: Model = (
  [[]                    
  ,[]

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init: Model = (
  [[]                    
  ,[]
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) in
  LSP: Info: ALL errors:
Error in term:
  , 
Nature of error: Expecting type Model but got inconsistent type [[?]]
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: []
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: []
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "]"
root ::= new-tokens

Top 20 Logits:
                :16.0353

:15.8547
 :13.5659
               :13.1742
           :12.7174
             :12.7021
      :12.6969
              :12.6506
     :12.6398
            :12.5852
  :12.5121
        :12.3543
          :12.3335
         :12.1562
    :11.9699
   :11.9591
       :11.2539
 ]:11.0264
 #:10.6618	rejected
 ],:10.6101	prefix accepted: ]
 ,:10.1744

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init: Model = (
  [[]                    
  ,[]


LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init: Model = (
  [[]                    
  ,[]

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) in
  LSP: Info: ALL errors:
Error in term:
  , 
Nature of error: Expecting type Model but got inconsistent type [[?]]
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "]"
root ::= new-tokens

Top 20 Logits:
 :18.6229
  :14.0999
],:13.9172	prefix accepted:]
     :13.3945
   :13.3638
                :13.0694
      :12.6008
 ],:12.5154	prefix accepted: ]
]:13.9172
]):12.1393	prefix accepted:]
 ,:11.9197
]]:11.911	prefix accepted:]
 ]:12.5154
    :11.7915
	:11.5704	rejected

:11.4409
,:11.3691
#:11.3046	rejected
              :11.0714
            :10.9461
             :10.864

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init: Model = (
  [[]                    
  ,[]
 

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init: Model = (
  [[]                    
  ,[]
 
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) in
  LSP: Info: ALL errors:
Error in term:
  , 
Nature of error: Expecting type Model but got inconsistent type [[?]]
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "]"
root ::= new-tokens

Top 20 Logits:
 ,:20.0301
 ],:18.1205	prefix accepted: ]
 ]:18.1205
 []:14.8275	rejected
 ]]:14.2302	prefix accepted: ]
 #:13.7962	rejected
 [],:13.535	rejected
 ),:12.6149	rejected
 ::12.5055
 ...:12.3391	rejected
 :::12.3061
 //:12.2641	prefix accepted: /
 ):12.2436	rejected
 #[:12.2134	rejected
 [:12.1467	rejected
 ():11.9702	prefix accepted: (
 [":11.8016	rejected
 ];:11.7032	prefix accepted: ]
 (*:11.6422	prefix accepted: (
 },:11.6321	rejected
 *:11.6062

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init: Model = (
  [[]                    
  ,[]
  ,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init: Model = (
  [[]                    
  ,[]
  ,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [[?]]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model");
           syn = (List (List (Unknown Internal)))})))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) in
  LSP: Info: ALL errors:
Error in term:
  , , ?
Nature of error: Expecting type Model but got inconsistent type [[?]]
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [[?]]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model");
           syn = (List (List (Unknown Internal)))})))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) in
  LSP: Info: ALL errors:
Error in term:
  , , ?
Nature of error: Expecting type Model but got inconsistent type [[?]]
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) in
  LSP: Info: ALL errors:
Error in term:
  , , ?
Nature of error: Expecting type Model but got inconsistent type [[?]]
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
[]:16.7852
[":14.2891	prefix accepted:[
[:14.2891
 []:12.3047
[':10.8689	prefix accepted:[
[]):10.6124	prefix accepted:[]
[(:9.88515	prefix accepted:[
[{:9.83028	prefix accepted:[
 [":9.76262	prefix accepted: [

:9.6192
 [:9.76262
[,:9.37768	prefix accepted:[
[[:8.86753	prefix accepted:[
[::8.34463	prefix accepted:[
[\:8.17302	prefix accepted:[
]:8.12059	rejected
],:8.09609	rejected
 :7.88428
([:7.85125	prefix accepted:(
<:7.77744	rejected
 [],:7.54341	prefix accepted: []

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init: Model = (
  [[]                    
  ,[]
  ,[]

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init: Model = (
  [[]                    
  ,[]
  ,[]
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) in
  LSP: Info: ALL errors:
Error in term:
  , , 
Nature of error: Expecting type Model but got inconsistent type [[?]]
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: []
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: []
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "]"
root ::= new-tokens

Top 20 Logits:
],:19.0235	prefix accepted:]

:17.5967
]:19.0235
                :15.4054
]):15.2491	prefix accepted:]
 ],:14.9515	prefix accepted: ]
 ]:14.9515
 :14.5967
]),:14.5578	prefix accepted:]
]],:14.4562	prefix accepted:]
]]:14.4374	prefix accepted:]
  :13.6308
     :13.2737
               :13.1151
   :13.05
      :13.0229
]]):12.9567	prefix accepted:]
    :12.7761
            :12.7155
        :12.6679
              :12.6098
Rejected the highest logit candidate ], with logit -inf

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init: Model = (
  [[]                    
  ,[]
  ,[]]

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init: Model = (
  [[]                    
  ,[]
  ,[]]
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [[?]]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model");
           syn = (List (List (Unknown Internal)))})))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in
  LSP: Info: ALL errors:
Error in term:
  , , 
Nature of error: Expecting type Model but got inconsistent type [[?]]
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:

:15.9307
                :15.3199
 #:13.9668	rejected
 :13.6423
  :13.0025
 ,:12.9899
     :12.972
               :12.8547
           :12.807
            :12.7349
      :12.7122
        :12.6121
          :12.5536
             :12.5213
              :12.4742
         :12.2841
   :12.2522
    :11.7708
       :11.4858
#:10.6188	rejected
 ):10.2187

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init: Model = (
  [[]                    
  ,[]
  ,[]]                

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init: Model = (
  [[]                    
  ,[]
  ,[]]                
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [[?]]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model");
           syn = (List (List (Unknown Internal)))})))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in
  LSP: Info: ALL errors:
Error in term:
  , , 
Nature of error: Expecting type Model but got inconsistent type [[?]]
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
   :16.2387
     :15.8412
    :15.3749
      :15.1207
  :15.0531
 #:14.7133	rejected
        :14.6872
         :14.5985
 :14.3864
          :14.3144
                :14.2671
             :14.2516
              :14.1811
            :14.1547
           :14.0517
               :13.7924

:13.7251
       :13.6701
 ,:11.2046
 //:10.2582	prefix accepted: /
 ##:8.61789	rejected

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init: Model = (
  [[]                    
  ,[]
  ,[]]                     

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init: Model = (
  [[]                    
  ,[]
  ,[]]                     
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [[?]]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model");
           syn = (List (List (Unknown Internal)))})))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in
  LSP: Info: ALL errors:
Error in term:
  , , 
Nature of error: Expecting type Model but got inconsistent type [[?]]
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
 #:19.7063	rejected

:18.2533
 ,:14.4266
 //:13.2198	prefix accepted: /
 ):12.8428
 (*:12.5216	prefix accepted: (
 ##:12.259	rejected
 Em:11.8934	rejected
 <:11.7734
 #[:11.7707	rejected
	:11.7492	rejected
 \:11.6072
 *:11.5502
 Grid:11.477	rejected
 @:11.2718
 ::11.2241
 --:11.1892	prefix accepted: -
 ###:11.1132	rejected
 (:12.5216
 |:11.0223	rejected
 /*:11.0049	prefix accepted: /
Rejected the highest logit candidate  # with logit -inf

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init: Model = (
  [[]                    
  ,[]
  ,[]]                     


LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init: Model = (
  [[]                    
  ,[]
  ,[]]                     

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [[?]]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model");
           syn = (List (List (Unknown Internal)))})))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in
  LSP: Info: ALL errors:
Error in term:
  , , 
Nature of error: Expecting type Model but got inconsistent type [[?]]
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
 :17.2854
,:15.4753
 ,:14.1567
,[:14.1307	prefix accepted:,
  :14.0582
                :13.7745
   :13.3566

:12.8515
      :12.5958
,":12.5388	prefix accepted:,
):12.2346
     :12.1786
    :12.0204
),:11.7458	prefix accepted:)
,(:11.646	prefix accepted:,
            :11.6261
          :11.607
        :11.5988
               :11.4621
           :11.4236
         :11.3511

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init: Model = (
  [[]                    
  ,[]
  ,[]]                     
 

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init: Model = (
  [[]                    
  ,[]
  ,[]]                     
 
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [[?]]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model");
           syn = (List (List (Unknown Internal)))})))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in
  LSP: Info: ALL errors:
Error in term:
  , , 
Nature of error: Expecting type Model but got inconsistent type [[?]]
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
 ,:17.8254
,":16.5018	prefix accepted:,
 #:15.1905	rejected
 ):14.2052
 ":13.8906	rejected
 //:12.9901	prefix accepted: /
 (":12.8537	prefix accepted: (

:12.7981
 ),:12.6986	prefix accepted: )
 [":12.6616	rejected
 (*:12.1092	prefix accepted: (
 ]:12.0323	rejected
 :::12.0137
 "":11.7724	rejected
 ;:11.51	rejected
 ::11.5044
 ],:11.4691	rejected
 |:11.415	rejected
 @:11.3427
 [:11.1537	rejected
 (:12.8537

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init: Model = (
  [[]                    
  ,[]
  ,[]]                     
  ,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init: Model = (
  [[]                    
  ,[]
  ,[]]                     
  ,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[?]], ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model");
           syn =
           (Prod [(List (List (Unknown Internal))); (Unknown Internal)])})))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in
  LSP: Info: ALL errors:
Error in term:
  , , , ?
Nature of error: Expecting type Model but got inconsistent type ([[?]], ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([[?]], ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model");
           syn =
           (Prod [(List (List (Unknown Internal))); (Unknown Internal)])})))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in
  LSP: Info: ALL errors:
Error in term:
  , , , ?
Nature of error: Expecting type Model but got inconsistent type ([[?]], ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), fillRowInGrid: ((Grid, Row, Emoji) -> Grid), clearGrid: (Grid -> Grid), updateGrid: ((Grid, Row, Col, Emoji) -> Grid), model_init: Model, SelectEmoji: (Emoji -> Action), StampEmoji: ((Row, Col) -> Action), ClearCell: ((Row, Col) -> Action), ClearGrid: Action, FillRow: (Row -> Action), Action:: (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)), Model:: (Grid, Emoji, [Emoji]), Grid:: [[Emoji]], Col:: Int, Row:: Int, Emoji:: String, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in
  LSP: Info: ALL errors:
Error in term:
  , , , ?
Nature of error: Expecting type Model but got inconsistent type ([[?]], ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: update fillRowInGrid clearGrid updateGrid model_init string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity SelectEmoji StampEmoji ClearCell ClearGrid FillRow () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "ClearCell" | "ClearGrid" | "FillRow" | "SelectEmoji" | "StampEmoji" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "clearGrid" | "cos" | "epsilon_float" | "exp" | "false" | "fillRowInGrid" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model_init" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | "updateGrid" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 ":14.7508
 "":12.6925
 "",:10.965	prefix accepted: ""

:10.6125
                :10.5655
 :10.252
 ?:9.77139	rejected
 #:9.70636	rejected
[":9.32766	prefix accepted:[
(":9.25742	prefix accepted:(
�:9.16921	rejected
 Em:8.88407	rejected
?:8.88123	rejected
"":8.81168
 [":8.73486	prefix accepted: [
  :8.72969
 (":8.6305	prefix accepted: (
 []:8.4877
#:8.46273	rejected
 "::8.34991
"::8.15185

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init: Model = (
  [[]                    
  ,[]
  ,[]]                     
  , "

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init: Model = (
  [[]                    
  ,[]
  ,[]]                     
  , "
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >,<
LSP: Must extend/complete stringlit: ""
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-stringlit
root ::= completions

Top 20 Logits:
�:15.0761
�:11.1861
emo:9.48307
",":9.20669	prefix accepted:"
a:9.14697
1:9.01953
x:8.82207
?:8.80807
A:8.7851
?":8.76579
0:8.6205
sm:8.61707
 :8.52115
 ":8.19353
☺:8.10199
E:8.08028
X:7.93335
 ",:7.90261	prefix accepted: "
em:7.89568
https:7.86701
hello:7.7997

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init: Model = (
  [[]                    
  ,[]
  ,[]]                     
  , "�

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init: Model = (
  [[]                    
  ,[]
  ,[]]                     
  , "�
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >,<
LSP: Must extend/complete stringlit: "�"
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-stringlit
root ::= completions

Top 20 Logits:
�:28.1501	rejected
�:19.5189	rejected
�:18.8198	rejected
�:16.9298	rejected
�:16.6352	rejected
�:16.3588	rejected
�:15.6128	rejected
�:15.5189	rejected
�:15.3784	rejected
�:15.3284	rejected
�:15.0807	rejected
�:14.7299	rejected
�:14.7051	rejected
�:14.097	rejected
�:14.0734	rejected
�:13.8682	rejected
�:13.6731	rejected
�:13.6663	rejected
�:13.6	rejected
�:13.4675	rejected
�:13.4453	rejected
Rejected the highest logit candidate � with logit -inf

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init: Model = (
  [[]                    
  ,[]
  ,[]]                     
  , "�️

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init: Model = (
  [[]                    
  ,[]
  ,[]]                     
  , "�️
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing


================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init: Model = (
  [[]                    
  ,[]
  ,[]]                     
  , "�️�

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init: Model = (
  [[]                    
  ,[]
  ,[]]                     
  , "�️�
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >�<
LSP: Must extend/complete stringlit: ""
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-stringlit
root ::= completions

Top 20 Logits:
�:17.3758	rejected
�:17.3662	rejected
�:17.2364	rejected
�:17.0588	rejected
�:16.9947	rejected
�:16.9229	rejected
�:16.7699	rejected
�:16.7555	rejected
�:16.6677	rejected
�:16.6146	rejected
�:16.5289	rejected
�:16.4759	rejected
�:16.4579	rejected
�:16.2033	rejected
�:16.1898	rejected
�:16.0713	rejected
�:16.0033	rejected
�:16.0021	rejected
�:16.0017	rejected
�:15.9222	rejected
�:15.8927	rejected
Rejected the highest logit candidate � with logit -inf

================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init: Model = (
  [[]                    
  ,[]
  ,[]]                     
  , "�️�️

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in
  
  
let model_init: Model = (
  [[]                    
  ,[]
  ,[]]                     
  , "�️�️
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <�>
  LSP: Syntax: Rightwards segment is: [(Grout { id = b5389985-6d3f-4833-9281-361c51fb5ae6; shape = Concave });
  (Tile
     { id = 72c00b2c-cdf6-4d6e-8614-6a7a5a3591ba; label = ["\"\""];
       mold =
       { out = Exp; in_ = [];
         nibs =
         ({ shape = Convex; sort = Exp }, { shape = Convex; sort = Exp }) };
       shards = [0]; children = [] })
  ]


================

# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in

LSP: Command: Completions(Context)
LS: New token mode: 
# Update the EmojiPaint app model based on an action #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, availableEmojis), action ->
    case action
    | SelectEmoji(emoji) => (grid, emoji, availableEmojis)
    | StampEmoji(row, col) => 
      (updateGrid(grid, row, col, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearCell(row, col) =>  
      (updateGrid(grid, row, col, "")) 
        , selectedEmoji, availableEmojis
    | FillRow(rowToFill) =>
      (fillRowInGrid(grid, rowToFill, selectedEmoji)
        , selectedEmoji, availableEmojis)
    | ClearGrid => (clearGrid(grid)
        , selectedEmoji, availableEmojis) end in

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing

