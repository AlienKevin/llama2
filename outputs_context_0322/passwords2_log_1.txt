

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model =

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model =
LSP: Process zipper: Recieved string
LSP: Process Zipper: No serialized zipper, processing string
LSP: Process zipper: Recieved string
LSP: Process Zipper: No serialized zipper, processing string
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((Model, Action) -> Model)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((Model, Action) -> Model)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "calculateStrength" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:18.4013
 :16.211
 fun:15.6344
  :14.4332
    :13.4684
                :13.1702
 function:12.6208	rejected
     :12.3771
      :12.0707
   :11.9408
 (:11.8389
        :11.6843
       :11.3219
            :11.2556
	:11.0803	rejected
         :11.0215
          :10.8964
 match:10.7561	rejected
 (*:10.6615	prefix accepted: (
             :10.6397
              :10.5128

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 model:16.8588
 (:15.9588
 m:15.7981
 ((:14.5354	prefix accepted: (
 state:14.0068
 old:13.5798
 current:12.8617
 prev:12.5937
(:12.5383
 {:12.375	rejected
 initial:12.1554
 s:11.8132
 [:11.7329

:11.5493
 ({:11.3996	prefix accepted: (
 md:11.3759
 init:11.312
((:11.2882	prefix accepted:(
 x:11.2735
 previous:11.218
 acc:11.1481

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <m>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {m: (Model, Action), update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: m
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: m
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | "->"
root ::= completions | new-tokens

Top 20 Logits:
,:16.2657
dl:13.9077
::13.7658	rejected
 ->:11.6336
 ,:11.0672
0:10.9391
 ::10.8023	rejected
1:10.5701
@:10.2694	rejected
_:9.49927
do:9.36107
,(:9.25224	prefix accepted:,
x:9.23146
w:9.14131
c:9.10508
state:9.01483
:(:9.01106	rejected
_,:8.87494	prefix accepted:_
old:8.86849
l:8.86774
model:8.80256

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: ((String, [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)], (Weak + Moderate + Strong)), (UpdatePassword(String) + ClearCriteria + AddCriterion((RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)) + RemoveCriterion((RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar))))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: ((String, [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)], (Weak + Moderate + Strong)), (UpdatePassword(String) + ClearCriteria + AddCriterion((RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)) + RemoveCriterion((RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar))))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 a:18.2253
 action:15.2704
 act:14.7225
a:13.8927
 x:13.7482
 msg:13.047
 c:11.7995
action:11.3733
 ac:11.1999
 n:11.1855
 _:11.1045
 cmd:11.0791
 e:11.0713
 s:11.044
 message:10.7661
 new:10.7218
 p:10.4457
 o:10.3728
 :10.25
 v:10.1862
 acc:10.1643

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <action>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: action
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: action
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | "->"
root ::= completions | new-tokens

Top 20 Logits:
 ->:18.61
::14.5624	rejected
->:14.0385
 =>:14.0173	rejected
 :13.4357
 ::12.6678	rejected
':11.3576	rejected
 =:11.1374	rejected

:11.1216
_:10.502
 -:10.4426
 -->:10.2531	prefix accepted: -
0:9.97063
  :9.94475
 →:9.91254	rejected
?:9.80984	rejected
 :::9.73792	rejected
1:9.37927
:::9.1032	rejected
,:9.06998
 |:9.03977	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Model, Action) -> Model)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "calculateStrength" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:18.9635
 :16.6872
  :15.6043
    :14.5321
 match:14.5071	rejected
 case:13.6835
 {:13.1968	rejected
      :13.1313
   :13.0965
     :12.9364
                :12.8929
        :12.7792
       :12.5763
         :12.1357
 (:12.0176
 let:11.8736
          :11.8142
            :11.4565
 switch:11.4234	rejected
	:11.4169	rejected
 begin:11.4055	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->


LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Model, Action) -> Model)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "calculateStrength" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 :19.0137
   :16.8901
  :16.8005
case:16.0802
match:15.0156	rejected
     :14.9329
 case:14.9312

:14.7877
    :14.498
	:14.2496	rejected
 match:14.2423	rejected
       :14.1045
switch:13.3951	rejected
 let:13.1582
 switch:12.9554	rejected
      :12.9429
let:12.6624
         :12.001
#:11.9925	rejected
        :11.9458
                :11.7834

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
 

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
 
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Model, Action) -> Model)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "calculateStrength" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 case:18.9479
 let:17.3834
 match:16.6371	rejected
 switch:14.7237	rejected
 (:12.5117
 print:11.723	rejected
 #:11.6904	rejected
 if:11.6523
 (*:11.5907	prefix accepted: (
 {:10.9055	rejected
 un:10.7499	rejected
 printf:10.712	rejected
 open:10.4177	rejected
 set:10.3529	rejected
 //:10.2142	rejected
 debug:9.85262	rejected
 update:9.84794
 begin:9.7835	rejected
 f:9.76545

:9.7551
 model:9.72619	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <case end<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "calculateStrength" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 action:17.7762
 m:16.2218
 (:12.7903
 let:11.9344
 :11.343
 model:10.7371	rejected

:10.5505
 [:10.5379
 f:10.3145
 s:10.3041
 match:10.0361	rejected
 get:9.80441	rejected
(:9.46654
action:9.42533
 List:9.34849	rejected
 met:9.30218
 *:9.22531	rejected
 string:9.16776
 tuple:9.10939	rejected
 actions:9.0465	rejected
 {:9.02749	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <m>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (String, [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)], (Weak + Moderate + Strong))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: m
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Generating Completions for prefix: m
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ax_int" | "eetsCriterion" | "eetsMinLength" | "etCriteria" | "in_int" | "od"
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= completions | new-tokens

Top 20 Logits:
,:18.0954

:16.308
 :14.8913
 with:14.0231	rejected
 ,:13.6973
 of:13.4793	rejected
::13.4242
 ::12.9939
  :12.9281
 in:12.0553	rejected
 |:11.9407
 //:11.8394	prefix accepted: /
 as:11.6514	rejected
.:11.6154	rejected
 =:11.5403
                :11.532
 match:11.3249	rejected
,(:11.0763	prefix accepted:,
 ->:11.0164	prefix accepted: -
    :10.9976
 {:10.7243	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ((String, [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)], (Weak + Moderate + Strong)), ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ((String, [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)], (Weak + Moderate + Strong)), ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "calculateStrength" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 action:19.5993
action:15.4257
 :12.5706
 m:11.6975
 a:11.4971
 actions:10.7584	rejected
 s:10.7036
 act:10.7
 (:10.6454

:10.5819
  :9.74005
 ac:9.72413
 Action:9.667	rejected
 update:9.37503
 calculate:9.235
 x:9.14751	rejected
 f:9.1475
 #:9.01923	rejected
 c:8.84233
 met:8.7238
 match:8.58717	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <action>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (UpdatePassword(String) + ClearCriteria + AddCriterion((RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)) + RemoveCriterion((RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: action
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Generating Completions for prefix: action
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:19.007
 :17.3981
 of:16.9307	rejected
  :15.8974
 with:14.668	rejected
    :14.6557
                :14.5613
      :13.7793
     :13.4602
 |:13.1724
   :13.0077
 =>:13.0047	prefix accepted: =
       :12.674
        :12.6653
          :12.5938
            :12.536
::12.4403
         :12.3062
 {:12.2237	rejected
 ->:12.1466	prefix accepted: -
,:12.1122

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action


LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <action>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (UpdatePassword(String) + ClearCriteria + AddCriterion((RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)) + RemoveCriterion((RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 :20.1097
  :18.2899
    :16.8663
   :16.8301

:16.7034
     :15.4102
      :14.7743
|:14.6536
#:14.1726	rejected
                :14.1115
 |:14.0205
       :14.0086
        :13.9719
	:13.9437	rejected
(*:13.8778	prefix accepted:(
            :13.2539
          :13.2396
         :12.7406
           :12.3881
              :11.9733
             :11.8257

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
 

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
 
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <action>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (UpdatePassword(String) + ClearCriteria + AddCriterion((RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)) + RemoveCriterion((RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:22.6226
 (*:17.5791	prefix accepted: (
 #:17.0414	rejected
 /*:14.8019	prefix accepted: /
 //:14.6439	prefix accepted: /

:13.6315
 ##:13.629	rejected
 (**:13.474	prefix accepted: (
 ###:13.2777	rejected
 ||:13.1846	prefix accepted: |
 *:12.7118
 +:12.4727
 /**:12.1371	prefix accepted: /
 {:12.0619	rejected
 /:14.8019
 ///:12.0363	prefix accepted: /
 ####:11.8094	rejected
 --:11.6453	prefix accepted: -
 ~:11.5083	rejected
 (:17.5791
 match:11.3745	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  |

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  |
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 _,:15.4543	prefix accepted: _
 (:14.8209
 model:13.3801
 ((:13.0268	prefix accepted: (
 m:12.5844
 password:12.54
 p:12.139
 _:15.4543
 old:11.2331
 (_:10.9458	rejected
 initial:10.7509
 x:10.4637
 s:10.1478
(:9.92187
 pm:9.91968
 state:9.74537
 c:9.65525
 new:9.64177
_,:9.55321	prefix accepted:_
 a:9.51688
 md:9.36817
Rejected the highest logit candidate  _, with logit -inf

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Wildcard
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Wildcard
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: _
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: _
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
 ,:14.2277
model:13.1728	rejected
 as:12.9589	rejected
m:12.6331	rejected
:::12.3615	rejected
 ->:11.3042	rejected
 :::11.1477	rejected
::11.0844	rejected
 =>:10.6324
 when:10.6229	rejected
_,:10.4062	rejected
password:10.1178	rejected
 +:10.0403	rejected
 ::9.38527	rejected
x:9.35105	rejected
 =:8.91082
p:8.86098	rejected
@:8.78353	rejected
 :=:8.76645	rejected
->:8.59305	rejected
Model:8.33666	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ ,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ ,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: ((String, [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)], (Weak + Moderate + Strong)), (UpdatePassword(String) + ClearCriteria + AddCriterion((RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)) + RemoveCriterion((RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar))))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: ((String, [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)], (Weak + Moderate + Strong)), (UpdatePassword(String) + ClearCriteria + AddCriterion((RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)) + RemoveCriterion((RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar))))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 Clear:16.929
 Update:14.8763
 Add:13.7155
Clear:13.6464
Update:12.6489
 Remove:11.7285
 _:11.3793
 :10.8461
 Action:10.4831	rejected
Add:10.2344
 (:10.1076
  :9.1547
 clear:8.89459
                :8.66392
Remove:8.50657
(:8.49796
_:8.4288

:8.36005
Action:8.34711	rejected
 {:8.31339	rejected
 ?:8.28963	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , Clear

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , Clear
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Clear>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "Clear"))))
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  Clear
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Clear
LSP: Generating Completions for prefix: Clear
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Criteria"
root ::= completions

Top 20 Logits:
C:19.5328
Password:12.8148	rejected
All:11.8919	rejected
Action:11.1919	rejected
():11.1657	rejected
 C:10.9836	rejected
c:10.8522	rejected
_:10.4087	rejected
 =>:10.1733	rejected

:10.1062	rejected
Actions:9.93153	rejected
Credentials:9.38909	rejected
Pass:9.38506	rejected
State:9.17692	rejected
 ->:9.09532	rejected
Str:8.96885	rejected
Model:8.90163	rejected
(_:8.79755	rejected
Check:8.63799	rejected
P:8.58242	rejected
(:8.54746	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearC

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearC
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <ClearC>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "ClearC"))))
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  ClearC
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: ClearC
LSP: Generating Completions for prefix: ClearC
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "riteria"
root ::= completions

Top 20 Logits:
riteria:22.9399
riter:13.3307
rit:12.7954
 criteria:12.1544	rejected
ri:10.4999
ria:10.1481	rejected
rea:9.6343	rejected
andid:9.49917	rejected
ategories:9.34044	rejected
rite:9.20898
li:9.14366	rejected
ra:9.1362	rejected
Add:9.12251	rejected
rl:8.94105	rejected
ir:8.92632	rejected
rie:8.80064	rejected
R:8.61884	rejected
riority:8.58992	rejected
Re:8.51901	rejected
rypt:8.3292	rejected
rypto:8.24556	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <ClearCriteria>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (UpdatePassword(String) + ClearCriteria + AddCriterion((RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)) + RemoveCriterion((RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: ClearCriteria
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: ClearCriteria
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:19.3402
 ->:13.7329	rejected
 :13.3358
=>:12.9244

:12.4206
  :12.3411
                :12.2304
   :11.5597
    :11.5161
     :11.4564
      :11.4418
       :11.3451
        :11.3082
         :11.1136
          :11.0833
():10.9954	prefix accepted:(
 =:10.9209
 {:10.8026	rejected
 :=:10.7823	rejected
           :10.6739
            :10.642

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria =>

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria =>
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "calculateStrength" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 initial:16.9068
 (":15.7281	prefix accepted: (
 (:15.7281

:15.2982
 :14.3117
 m:13.199
 ([:12.7049	prefix accepted: (
 ?:12.5338	rejected
  :11.9961
 f:11.5218
 let:11.4113
                :11.3635
 ((:11.2303	prefix accepted: (
 ({:10.9824	prefix accepted: (
 (?:10.9496	prefix accepted: (
 [":10.8509	prefix accepted: [
 {:10.7911	rejected
 (*:10.743	prefix accepted: (
 "":10.6154
 ():10.5903
 [:10.8509

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)], (Weak + Moderate + Strong))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)], (Weak + Moderate + Strong))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "calculateStrength" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
f:15.0225
initial:14.06
m:13.7851
s:13.5207

:13.4584
 "",:11.2912	prefix accepted: ""
List:11.0434	rejected
?,:11.0379	rejected
string:10.786
String:10.6399	rejected
 f:10.4748
model:10.3568	rejected
 initial:9.8179
first:9.61009	rejected
Password:9.40401	rejected
 ?:9.35148	rejected
password:9.29711	rejected
hd:9.27517	rejected
p:9.24051
get:9.19603	rejected
<:9.18768	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <m>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)], (Weak + Moderate + Strong))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: m
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: m
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ax_int" | "eetsCriterion" | "eetsMinLength" | "etCriteria" | "in_int" | "od"
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= completions | new-tokens

Top 20 Logits:
.:13.9179	rejected
[:13.5602	rejected
.(:11.4699	rejected
#:11.4312	rejected
@:10.8467
0:10.4739	rejected
1:10.4438	rejected
 |:10.2571	rejected
(:10.2147
.[:9.89897	rejected
 #:9.8401	rejected
,:9.62041
^:9.47904	rejected
::9.38285
_:9.2888	rejected
 \:9.23944
 @:9.101
._:8.9879	rejected
|:8.97213	rejected
$:8.89364
~:8.86599	rejected
Rejected the highest logit candidate . with logit -inf

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model"); syn = (List (Unknown Internal))})))
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ ?
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model"); syn = (List (Unknown Internal))})))
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ ?
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ ?
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "calculateStrength" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
[:13.127
0:12.6851
1:12.5521
(:11.6739
2:10.6554
f:10.5863
.:10.415	rejected
Model:10.1045	rejected
s:9.94081
initial:9.82595
_:9.72196	rejected
Password:9.71497	rejected
3:9.58649
t:9.23128
.(:8.93107	rejected
<:8.90548	rejected
>:8.78614	rejected
->:8.71444	prefix accepted:-
((:8.56022	prefix accepted:(
{:8.53862	rejected
p:8.47725

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <0>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Integer literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = (List (Unknown Internal)); syn = Int})))
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: 0
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: 0
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-floatlit | extend-intlit
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= completions | new-tokens

Top 20 Logits:
,:14.3043
@:12.2138
 @:11.9843
.:11.7907
):11.1928
 |:10.913	rejected
::10.3294
).:10.0405	rejected
),:10.0399	prefix accepted:)
[:9.90706	rejected
 ,:9.69663
|:9.66339	rejected
)(:9.47923	prefix accepted:)
^:9.13008	rejected
 +:9.10696
 ::9.04429
.@:8.99212	prefix accepted:.
#:8.81247	rejected
:::8.6384
 :8.48053
@@:8.47153	prefix accepted:@

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model"); syn = (List (Unknown Internal))})))
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ ?
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model"); syn = (List (Unknown Internal))})))
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ ?
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ ?
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "calculateStrength" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
1:14.8232
2:14.2642
0:12.5187
3:12.1648
[:11.7188
s:10.4287
(:10.0431
,:9.75749	rejected
4:9.73959
):9.70179	rejected
[]):9.64285	prefix accepted:[]
m:9.58915
initial:9.40445
We:9.29085
n:9.06454
5:8.77486
-:8.60406
Clear:8.52901
Str:8.51898
Re:8.49309
[]:9.64285

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <2>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Integer literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = (List (Unknown Internal)); syn = Int})))
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: 2
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: 2
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-floatlit | extend-intlit
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= completions | new-tokens

Top 20 Logits:
):15.4365
,:13.9142
@:12.5733
),:11.3784	prefix accepted:)
)::11.3044	prefix accepted:)
)(:11.0867	prefix accepted:)
 @:10.7999
).:10.7589	rejected
:::10.4233
 ):10.214
::10.1457
 +:10.1336
 ::9.9908
 |:9.91965	rejected
 -:9.68186
 ,:9.41679
.:9.24208
);:9.17364	prefix accepted:)
 :::9.05206
 :=:9.03285	prefix accepted: :
|:8.8786	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:17.1421
 :14.2349
  :14.0837
 (*:14.0023	prefix accepted: (
 //:13.6442	prefix accepted: /
 #:13.6041	rejected
 @:13.4743
@:13.1982
                :13.1349
    :12.7778
   :12.6879
#:12.2606	rejected
 ::12.2303
 in:12.0572	rejected
      :11.9735
     :11.8472
            :11.5677
 |:11.5677
:::11.5577
        :11.4065
 --:11.3737	prefix accepted: -

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)


LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 :20.3561
  :17.9781
    :16.9518

:16.3827
   :15.9031
      :15.4293
                :15.3936
        :14.6756
     :14.57
	:14.2484	rejected
|:14.1106
            :14.0288
       :13.9322
          :13.9305
(*:13.2822	prefix accepted:(
              :13.2276
#:13.0375	rejected
 |:12.8604
         :12.4237
               :12.3202
             :12.2245

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
 

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
 
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:21.4593
 #:16.1707	rejected
 (*:15.0652	prefix accepted: (
 //:14.4141	prefix accepted: /
 ||:14.0477	prefix accepted: |

:13.5852
 /*:13.2634	prefix accepted: /
 ##:12.7461	rejected
 --:12.2345	prefix accepted: -
 /:14.4141
 |\:12.0589	prefix accepted: |
 *:11.9191
 \:11.8671
 <:11.8337
 ###:11.799	rejected
 ///:11.5111	prefix accepted: /
 (**:11.4824	prefix accepted: (
 ---:11.1994	prefix accepted: -
 (:15.0652
 ...:10.9639	rejected
 -:12.2345

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  |

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  |
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 _:15.6991
 _,:15.2342	prefix accepted: _
 (:14.4553
 m:14.4287
 p:13.3656
 model:13.29
 password:13.1844
 ((:12.2475	prefix accepted: (
 (_:11.9911	rejected
 a:11.5361
 x:11.4275
 old:11.0998
 s:10.8787
 :10.4899
 initial:10.2536
 pm:10.1816
 ":10.1495
 l:10.0805
 [:9.95934
 xs:9.93575
 c:9.84653

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Wildcard
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Wildcard
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: _
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: _
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
 ,:17.7129
@:12.0001	rejected
 @:11.975	rejected
model:11.7601	rejected
 :::11.1335	rejected
 :11.0094
 +:10.856	rejected
 as:10.8492	rejected
m:10.7351	rejected
 _,:10.5087	rejected
 ::10.2644	rejected
::10.1136	rejected
  :10.0564
_,:10.0383	rejected
:::9.93393	rejected
,:9.46389
 m:9.10788	rejected
   :8.99271
+:8.77368	rejected
 ->:8.77283	rejected
 model:8.72267	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ ,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ ,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: ((String, [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)], (Weak + Moderate + Strong)), (UpdatePassword(String) + ClearCriteria + AddCriterion((RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)) + RemoveCriterion((RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar))))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: ((String, [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)], (Weak + Moderate + Strong)), (UpdatePassword(String) + ClearCriteria + AddCriterion((RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)) + RemoveCriterion((RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar))))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 Add:17.7853
 Remove:15.2127
 Update:15.1466
 (:12.2823
 _:12.2822
Add:11.6431
 Action:11.2748	rejected
 :11.256
Update:10.1389
(:9.55011
 Re:9.29074
 add:9.29058
Remove:9.20011
 (_:9.05333	rejected
 Rem:8.97216
 Set:8.93315	rejected
 action:8.93277
  :8.92722
 Min:8.73723
 _,:8.59361	prefix accepted: _
 x:8.5401

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , Add

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , Add
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Add>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "Add"))))
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Add
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Add
LSP: Generating Completions for prefix: Add
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Criterion"
root ::= completions

Top 20 Logits:
C:19.0075
(:11.9399	rejected
(_:10.3446	rejected
_:10.3398	rejected
Password:9.92832	rejected
c:9.88145	rejected
Re:9.67006	rejected
Action:9.55726	rejected
 C:8.8116	rejected
To:8.43856	rejected
All:8.36047	rejected
New:8.27671	rejected
 criteria:8.07526	rejected
 criter:7.97132	rejected
Pass:7.90526	rejected
 (:7.75187	rejected
 _:7.74201	rejected
Min:7.71719	rejected
Required:7.67293	rejected
Or:7.63346	rejected
Upper:7.35617	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddC

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddC
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <AddC>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "AddC"))))
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  AddC
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: AddC
LSP: Generating Completions for prefix: AddC
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "riterion"
root ::= completions

Top 20 Logits:
riter:23.949
riteria:15.0006	rejected
rit:13.8914
rier:12.5845	rejected
iter:11.7591	rejected
rer:11.5343	rejected
 criter:10.1912	rejected
rimin:9.9714	rejected
ri:9.92293
ron:9.89647	rejected
andid:9.78803	rejected
rt:9.78556	rejected
rite:9.72361
oder:9.53336	rejected
ategor:9.46811	rejected
rior:9.33275	rejected
ertain:9.23944	rejected
urer:9.22967	rejected
oter:9.03764	rejected
ru:8.8636	rejected
(:8.80211	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriter

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriter
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <AddCriter>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "AddCriter"))))
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  AddCriter
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: AddCriter
LSP: Generating Completions for prefix: AddCriter
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ion"
root ::= completions

Top 20 Logits:
ion:25.9285
on:13.3545	rejected
ions:12.2408	rejected
(:12.1671	rejected
ian:11.3787	rejected
ation:11.2118	rejected
io:11.1947
ium:11.1532	rejected
ition:11.1114	rejected
in:11.0391	rejected
iona:11.018	rejected
 ion:10.5868	rejected
ION:10.5539	rejected
iom:10.5141	rejected
i:9.93229
iation:9.66443	rejected
ione:9.42401	rejected
ia:8.90208	rejected
 (:8.69843	rejected
ior:8.43364	rejected

:8.36334	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <AddCriterion>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ((RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar) -> (UpdatePassword(String) + ClearCriteria + AddCriterion((RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)) + RemoveCriterion((RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar))))
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Var "Action");
           syn = (Arrow ((Var "PasswordCriteria"), (Var "Action")))})))
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  AddCriterion
Nature of error: Expecting type Action but got inconsistent type (PasswordCriteria -> Action)
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: AddCriterion
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: AddCriterion
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
(:17.8666
(_:13.8362	rejected
 c:12.2803	rejected
 (:10.8248
():10.5611	prefix accepted:(
 criter:10.5407	rejected
((:10.3486	prefix accepted:(
 =>:10.3153
 criteria:10.2582	rejected
 x:9.73759	rejected
(":9.50944	prefix accepted:(
 p:9.27715	rejected
 _:9.1883	rejected
([:9.05382	prefix accepted:(
 ->:8.75203	rejected
({:8.68053	prefix accepted:(
 new:8.6145	rejected
(@:8.5393	prefix accepted:(
(?:8.53164	prefix accepted:(
 a:8.47254	rejected
(*):8.44606	prefix accepted:(

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (UpdatePassword(String) + ClearCriteria + AddCriterion((RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)) + RemoveCriterion((RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (UpdatePassword(String) + ClearCriteria + AddCriterion((RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)) + RemoveCriterion((RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PasswordCriteria
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: PasswordCriteria
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "()" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= completions | new-tokens

Top 20 Logits:
c:16.9068
crit:13.6161
x:13.1408
Re:13.0031
new:12.8734
p:12.2567
Min:11.6759
password:11.4319
cr:11.4048
a:11.1383
pc:10.83
cri:10.3299
Add:10.2379
s:10.1459
rule:10.065
item:9.97962
n:9.9454
action:9.88271
value:9.81759
i:9.71715
policy:9.70482

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <c>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PasswordCriteria
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: PasswordCriteria
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: c
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: c
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
):15.7152
riter:15.1578
riteria:13.0663
rt:11.0253
1:10.5657
::10.4988	rejected
)=:10.3719	prefix accepted:)
),:10.1161
@:9.7158	rejected
)->:9.71339	prefix accepted:)
 ):9.38919
rit:9.30261
andid:9.16844
)::9.10739	prefix accepted:)
'):8.95137	rejected
_:8.92832
)):8.59342
0:8.4328
iter:8.42325
ru:8.33234
_):8.32274	prefix accepted:_

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c)

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (UpdatePassword(String) + ClearCriteria + AddCriterion((RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)) + RemoveCriterion((RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:18.7519
 when:14.7135	rejected
 :13.577
 if:13.4915	rejected
 ->:13.1405	rejected
 :::12.3818	rejected
  :12.314

:12.1081
:::11.6722	rejected
 :=:11.6541	rejected
   :11.114
 as:10.958	rejected
 |:10.5949	rejected
    :10.5813
     :10.0379
      :9.99564
 unless:9.98102	rejected
 ::9.88262	rejected
 {:9.45798	rejected
       :9.41638
 ||:9.38454	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 (:16.9562

:16.1359
 :15.6237
 let:14.9932
 if:14.3339
 ((:13.8203	prefix accepted: (
 List:13.815	rejected
  :13.3886
 {:13.2672	rejected
 c:13.0892
 (":12.9387	prefix accepted: (
 m:12.8339
 add:12.6555	rejected
 match:12.5789	rejected
 (*:12.4667	prefix accepted: (
 (_:12.3706	rejected
 ([:12.1002	prefix accepted: (
 ?:12.0065	rejected
 begin:11.9266	rejected
 [:11.7978
   :11.6891

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>


LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
   :20.0789
     :18.417
    :17.1967
       :15.8496
      :15.4336
  :14.9186
 :13.8565
         :13.8098
        :13.6426
	:13.2289	rejected
           :12.4419
          :12.3098
                :12.0522

:11.7113
             :11.3868
            :11.3466
               :10.8875
#:10.8519	rejected
              :10.6454
(:9.66126
if:9.26342

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
   

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
   
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 let:20.1122
 if:19.4992
 (:17.4547
 case:16.374
 List:16.1137	rejected
 begin:15.865	rejected
 match:15.8483	rejected
 ((:14.9313	prefix accepted: (
 (_:14.6828	rejected
 (*:14.6292	prefix accepted: (
 c:14.3126
 calculate:13.7448
 m:13.7338
 {:13.7302	rejected
 met:13.4863
 add:13.3893	rejected
 update:13.3728
 #:13.2851	rejected
 _:13.2463	rejected
 [:12.9428
 f:12.6561

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 criteria:14.1606
 c:12.8194
 new:12.6983
 (:11.5342
 cs:11.4843
 old:11.1503
 add:10.6514
 _:10.5437
 m:10.5225
 password:10.5173
 strength:10.3812
 crit:10.3095
 model:10.2812
 current:10.1062
 f:10.0022
 _,:9.96135	prefix accepted: _
 xs:9.85848
 p:9.73545
 criter:9.66888
 go:9.66731
 met:9.64261

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <criteria>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: criteria
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: criteria
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
 =:16.4249
::14.5598
_:13.7976
':13.4931	rejected
 ::13.1539
,:12.8575
'::11.9291	rejected
1:11.2639
=:11.1869
 :10.4865
',:10.1616	rejected
2:10.0777
:(:9.9645	prefix accepted::
List:9.9187
  :9.7735
@:9.7474	rejected
 :=:9.51209	prefix accepted: :
0:9.41211
With:9.21485
    :8.68286
     :8.61176

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria =

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria =
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 List:15.4329	rejected
 c:14.2338
 s:14.1126
 m:14.041
 f:13.6515

:12.714
 (:12.664
 :12.3246
 [:11.7781
 match:11.746	rejected
 met:11.6928
 if:11.3595
 add:10.1712	rejected
 list:10.1198	rejected
 case:9.92963
 ((:9.90814	prefix accepted: (
 @:9.60471	rejected
 _:9.53893	rejected
 ref:9.47819	rejected
 cons:9.44219	rejected
 get:9.32259	rejected
Rejected the highest logit candidate  List with logit -inf

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = s

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = s
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <s>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "s"))
  LSP: Info: Typing Context: {c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  s
Nature of error: Variable s is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: s
LSP: Generating Completions for prefix: s
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "in" | "qrt" | "trength_of" | "tring_compare" | "tring_concat" | "tring_contains" | "tring_length" | "tring_of_bool" | "tring_of_float" | "tring_of_int" | "tring_sub" | "tring_trim"
root ::= completions

Top 20 Logits:
nd:18.1534	rejected
@:12.1875	rejected
add:9.86446	rejected
igma:8.63186	rejected
':8.25414	rejected
#:8.22073	rejected
 @:8.20064	rejected
^:8.12599	rejected
list:8.11451	rejected
1:8.0732	rejected
_:7.95587	rejected
3:7.89006	rejected
(:7.85998	rejected
nt:7.78733	rejected
:::7.64475	rejected
ns:7.61661	rejected
@{:7.58371	rejected
(@:7.39467	rejected
noc:7.22492	rejected
2:7.19899	rejected
printf:7.14895	rejected
Rejected the highest logit candidate nd with logit -inf

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <sin>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (Float -> Float)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: sin
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: sin
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "in"
root ::= new-tokens

Top 20 Logits:
(:11.0355
on:10.4589	rejected
_:9.87762	rejected
@:9.80018
sert:9.72633	rejected
nd:9.56086	rejected
l:9.21362	rejected
 m:9.15449	rejected
m:8.89673	rejected
r:8.78482	rejected
 (:8.39884
((:8.37766	prefix accepted:(
.:8.37501	rejected
#:8.33827	rejected
cre:8.23239	rejected
tr:8.16819	rejected
cer:8.15182	rejected
 @:8.14912
og:8.05724	rejected

:8.0241
@{:7.79618	prefix accepted:@

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: @
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
1:15.0332
0:12.9501
2:12.4803
3:11.7328
m:11.2367
List:10.8523	rejected
(:10.6372
c:10.3472
s:10.0963
4:9.48706
f:8.99449
[:8.9368
t:8.89124
((:8.84564	prefix accepted:(
_:8.62196	rejected
n:8.48997
#:8.44676	rejected
 m:8.18974
5:7.99418
sin:7.96273
l:7.83463

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <1>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Integer literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = (List (Unknown SynSwitch)); syn = Int})))
  LSP: Info: Typing Context: {c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: 1
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: 1
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-floatlit | extend-intlit
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "in"
root ::= completions | new-tokens

Top 20 Logits:
 in:13.8503
@:11.857
 end:10.3794	rejected
(:10.2184
(*:10.1629	prefix accepted:(

:9.5395
:::9.44556
in:9.42402
 @:9.30116
 m:9.29564	rejected
 with:9.05416	rejected
of:9.00564	rejected
,:8.98514
 add:8.7431	rejected
.:8.70465
m:8.6874	rejected
::8.64062
 +:8.58307
 :8.31109
;:8.31091	rejected
(@:8.2433	prefix accepted:(

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:16.9067
 c:14.9362
 :14.7218
 if:13.3895
 List:13.3641	rejected
  :13.0719
 (:12.9864
 sin:12.28
 s:11.9174
    :11.8586
 (*:11.5827	prefix accepted: (
                :11.3822
 criteria:11.3519
 let:11.1504
 ((:11.0227	prefix accepted: (
 [:10.8855
      :10.6778
            :10.6218
     :10.605
 f:10.5952
   :10.5121

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in


LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
   :19.3824
     :18.7278
    :17.0618
       :15.6925
      :15.3402
  :14.1888
        :13.8501
	:13.3805	rejected

:13.0736
         :12.9809
 :12.5331
                :11.7488
          :11.4729
           :11.3834
            :10.5859
             :10.3563
#:10.1529	rejected
               :10.0249
(:9.85251
              :9.63259
(*:9.59748	prefix accepted:(

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
     

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
     
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 if:16.8944
 (:15.4286
 c:14.0145
 case:13.4386
 match:13.3317	rejected
 ((:13.1786	prefix accepted: (
 criteria:13.1631
 List:13.0854	rejected
 let:13.0708
 (*:12.4257	prefix accepted: (
 (_:12.1098	rejected
 m:12.0126
 _:11.3285	rejected
 s:11.2372
 begin:10.9032	rejected
 sin:10.8237
 ([:10.6175	prefix accepted: (
 [:10.5509
 @:10.3217	rejected
 {:10.3069	rejected
 #:10.0981	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)], (Weak + Moderate + Strong))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)], (Weak + Moderate + Strong))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
m:14.3889
f:12.5813
sin:12.1455
if:11.5309
s:11.5032

:11.2176
List:10.1159	rejected
c:10.0753
 m:9.76446
case:9.48073
cos:9.33539
hd:9.27722	rejected
password:8.90161	rejected
string:8.7422
((:8.70907	prefix accepted:(
x:8.61331	rejected
first:8.60654	rejected
_,:8.49812	rejected
 if:8.31344
p:8.23794
String:8.06852	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <m>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)], (Weak + Moderate + Strong))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: m
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: m
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ax_int" | "eetsCriterion" | "eetsMinLength" | "etCriteria" | "in_int" | "od"
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= completions | new-tokens

Top 20 Logits:
@:15.3754
 @:13.4663
,:11.638
@{:11.1245	prefix accepted:@
@@:11.0861	prefix accepted:@
[:9.98527	rejected
.:9.60955	rejected
^:9.41272	rejected
#:9.3839	rejected
&:9.27242
$:9.04691
!:8.97262
 &:8.86144
(:8.71189
:::8.65772
|:8.61976	rejected
 +:8.59598
):8.54241
::8.50728
+:8.39558
 -:8.3903

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model"); syn = (List (Unknown Internal))})))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m @ ?
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model"); syn = (List (Unknown Internal))})))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m @ ?
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m @ ?
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
0:15.0599
1:13.1892
(:12.528
2:12.0229
3:11.5779
c:10.9284
((:10.7345	prefix accepted:(
List:10.6968	rejected
[:10.2622
s:10.215
sin:9.761
f:9.29649
4:9.2827
(!:9.18103	prefix accepted:(
string:9.16374
if:9.12635
m:9.11508
 (:9.04883
_:8.75463	rejected
!:8.62358
{:8.58381	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <0>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Integer literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = (List (Unknown Internal)); syn = Int})))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: 0
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: 0
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-floatlit | extend-intlit
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= completions | new-tokens

Top 20 Logits:
@:15.3068
,:14.2544
 @:12.2724
):12.1485
,(:11.457	prefix accepted:,
)(:10.9364	prefix accepted:)
 +:10.1314
 ,:10.002
+:9.39679
@{:9.2869	prefix accepted:@
),:9.2082	prefix accepted:)
+(:9.08802	prefix accepted:+
@@:9.0589	prefix accepted:@
(:8.94121
::8.56419

:8.55527
 -:8.5514
^:8.31739	rejected
 (:8.24505
.:8.00314
(@:7.99854	prefix accepted:(

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model"); syn = (List (Unknown Internal))})))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ ?
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model"); syn = (List (Unknown Internal))})))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ ?
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ ?
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
3:13.6597
2:13.3865
calcul:13.131
(:12.6393
1:12.2515
str:11.1759
((:10.5438	prefix accepted:(
c:10.4926
List:10.4422	rejected
4:10.3661
0:9.94496
Str:9.7309
if:9.64078
[:9.53419
sin:9.4759

:9.21999
s:9.10191
 calculate:8.97237
Calcul:8.91838	rejected
 strength:8.9048
min:8.5675

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <1>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Integer literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = (List (Unknown Internal)); syn = Int})))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: 1
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: 1
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-floatlit | extend-intlit
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= completions | new-tokens

Top 20 Logits:
,:14.1272
@:13.3277
):12.9838
 +:12.8524
 @:12.3142
+:11.7876
)(:11.5128	prefix accepted:)
+(:10.6761	prefix accepted:+
),:10.5122	prefix accepted:)
(:10.1048
,(:9.88622	prefix accepted:,
::9.4522
:::9.30908
((:8.99355	prefix accepted:(
 ,:8.89595
 c:8.79232	rejected
|:8.72939	rejected
)[:8.71846	prefix accepted:)
:(:8.49489	prefix accepted::
[:8.42059	rejected
 -:8.16517

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([?], ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model");
           syn = (Prod [(List (Unknown Internal)); (Unknown Internal)])})))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1, ?
Nature of error: Expecting type Model but got inconsistent type ([?], ?)  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([?], ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model");
           syn = (Prod [(List (Unknown Internal)); (Unknown Internal)])})))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1, ?
Nature of error: Expecting type Model but got inconsistent type ([?], ?)  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1, ?
Nature of error: Expecting type Model but got inconsistent type ([?], ?)  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 c:14.6151
 criteria:12.4859
 List:12.3117	rejected
 sin:11.1568
 (:11.0648
 if:10.9196
 [:10.8862
 s:10.3273
 m:9.66224
 Add:9.6362

:9.46876
c:9.3066
 criter:9.11408
 Re:9.09968
 :9.07041
 add:9.0587	rejected
 strength:8.98566
 f:8.69247
 new:8.61444	rejected
 ((:8.53305	prefix accepted: (
 Min:8.08742

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <c>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1, c
Nature of error: Expecting type Model but got inconsistent type ([?], PasswordCriteria)  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: c
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: c
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "alculateStrength" | "ase " | "eil" | "os" | "riteria"
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= completions | new-tokens

Top 20 Logits:
:::17.7993
 :::15.9599
 @:11.6852
 +:11.4278
::11.2368
@:10.9342
):10.5947
 in:10.4272	rejected
 ::10.0172
,:10.0117
sin:9.84007	rejected
+:9.31714
.:9.20785	rejected
:(:8.3994	prefix accepted::
@@:8.34389	prefix accepted:@
 *:8.28648
 ^:8.28554	rejected
[:8.22368	rejected
*:8.16891
 <:8.16669
 -:8.06223

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >::<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Cons
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1, c :: ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Cons
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1, c :: ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1, c :: ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ::
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ::
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
c:16.4808
sin:14.3181
s:12.3314
@:12.227	rejected
List:12.1608	rejected
(:11.7183
crit:11.5439
 criteria:10.9303
m:10.4587
cri:10.235
[:10.0948
met:9.54914
cin:9.41699	rejected
(@:8.96918	prefix accepted:(
list:8.88633	rejected
filter:8.63217	rejected
<:8.47551	rejected
[]):8.3403	prefix accepted:[]
((:8.31326	prefix accepted:(
cos:8.27276
f:8.22292

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <sin>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: (Float -> Float)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (List (Unknown Internal));
           syn = (Arrow (Float, Float))})))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1, c :: sin
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: sin
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: sin
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
@:13.664
):12.3984
,:12.1148
(:11.5417
(@:10.6039	prefix accepted:(
[:9.2912	rejected
^:9.1325	rejected
!:8.89206
_:8.77592	rejected
.:8.4994	rejected
 @:8.41472
 ):8.1675
@{:8.10232	prefix accepted:@
::7.80702
((:7.76021	prefix accepted:(
)(:7.49002	prefix accepted:)
(*:7.47039	prefix accepted:(
!(:7.40403	prefix accepted:!
l:7.35231	rejected
2:7.33283	rejected
.@:7.32986	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1, c :: sin @ ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1, c :: sin @ ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1, c :: sin @ ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
1:18.1495
2:15.5385
3:14.8649
0:14.6491
4:12.7273
c:12.7237
(:11.8111
5:11.405
):11.1954	rejected
m:10.8136
crit:10.4916
6:10.4575
[:10.2125
List:10.1193	rejected
n:9.96836
,:9.86223	rejected
8:9.84155
s:9.75194
list:9.63018	rejected
9:9.6183
7:9.43257

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <1>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Integer literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = (List (Unknown Internal)); syn = Int})))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1, c :: sin @ 1
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: 1
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: 1
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-floatlit | extend-intlit
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= completions | new-tokens

Top 20 Logits:
):15.3665
,:14.8876
@:14.3826
 ):11.0886
 @:10.6207
)(:10.365	prefix accepted:)
)):10.1798
 ,:9.80996
),:9.6219	prefix accepted:)
@@:9.37192	prefix accepted:@
::9.2779
);:8.87993	prefix accepted:)

:8.7868
(:8.69109
:::8.65171
^:8.52045	rejected
,(:8.51583	prefix accepted:,
.:8.39409
)::8.12538	prefix accepted:)
 +:8.11011
 in:8.00073	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (?, [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)], (Weak + Moderate + Strong))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (?, [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)], (Weak + Moderate + Strong))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Strength
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 calculate:15.3284
 strength:12.3124
 sin:11.846
 Str:11.647
calcul:10.1731
 (:10.0097
 m:9.8864
 c:9.80982

:9.69465
 s:9.57463
 :9.52547
 We:9.39332
 ?:8.80931	rejected
 if:8.61331
 f:8.41768
 _):8.31694	rejected
 password:8.19226	rejected
 met:8.05236
 update:8.03379
 Calcul:7.95377	rejected
 Password:7.93135	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculate

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculate
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <calculate>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Strength
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "calculate"))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  calculate
Nature of error: Variable calculate is not bound  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: calculate
LSP: Generating Completions for prefix: calculate
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Strength"
root ::= completions

Top 20 Logits:
Str:21.0801
_:14.1826	rejected
Password:12.9617	rejected
@:12.0966	rejected
S:11.7925
):10.769	rejected
C:10.699	rejected
New:10.6451	rejected
(:10.4234	rejected
Ste:10.4095	rejected
St:10.0331
(@:9.58963	rejected
 Str:9.4618	rejected
 @:9.18348	rejected
Pass:9.05043	rejected
Strategy:8.98789	rejected
Length:8.94014	rejected
State:8.85974	rejected
P:8.62345	rejected
From:8.52217	rejected
()):8.51732	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStr

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStr
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <calculateStr>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Strength
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "calculateStr"))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  calculateStr
Nature of error: Variable calculateStr is not bound  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: calculateStr
LSP: Generating Completions for prefix: calculateStr
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ength"
root ::= completions

Top 20 Logits:
ength:22.5993
eng:13.9082
enth:12.3943	rejected
en:10.918
(:10.7428	rejected
@:10.6971	rejected
...:10.079	rejected
ong:9.76194	rejected
_:9.53338	rejected
ent:9.2515	rejected
n:9.21486	rejected
ng:9.12608	rejected
():9.10305	rejected
 @:8.86875	rejected
 strength:8.66593	rejected
..:8.54783	rejected
(@:8.21157	rejected
nth:8.14828	rejected
):8.13093	rejected

:8.0683	rejected
e:7.87048

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <calculateStrength>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Strength
  LSP: Info: Seft type: ((String, [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)]) -> (Weak + Moderate + Strong))
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Strength");
           syn =
           (Arrow (
              (Prod [(Var "Password"); (List (Var "PasswordCriteria"))]),
              (Var "PasswordStrength")))})))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  calculateStrength
Nature of error: Expecting type Strength but got inconsistent type ((Password, [PasswordCriteria]) -> PasswordStrength)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: calculateStrength
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: calculateStrength
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
(:17.2126
(@:14.6346	prefix accepted:(
((:13.9798	prefix accepted:(
@:12.369
(_:11.9549	rejected
 sin:11.4888	rejected
()):11.4728	prefix accepted:(
(!:11.4379	prefix accepted:(
):11.3648
 (:11.3505
(*:10.9623	prefix accepted:(
 @:10.8094
():10.5935	prefix accepted:(
(?:10.3068	prefix accepted:(
)(:10.2146	prefix accepted:)
(...:10.0945	rejected
#:9.91152	rejected
($:9.76783	prefix accepted:(
(":9.6026	prefix accepted:(
@@:9.56286	prefix accepted:@
!(:9.55854	prefix accepted:!

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Strength
  LSP: Info: Seft type: (Weak + Moderate + Strong)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Strength
  LSP: Info: Seft type: (Weak + Moderate + Strong)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
f:14.1908
sin:13.9488
m:13.7955
s:13.0353
password:10.6013	rejected
cos:10.5585
hd:10.3348	rejected
get:9.84823	rejected
string:9.76667
nth:9.54436	rejected
cin:9.50862	rejected

:9.47036
p:9.44729
out:9.3346	rejected
n:9.27699
String:9.24012	rejected
t:9.15641
List:9.15186	rejected
c:9.10071
Password:8.88993	rejected
str:8.6787

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <m>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Seft type: (String, [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)], (Weak + Moderate + Strong))
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana = (Prod [(Var "Password"); (List (Var "PasswordCriteria"))]);
           syn = (Var "Model")})))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type (Password, [PasswordCriteria]) but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: m
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: m
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ax_int" | "eetsCriterion" | "eetsMinLength" | "etCriteria" | "in_int" | "od"
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= completions | new-tokens

Top 20 Logits:
@:16.7077
 @:12.3126
@@:11.3252	prefix accepted:@
.:10.7443	rejected
,:10.6884
@{:10.4413	prefix accepted:@
^:10.4017	rejected
#:10.3633	rejected
.@:10.3183	rejected
[:9.93388	rejected
$:9.55458
):9.35932
&:9.31291
!:9.19978
f:9.13834	rejected
\:9.13052
(:9.10978
*:8.95113
':8.80737	rejected
%:8.7964	rejected
|:8.69668	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana = (Prod [(Var "Password"); (List (Var "PasswordCriteria"))]);
           syn = (List (Unknown Internal))})))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m @ ?
Nature of error: Expecting type (Password, [PasswordCriteria]) but got inconsistent type [?]  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana = (Prod [(Var "Password"); (List (Var "PasswordCriteria"))]);
           syn = (List (Unknown Internal))})))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m @ ?
Nature of error: Expecting type (Password, [PasswordCriteria]) but got inconsistent type [?]  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m @ ?
Nature of error: Expecting type (Password, [PasswordCriteria]) but got inconsistent type [?]  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
0:18.7567
3:13.2099
1:13.0354
2:12.5759
f:11.8671
m:11.1118
4:10.989
(:10.8368
s:10.2704
sin:10.0951
_:9.8885	rejected
5:9.87197
6:9.79322
#:9.79161	rejected
n:9.76996
 :9.70098
9:9.65492
8:9.51084
,:9.29239	rejected
*:9.28743	rejected
i:9.26948

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <0>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Integer literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = (List (Unknown Internal)); syn = Int})))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: 0
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: 0
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-floatlit | extend-intlit
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= completions | new-tokens

Top 20 Logits:
,:16.8631
@:16.1926
 @:11.4456
 ,:11.2346
)):10.7651
,(:10.5931	prefix accepted:,
):10.4375
^:9.81309	rejected
)(:9.44232	prefix accepted:)
@@:9.36144	prefix accepted:@
.:8.77003
(:8.76836
::8.76597
 in:8.65981	rejected
s:8.54807	rejected
(@:8.40998	prefix accepted:(
(),:8.26501	prefix accepted:(
),:8.11994	prefix accepted:)
+:8.08916
#:8.07333	rejected
@{:8.05066	prefix accepted:@

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana = (Prod [(Var "Password"); (List (Var "PasswordCriteria"))]);
           syn = (List (Unknown Internal))})))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m @ 0 @ ?
Nature of error: Expecting type (Password, [PasswordCriteria]) but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana = (Prod [(Var "Password"); (List (Var "PasswordCriteria"))]);
           syn = (List (Unknown Internal))})))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m @ 0 @ ?
Nature of error: Expecting type (Password, [PasswordCriteria]) but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m @ 0 @ ?
Nature of error: Expecting type (Password, [PasswordCriteria]) but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
0:17.5208
2:16.8625
3:16.2493
1:15.9891
4:13.5854
5:12.3265
s:11.4233
6:11.2289
,:11.0317	rejected
-:10.777
n:10.5754
7:10.4932
(:10.3963
9:10.2923
m:10.2755
8:10.2423
):10.005	rejected
c:9.91661
[:9.71774
)):9.6528	rejected
new:9.60628	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <0>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Integer literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = (List (Unknown Internal)); syn = Int})))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type (Password, [PasswordCriteria]) but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: 0
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: 0
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-floatlit | extend-intlit
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= completions | new-tokens

Top 20 Logits:
,:17.3739
@:13.4003
)):12.5874
 ,:11.6045
)(:11.4984	prefix accepted:)
,(:11.2839	prefix accepted:,
 @:11.2639
):11.4984
::10.4842
),:9.85762	prefix accepted:)
 +:9.6679
.:9.29986
^:9.26211	rejected
 m:9.24524	rejected
 sin:9.2304	rejected
 in:9.19733	rejected
+:8.91942
(:8.81175
))):8.66451	prefix accepted:))
(),:8.61526	prefix accepted:(
 :8.60081

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Seft type: (?, [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Seft type: (?, [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [PasswordCriteria]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 sin:15.1313
 m:13.4135
 criteria:12.6224
 c:12.0952
 criter:10.1488
 s:10.0431
 (:9.99889
c:9.72024
 [:9.70471
sin:9.56728
 List:9.55853	rejected
 new:8.89168	rejected
 list:8.13697	rejected
 crit:8.11382
 :8.02218
 f:7.80369
m:7.78676

:7.5958
 cin:7.51111	rejected
 in:7.30206
 add:7.11316	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <sin>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [PasswordCriteria]
  LSP: Info: Seft type: (Float -> Float)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (List (Var "PasswordCriteria"));
           syn = (Arrow (Float, Float))})))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: sin
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: sin
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
@:17.166
)):14.4375
 @:11.1258
):10.8913
@{:10.4455	prefix accepted:@
(:10.4154
@@:10.2599	prefix accepted:@
^:10.2593	rejected
(@:10.0076	prefix accepted:(
_:9.48662	rejected
)(:9.15759	prefix accepted:)
*:9.09662
2:9.06797	rejected
$:9.02137
1:8.70753	rejected
),:8.6668	prefix accepted:)
[:8.54685	rejected
.:8.43947	rejected
#:8.35625	rejected
<:8.35518
 :8.3531

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [PasswordCriteria]
  LSP: Info: Seft type: [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [PasswordCriteria]
  LSP: Info: Seft type: [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [PasswordCriteria]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
1:19.9288
2:16.8727
3:16.5771
0:16.254
4:13.366
)):13.0908	rejected
c:12.4817
new:12.3121	rejected
(:11.9008
5:11.6981
list:11.2072	rejected
[:10.9727
_:10.9028	rejected
9:10.7796
6:10.7537
 :10.6649
#:10.6497	rejected
8:10.5932
crit:10.4509
n:10.225
m:10.1423

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <1>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Integer literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [PasswordCriteria]
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (List (Var "PasswordCriteria")); syn = Int})))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: 1
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: 1
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-floatlit | extend-intlit
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= completions | new-tokens

Top 20 Logits:
)):17.8503
):13.5156
@:12.5191
),:12.1012	prefix accepted:)
 +:11.0389
))):10.2373	prefix accepted:))
 :10.2074
 @:10.1792
 ):9.75495
,:9.69621
+:9.60132
));:9.4796	prefix accepted:))
)),:9.4261	prefix accepted:))
)(:9.1418	prefix accepted:)
@@:8.92515	prefix accepted:@
 in:8.82346	rejected
))$:8.3934	prefix accepted:))
);:8.28687	prefix accepted:)
::8.16403
:::8.15404
(:8.09388

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)], (Weak + Moderate + Strong))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:18.3618
 :15.4587
  :15.0872
 end:14.7567
    :14.2036
      :13.663
 in:13.1748	rejected
                :12.691
 #:12.5564	rejected
   :12.4672
 (*:12.343	prefix accepted: (
        :12.2907
       :12.0998
 @:12.0869
     :12.0194
@:11.9643
          :11.8387
#:11.7853	rejected
            :11.6166
         :11.2956
end:11.178

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))


LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)], (Weak + Moderate + Strong))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 :19.8165
  :16.9931
      :16.7512
    :16.4912
   :15.5106

:15.4876
        :15.1111
       :14.7002
     :14.4551
                :14.2047
          :13.881
|:13.8097
            :13.7824
	:13.2757	rejected
#:13.1206	rejected
         :12.9941
 |:12.9638
end:12.2558
           :12.0816
              :12.0435
(*:11.8527	prefix accepted:(

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
 

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
 
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)], (Weak + Moderate + Strong))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:21.2409
 #:14.8673	rejected
 end:14.5183
 (*:13.8048	prefix accepted: (

:13.215
 //:12.9987	prefix accepted: /
 case:12.1275	rejected
 ...:12.0678	rejected
 <:11.8442
 /*:11.5654	prefix accepted: /
 /:12.9987
 ||:11.2433	prefix accepted: |
 *:11.0772
 ,:10.8694
 (:13.8048
 &:10.7175
 @:10.7031
 }:10.6902	rejected
 \:10.652
 .:10.6489	rejected
 if:10.5553	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  |

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  |
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 _:17.1036
 _,:14.7518	prefix accepted: _
 m:14.5087
 (:13.4292
 model:13.1139
 p:12.5786
 password:12.3029
 (_:11.9178	rejected
 ((:11.772	prefix accepted: (
 :11.1668
 a:10.9566
 x:10.3835
_:10.1841
 ,:9.6109	rejected
  :9.60835
 s:9.52516
 l:9.47097
 [:9.28055
 ":9.26452
 initial:9.25067
 mod:9.07447

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Wildcard
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Wildcard
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: _
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: _
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
 ,:18.5569
 :11.5679
 _,:10.9926	rejected
 @:10.2899	rejected
::10.1847	rejected
 ::9.97348	rejected
 Remove:9.8615	rejected
 Add:9.8554	rejected
,:9.84132
 Update:9.7893	rejected
 :::9.76001	rejected
@:9.63312	rejected
  :9.43735
m:9.43363	rejected
 m:8.79952	rejected
 ->:8.79726	rejected
 as:8.72036	rejected
_,:8.59035	rejected
,,:8.3836	prefix accepted:,
s:8.10474	rejected
 +:8.02009	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ ,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ ,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: ((String, [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)], (Weak + Moderate + Strong)), (UpdatePassword(String) + ClearCriteria + AddCriterion((RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)) + RemoveCriterion((RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar))))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: ((String, [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)], (Weak + Moderate + Strong)), (UpdatePassword(String) + ClearCriteria + AddCriterion((RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)) + RemoveCriterion((RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar))))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 Remove:19.9471
 Update:14.8936
Remove:13.2845
 Rem:12.9008
 :12.442
 Add:11.3925
 Re:11.3134
 (:11.0816
 _:10.9796

:10.9211
 Min:10.4414
 Action:10.4411	rejected
 Delete:10.3582	rejected
  :10.1304
 remove:10.0681
 Clear:9.27648
 Set:8.84789	rejected
	:8.65218	rejected
 Insert:8.51894	rejected
 action:8.5141
 R:8.38146

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , Remove

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , Remove
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Remove>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "Remove"))))
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  Remove
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Remove
LSP: Generating Completions for prefix: Remove
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Criterion"
root ::= completions

Top 20 Logits:
C:20.2208
c:11.1816	rejected
_:10.4419	rejected
(:10.1214	rejected
CR:9.99171	rejected
Action:9.7709	rejected
 C:9.75386	rejected
Password:9.35635	rejected
 criter:8.67153	rejected
Cr:8.55306
Re:8.26331	rejected
Spec:8.1055	rejected
Pass:8.022	rejected
From:7.99002	rejected
All:7.98471	rejected
(_:7.79677	rejected
Con:7.76192	rejected
Current:7.67034	rejected
crit:7.48041	rejected
Condition:7.45965	rejected
 criteria:7.40516	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveC

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveC
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <RemoveC>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "RemoveC"))))
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  RemoveC
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: RemoveC
LSP: Generating Completions for prefix: RemoveC
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "riterion"
root ::= completions

Top 20 Logits:
riter:22.2768
riteria:17.298	rejected
rit:15.5197
rimin:13.2257	rejected
 criter:12.7935	rejected
rier:12.3375	rejected
ru:10.9671	rejected
oder:10.9004	rejected
iter:10.8861	rejected
utor:10.8476	rejected
ri:10.8005
rior:10.7738	rejected
ron:10.7644	rejected
rypt:10.7269	rejected
rer:10.3531	rejected
rt:10.3339	rejected
utter:10.0841	rejected
oter:10.0131	rejected
irit:9.88309	rejected
orer:9.53687	rejected
ategor:9.51671	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriter

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriter
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <RemoveCriter>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "RemoveCriter"))))
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  RemoveCriter
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: RemoveCriter
LSP: Generating Completions for prefix: RemoveCriter
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ion"
root ::= completions

Top 20 Logits:
ion:23.557
ation:14.9302	rejected
io:14.8595
iom:13.5298	rejected
ition:13.1755	rejected
ions:12.6098	rejected
on:12.4617	rejected
ian:11.8712	rejected
ium:11.5598	rejected
i:11.4131
iation:11.201	rejected
ION:11.1153	rejected
 ion:11.0779	rejected
in:10.9548	rejected
ia:10.8316	rejected
iona:10.4105	rejected
ione:10.3309	rejected
(:10.2493	rejected
tion:10.0268	rejected
ioni:9.80335	rejected
ino:9.75725	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <RemoveCriterion>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ((RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar) -> (UpdatePassword(String) + ClearCriteria + AddCriterion((RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)) + RemoveCriterion((RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar))))
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Var "Action");
           syn = (Arrow ((Var "PasswordCriteria"), (Var "Action")))})))
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  RemoveCriterion
Nature of error: Expecting type Action but got inconsistent type (PasswordCriteria -> Action)
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: RemoveCriterion
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: RemoveCriterion
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
(:20.0153
(_:14.3901	rejected
 (:13.2344
((:13.0056	prefix accepted:(
 c:11.2068	rejected
({:10.986	prefix accepted:(
(@:10.9052	prefix accepted:(
 ->:10.8044	rejected
([:10.6852	prefix accepted:(
():10.6554	prefix accepted:(
 =>:10.5527
(":10.3859	prefix accepted:(

:10.2105
::10.1696	rejected
(':10.0132	prefix accepted:(
(::9.94135	prefix accepted:(
(?:9.92979	prefix accepted:(
($:9.70804	prefix accepted:(
(*:9.49788	prefix accepted:(
?(:9.34687	rejected
(*):9.22431	prefix accepted:(

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (UpdatePassword(String) + ClearCriteria + AddCriterion((RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)) + RemoveCriterion((RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (UpdatePassword(String) + ClearCriteria + AddCriterion((RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)) + RemoveCriterion((RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PasswordCriteria
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: PasswordCriteria
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "()" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= completions | new-tokens

Top 20 Logits:
c:18.1801
Re:14.3856
r:13.6627
rc:13.467
Min:13.2664
crit:12.5522
x:12.4437
Remove:12.2699
cr:11.744
Rem:11.3776
rm:11.2596
i:11.172
p:11.1574
remove:11.1393
s:10.9777
to:10.933
rem:10.9008
cri:10.5856
old:10.5855
R:10.4219
min:10.2479

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <c>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PasswordCriteria
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: PasswordCriteria
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: c
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: c
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
):18.4855
'):14.0607	rejected
riteria:13.9313
::13.0785	rejected
riter:12.5523
_:12.4353
2:12.3345
)::11.8562	prefix accepted:)
),:11.6033
)->:11.2242	prefix accepted:)
1:11.1506
_):10.9719	prefix accepted:_
)=:10.9228	prefix accepted:)
 ):10.8638
@:10.7911	rejected
)':10.7768	prefix accepted:)
':10.6859	rejected
,:10.1252
0:10.0654
To:10.0374
rt:10.0289

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c)

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (UpdatePassword(String) + ClearCriteria + AddCriterion((RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)) + RemoveCriterion((RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:20.0816
 :13.972
 ->:13.8528	rejected

:13.076
 :=:12.653	rejected
 in:11.9062	rejected
 when:11.8847	rejected
  :11.642
 :::11.183	rejected
	:10.2169	rejected
=>:10.2068
    :10.2051
 as:10.1908	rejected
 if:9.90482	rejected
 ::9.70276	rejected
   :9.6354
 &&:9.34277	rejected
 where:9.27224	rejected
 |:9.23747	rejected
 {:9.19089	rejected
 =:9.1818

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:19.1751
 :16.9814
  :15.6556
 (:15.003
    :14.2689
      :13.5628
                :13.148
 (*:12.9697	prefix accepted: (
   :12.8619
        :12.7816
       :12.5021
 let:12.3847
          :12.2054
            :12.1981
         :12.1287
 update:12.0511
     :12.0491
	:11.9966	rejected
 {:11.8881	rejected
 m:11.6549
              :11.4764

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>


LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
   :19.1522
    :16.583
     :16.4834
  :15.4004
       :14.5348
      :14.3684
 :13.7441
	:12.4416	rejected
         :12.1558
        :12.0294

:11.547
let:11.3251
#:10.9268	rejected
                :10.7558
           :10.6522
          :10.6094
            :9.78609
             :9.75292
(:9.61712
(*:9.32059	prefix accepted:(
               :9.30733

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
    

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
    
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 let:18.7086
 (:16.8423
 if:15.749
 case:14.7635
 List:14.7509	rejected

:14.2841
 ((:14.0449	prefix accepted: (
 (*:13.6149	prefix accepted: (
 (_:13.4892	rejected
	:13.4311	rejected
 match:12.9763	rejected
 begin:12.7023	rejected
 m:12.6737
 #:12.6694	rejected
 update:12.5616
 filter:12.4426	rejected
 _:12.3489	rejected
 {:12.2829	rejected
 remove:12.2408	rejected
 sin:11.9936
 <:11.8001	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 criteria:14.9387
 new:11.7972
 crit:11.2246
 go:11.1488
 filtered:11.1352
 idx:10.4104
 remove:10.3938
 m:10.2531
 sin:10.0003
 (:9.9057
 filter:9.86923
 old:9.86078
 c:9.62561
 _:9.40242
 index:9.35455
 f:9.2829
 l:9.13132
 removed:9.09886
 remaining:8.9181
 not:8.90748
 has:8.88428

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <criteria>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: criteria
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: criteria
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
 =:18.1683
::15.0241
_:13.6364
':13.3323	rejected
 ::12.9893
=:12.422
 :12.2895
2:11.9334
,:11.7958
  :10.8621
1:10.4357
With:10.3589
 :=:9.78864	prefix accepted: :
S:9.45103
',:9.36127	rejected
'::9.30415	rejected
 @:9.16964	rejected
List:9.06934
Filter:8.98498
   :8.92826
0:8.88946

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria =

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria =
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 List:14.794	rejected
 s:13.5853
 filter:13.553	rejected
 sin:13.1321
 m:11.9154
 f:11.5317

:11.3923
 :11.2091
 (:10.5484
 remove:9.76125	rejected
 met:9.45663
 fun:9.37208
 list:9.35027	rejected
 Filter:9.15179	rejected
 c:8.91963
 [:8.85436
 fil:8.77885	rejected
 l:8.75872
 sans:8.16112	rejected
 fin:8.03301	rejected
 string:7.9416
Rejected the highest logit candidate  List with logit -inf

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = s

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = s
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <s>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "s"))
  LSP: Info: Typing Context: {c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  s
Nature of error: Variable s is not bound  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: s
LSP: Generating Completions for prefix: s
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "in" | "qrt" | "trength_of" | "tring_compare" | "tring_concat" | "tring_contains" | "tring_length" | "tring_of_bool" | "tring_of_float" | "tring_of_int" | "tring_sub" | "tring_trim"
root ::= completions

Top 20 Logits:
nd:13.8004	rejected
@:10.8649	rejected
filter:10.8119	rejected
ins:10.6743	rejected
if:10.1839	rejected
not:10.085	rejected
lin:9.94212	rejected
list:9.70089	rejected
inc:9.42335	rejected
in:9.32529
as:9.29702	rejected
is:9.12372	rejected
inn:9.05909	rejected
iz:9.03459	rejected
din:8.63677	rejected
lt:8.56798	rejected
g:8.55847	rejected
rem:8.48473	rejected
fi:8.42547	rejected
ift:8.38491	rejected
ip:8.38282	rejected
Rejected the highest logit candidate nd with logit -inf

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <sin>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (Float -> Float)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: sin
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: sin
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "in"
root ::= new-tokens

Top 20 Logits:
@:17.5114
 @:11.3634
 in:11.0655
^:10.7424	rejected
@{:10.5179	prefix accepted:@
(:9.97771
.:9.93843	rejected
(@:9.79324	prefix accepted:(
 at:9.57455	rejected
$:9.52599
::9.46682

:9.44485
[:9.43318	rejected
&:9.20069
 :9.19008
2:9.17494	rejected
#:8.99424	rejected
|:8.84716	rejected
_:8.83412	rejected
*:8.80915
!:8.74715

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: @
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
1:19.3924
2:15.5789
0:13.8398
3:13.2699
(:11.5773
4:11.1616
m:10.6044
!:10.548
c:10.4825
 :10.2097
s:10.1832
filter:10.1621	rejected
5:10.1487
List:10.1093	rejected
i:9.63317
list:9.52813	rejected
_:9.50994	rejected
((:9.476	prefix accepted:(
6:9.47072
[:9.40392
n:9.40218

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <1>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Integer literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = (List (Unknown SynSwitch)); syn = Int})))
  LSP: Info: Typing Context: {c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: 1
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: 1
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-floatlit | extend-intlit
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "in"
root ::= completions | new-tokens

Top 20 Logits:
 in:17.4562
@:13.4521
 @:13.1258
 and:12.9006	rejected
,:12.7637

:12.7195
 :12.6084
 -:12.1241
.:11.5281
in:11.5046
 filter:11.1777	rejected
;:11.1752	rejected
 &&:10.717
 |:10.4625	rejected
::10.305
  :10.1711
:::10.1103
 ~:10.0462	rejected
 end:10.0157	rejected
 :::10.0078
-:9.55314

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:18.9761
 :15.9401
  :15.0774
    :13.3401
      :13.2574
 (:13.2509
   :12.5132
                :12.3522
        :12.2594
     :12.1708
 List:12.0988	rejected
            :11.8536
          :11.7816
       :11.6617
	:11.5093	rejected
         :11.4738
 (*:10.95	prefix accepted: (
 let:10.8534
              :10.6059
           :10.5893
 ((:10.4872	prefix accepted: (

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in


LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
      :20.2974
       :18.2773
     :18.2415
    :16.5843
        :16.1289
   :14.8277
         :14.3744
  :14.1294
	:13.2664	rejected
          :12.8413
           :12.6177
 :12.4905

:11.6776
            :11.53
                :10.9012
             :10.6305
(:10.3278
 (:9.77144
               :9.48461
              :9.18149
#:8.92174	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
      

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
      
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 (:19.8221
 if:17.7441
 let:17.2188
 case:17.1034
 List:15.8903	rejected
 match:15.7331	rejected
 ((:15.2758	prefix accepted: (
 filter:14.655	rejected
 (*:14.1364	prefix accepted: (
 begin:14.0254	rejected
 sin:13.8722
 remove:13.736	rejected
 update:13.4752
 (_:13.4344	rejected
 m:13.1478
 list:13.1377	rejected
 s:12.9351
 try:12.5366	rejected
 find:12.3568	rejected
 go:12.1994	rejected
 un:12.0834	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)], (Weak + Moderate + Strong))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)], (Weak + Moderate + Strong))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
m:18.1287
 m:13.7834

:13.7068
sin:12.0453
s:11.9226
if:11.9083
f:11.5464
let:10.8332
n:10.2567
update:9.99607
match:9.78341	rejected
c:9.77507
case:9.72366
ms:9.66806	rejected
_,:9.49807	rejected
model:9.46249	rejected
met:9.40814
md:9.39543	rejected
 :9.33014
x:9.29451	rejected
List:9.28792	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <m>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)], (Weak + Moderate + Strong))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: m
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: m
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ax_int" | "eetsCriterion" | "eetsMinLength" | "etCriteria" | "in_int" | "od"
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= completions | new-tokens

Top 20 Logits:
@:18.8435
 @:12.8881
,:11.6077
@{:10.7793	prefix accepted:@
@@:10.1543	prefix accepted:@
^:9.91355	rejected
*:9.64406
(:9.25916
[:9.20432	rejected
0:9.19764	rejected
&:9.17915
(@:9.17583	prefix accepted:(
::8.89961
@":8.84198	prefix accepted:@
_:8.83145	rejected

:8.80952
$:8.66485
|:8.5987	rejected
1:8.5765	rejected
):8.55567
.:8.49271	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model"); syn = (List (Unknown Internal))})))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ ?
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model"); syn = (List (Unknown Internal))})))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ ?
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ ?
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
0:19.4426
2:12.8714
1:12.8655
3:11.9419
(:10.9765
 :10.4916
sin:10.1985
s:9.9846
_:9.64983	rejected
m:9.61605
i:9.60303
n:9.51734
4:9.30023
o:9.21377	rejected
$:9.10096	rejected
,:9.00782	rejected
*:8.95791	rejected
6:8.93861
@:8.92964	rejected
5:8.87463
9:8.83694

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <0>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Integer literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = (List (Unknown Internal)); syn = Int})))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: 0
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: 0
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-floatlit | extend-intlit
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= completions | new-tokens

Top 20 Logits:
@:19.0375
,:14.5586
 @:13.6623
 ,:10.5316
@@:10.4934	prefix accepted:@
0:10.0458
^:9.69592	rejected
@{:9.34178	prefix accepted:@
(@:9.28944	prefix accepted:(
|:8.95121	rejected
*:8.84162
#:8.79892	rejected
):8.7471
(:9.28944
.:8.52315
,(:8.47601	prefix accepted:,
&:8.35933
$:8.35755

:8.30411
::8.25738
.@:8.23972	prefix accepted:.

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model"); syn = (List (Unknown Internal))})))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ ?
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model"); syn = (List (Unknown Internal))})))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ ?
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ ?
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
2:19.8995
0:18.796
1:16.2054
3:14.5916
4:12.2404
(:12.0986
-:11.5107
,:11.3725	rejected
s:11.3293
5:11.0476
n:10.6771
6:10.4881
 :10.1714
7:10.1384
sin:10.1025
[:10.0755
8:9.98666
((:9.95397	prefix accepted:(
9:9.91273
_:9.73969	rejected
m:9.70034

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <2>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Integer literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = (List (Unknown Internal)); syn = Int})))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: 2
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: 2
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-floatlit | extend-intlit
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= completions | new-tokens

Top 20 Logits:
,:17.3676
@:12.9339
,(:12.5053	prefix accepted:,
):12.5018
 ,:12.0849
),:11.8312	prefix accepted:)
 @:10.314

:10.0659
)(:9.77909	prefix accepted:)
 in:9.64282	rejected
(:9.51914
 -:9.4907
 sin:9.41747	rejected
::9.36719
 (:9.22457
,,:9.00248	prefix accepted:,
 +:8.98876
3:8.85729
.:8.79748
 :8.7606
sin:8.67471	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([?], ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model");
           syn = (Prod [(List (Unknown Internal)); (Unknown Internal)])})))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, ?
Nature of error: Expecting type Model but got inconsistent type ([?], ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([?], ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model");
           syn = (Prod [(List (Unknown Internal)); (Unknown Internal)])})))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, ?
Nature of error: Expecting type Model but got inconsistent type ([?], ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, ?
Nature of error: Expecting type Model but got inconsistent type ([?], ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 List:16.2739	rejected
 filter:13.8593	rejected
 criteria:11.7277
 c:11.3493
 :11.2076

:11.095
 remove:11.0005	rejected
 (:10.742
 s:10.3872
 list:10.3778	rejected
 Filter:10.3357	rejected
 f:10.2987
 sin:10.2881
 m:9.89973
 met:9.70908
 [:9.36059
List:9.24286	rejected
 criter:9.03896
 l:8.22806
 Password:8.18036	rejected
 filtered:8.1072	rejected
Rejected the highest logit candidate  List with logit -inf

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,


LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, ?
Nature of error: Expecting type Model but got inconsistent type ([?], ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
       :18.7553
        :17.6956
         :16.0333
      :15.0869
          :13.7371
	:13.4664	rejected
     :12.8472
           :12.4175
   :12.2073
    :11.7233
                :11.6866
  :11.4879
            :11.4665
             :11.3731
              :11.0845
 :10.4231
               :10.2858

:10.0961
List:7.51173	rejected
(:7.43512
if:7.2405

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
       

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
       
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, ?
Nature of error: Expecting type Model but got inconsistent type ([?], ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 List:17.4444	rejected
 filter:13.9579	rejected
 (:12.2318
 if:11.9692
 met:11.454
 remove:11.3088	rejected
 f:11.1347
 s:10.9688
 case:10.9549
 list:10.7387	rejected
 c:10.5698
 m:10.5094
 criteria:10.47
 sin:10.3959
 Filter:10.3734	rejected
 let:10.2559
 [:10.2275
 ((:10.2092	prefix accepted: (
 match:10.2048	rejected
 #:9.92505	rejected
 (*:9.86968	prefix accepted: (
Rejected the highest logit candidate  List with logit -inf

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if ? then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], ?)
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 List:15.0897	rejected
 c:11.7769
 not:11.5882	rejected
 has:11.4018
 (:11.0041
 m:10.6274
 met:10.446
 meets:10.2665
 criteria:10.2544
 !:10.133
 contains:9.92785	rejected
 sin:9.81602
 f:9.78042
 string:9.65461
 list:9.32009	rejected
 is:9.24973
 meet:9.04286
 s:8.92386
 criter:8.6145
 :8.59999
 exists:8.47899	rejected
Rejected the highest logit candidate  List with logit -inf

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <c>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = Bool; syn = (Var "PasswordCriteria")})))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  c
Nature of error: Expecting type Bool but got inconsistent type PasswordCriteria  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], ?)
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: c
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: c
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "alculateStrength" | "ase " | "eil" | "os" | "riteria"
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "then"
root ::= completions | new-tokens

Top 20 Logits:
 ==:13.9922
 =:12.5949
 in:12.5466	rejected
 \:11.097
==:10.9127
 @:10.81
 ===:10.7666	prefix accepted: ==
 :::10.6827
:::10.6452
 !=:10.4823
@:10.3038
 IN:10.138	rejected
 <>:10.0397	prefix accepted: <
 <:10.0397
=:9.63634
 `:9.63223	rejected
 is:8.81298	rejected
#:8.73948	rejected
_:8.60795	rejected
::8.6065
 :8.58068

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c ==

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c ==
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >==<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Integer Equality
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == ? then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], ?)
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Integer Equality
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == ? then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], ?)
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PasswordCriteria
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == ? then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], ?)
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex or complete: ==
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ==
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "."
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
 Re:14.0121
 Min:13.2637
 m:13.1195
 s:11.53
 sin:11.4847
 (:10.972
 List:10.6094	rejected
 h:10.4329
 head:10.0362	rejected
 !:9.59323
 Remove:9.50682
 ?:9.06011	rejected
 @:9.05783	rejected
 list:9.01785	rejected
 t:8.91755
 f:8.80903
 :8.63977
 met:8.61576
 last:8.60791	rejected
 strength:8.55737
 min:8.52939

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == Re

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == Re
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Re>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PasswordCriteria
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "Re"))))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  Re
Nature of error: Constructor is not defined  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == Re then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], ?)
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Re
LSP: Generating Completions for prefix: Re
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "moveCriterion" | "quireLowercase" | "quireNumber" | "quireSpecialChar" | "quireUppercase"
root ::= completions

Top 20 Logits:
quire:23.2303
quired:15.612	rejected
q:15.3657
qu:13.8629
comm:12.3365	rejected
verse:11.6733	rejected
require:11.3912	rejected
peat:11.0607	rejected
ason:10.4181	rejected
ject:10.4089	rejected
qi:10.3114	rejected
ve:10.181	rejected
ql:10.088	rejected
quis:10.052	rejected
quer:9.90155	rejected
cipe:9.85693	rejected
levant:9.66758	rejected
qui:9.6377
que:9.5653	rejected
voke:9.55511	rejected
ady:9.52669	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == Require

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == Require
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Require>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PasswordCriteria
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "Require"))))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Require
Nature of error: Constructor is not defined  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == Require then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], ?)
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Require
LSP: Generating Completions for prefix: Require
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Lowercase" | "Number" | "SpecialChar" | "Uppercase"
root ::= completions

Top 20 Logits:
Upper:19.9858
Lower:18.08
Special:17.937
Number:17.5257
Length:14.6441	rejected
Min:14.5196	rejected
U:11.6326
Numbers:11.3161	rejected
Num:10.7524
Dig:10.4922	rejected
N:10.3573
Password:10.269	rejected
Let:10.1372	rejected
Spec:10.03
All:10.0161	rejected
High:9.84204	rejected
upper:9.77642	rejected
L:9.65354
 Upper:9.62971	rejected
Up:9.52923
Middle:9.50143	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUpper

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUpper
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <RequireUpper>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PasswordCriteria
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "RequireUpper"))))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  RequireUpper
Nature of error: Constructor is not defined  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUpper then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], ?)
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: RequireUpper
LSP: Generating Completions for prefix: RequireUpper
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "case"
root ::= completions

Top 20 Logits:
case:22.4065
Case:15.6146	rejected
cases:11.2398	rejected
cas:11.1271
 case:10.855	rejected
c:10.581
 then:10.4514	rejected

:10.4277	rejected
ase:10.4121	rejected
CASE:10.4098	rejected
ca:9.90806
 ||:9.77887	rejected
 :9.7279	rejected
Lower:9.41428	rejected
care:9.25211	rejected
cs:8.94591	rejected
C:8.90662	rejected
 &&:8.90103	rejected
 in:8.67185	rejected
():8.61845	rejected
cast:8.59861	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <RequireUppercase>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PasswordCriteria
  LSP: Info: Seft type: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], ?)
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: RequireUppercase
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: RequireUppercase
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "then"
root ::= new-tokens

Top 20 Logits:
 then:17.8936
 &&:15.9618

:15.8487
 :15.3749
 ||:15.2068	rejected
 \:13.967
 @:12.8328
  :12.0589
 /\:11.7288	prefix accepted: /
 or:11.5774	rejected
 in:11.4729	rejected
 and:11.3292	rejected
 #:11.0971	rejected
 &:11.0675
 ->:10.9021	prefix accepted: -
   :10.7613
::10.5867
@:10.4267
                :10.3599
 |:10.3322	rejected
 //:10.1977	prefix accepted: /

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], ?)
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 List:13.2767	rejected

:12.9074
 [:12.6002
 filter:11.7546	rejected
 criteria:11.3317
 remove:11.2566	rejected
 Re:11.1409
 :11.1297
 []:10.8569
 sin:10.837
 m:10.6389
 s:10.1993
 (:9.98134
 c:9.55992
 Remove:9.44428
 t:9.00747
 f:8.768
 Filter:8.69327	rejected
 has:8.51797
  :8.24153
 Min:8.226
Rejected the highest logit candidate  List with logit -inf

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then


LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], ?)
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
         :20.0989
          :16.796
           :16.7662
        :16.1847
       :14.9723
            :14.7829
             :14.2242
	:13.8994	rejected
                :13.3913
              :12.7659
               :12.7232
     :12.221
   :11.8918
  :11.8874
      :11.7937
    :10.7665

:10.7648
 :10.3077
#:9.29516	rejected
(*:8.53873	prefix accepted:(
(:8.53873

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
         

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
         
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], ?)
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 List:14.8474	rejected
 filter:12.9676	rejected
 [:12.6225
 if:11.6339
 remove:11.503	rejected
 Re:10.809
 let:10.7084
 []:10.6273
 (:10.5734
 criteria:10.488
 case:10.3994
 s:10.3642
 m:10.1886
 Filter:10.0125	rejected
 c:9.78199
 met:9.74183
 sin:9.73895
 fun:9.71487
 f:9.44522
 Remove:9.39957
 list:9.31981	rejected
Rejected the highest logit candidate  List with logit -inf

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <[ ]<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [?])
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [?])
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [?])
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-convex or complete: [
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: [
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "]"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
Re:14.2147
Min:11.906

:11.3987
 Re:10.8901
x:10.7084	rejected
 Min:10.0986
c:10.0735
@:9.42709	rejected
a:8.95403
min:8.92991
fun:8.68507
require:8.55841	rejected
 x:8.54488	rejected
Remove:8.45607
 c:8.31844
s:8.1653
 :8.07662
m:8.01404
p:7.9183
f:7.86583
sin:7.81022

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [Re

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [Re
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Re>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "Re"))))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  Re
Nature of error: Constructor is not defined  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then Re else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [?])
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Re
LSP: Generating Completions for prefix: Re
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "moveCriterion" | "quireLowercase" | "quireNumber" | "quireSpecialChar" | "quireUppercase"
root ::= completions

Top 20 Logits:
quire:22.6367
q:15.2341
qu:13.9132
verse:12.4038	rejected
comm:11.8328	rejected
require:11.7753	rejected
peat:11.4128	rejected
ve:11.2895	rejected
v:10.9417	rejected
quer:10.5364	rejected
quired:10.3592	rejected
que:10.2685	rejected
queue:10.1627	rejected
usable:10.0857	rejected
qi:9.99808	rejected
ason:9.95203	rejected
ach:9.91782	rejected
fer:9.88707	rejected
cipe:9.77102	rejected
levant:9.71908	rejected
quis:9.64179	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [Require

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [Require
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Require>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "Require"))))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  Require
Nature of error: Constructor is not defined  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then Require else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [?])
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Require
LSP: Generating Completions for prefix: Require
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Lowercase" | "Number" | "SpecialChar" | "Uppercase"
root ::= completions

Top 20 Logits:
Lower:21.87
Upper:17.4303
Special:16.5736
Number:16.5436
Min:14.4507	rejected
Length:14.4103	rejected
Numbers:12.485	rejected
Num:12.4555
U:12.2267
Dig:12.2011	rejected
L:11.8599
lower:11.1265	rejected
Non:10.9006	rejected
Up:10.8873
N:10.8267
 Lower:10.8022	rejected
Password:10.7487	rejected
No:10.6998	rejected
Long:10.3865	rejected
Let:10.3622	rejected
Re:10.1871	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLower

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLower
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <RequireLower>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "RequireLower"))))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  RequireLower
Nature of error: Constructor is not defined  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLower else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [?])
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: RequireLower
LSP: Generating Completions for prefix: RequireLower
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "case"
root ::= completions

Top 20 Logits:
case:21.5353
Case:17.5072	rejected
cas:12.9177
ca:12.3525
,:11.924	rejected
]:11.4179	rejected
CASE:11.2587	rejected
c:11.2135
cases:11.0857	rejected
 case:10.9067	rejected
(),:10.7207	rejected
(:10.4313	rejected
():10.4283	rejected
C:10.2038	rejected
;:10.1276	rejected
care:9.66685	rejected
cast:9.62525	rejected
..:9.51585	rejected
ase:9.23349	rejected
();:9.19994	rejected
...:9.19355	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <RequireLowercase>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-concave or complete: RequireLowercase
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: RequireLowercase
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "]"
root ::= new-tokens

Top 20 Logits:
,:17.041
]:15.1715
;:14.4256	rejected
(),:12.2002	prefix accepted:(

:12.004
(:12.2002
 |:11.252	rejected
@:11.049
 @:10.9058
():10.7981	prefix accepted:(
][:10.7648	prefix accepted:]
 \:10.7576
 ,:10.6757
],:10.6545	prefix accepted:]
](:10.6239	prefix accepted:]
(@:10.4221	prefix accepted:(
|:10.4215	rejected
(*:10.3171	prefix accepted:(
:::10.2686
].:10.1192	rejected
 ...:10.0492	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 Min:17.2465

:14.3961
 Re:13.9862
Min:13.194
 :12.5371
  :10.3937
 min:10.3894
 \:10.3406	rejected
 ...:10.0014	rejected
Re:9.87185
 m:9.66425
 c:9.58139
   :9.32004
 *:9.17929	rejected
 (:8.92749
 ..:8.54433	rejected
 Mod:8.41471
     :8.34014
 minimum:8.31248	rejected
                :8.26543
 Max:8.25109	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, Min

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, Min
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Min>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "Min"))))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Min
Nature of error: Constructor is not defined  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, Min else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Min
LSP: Generating Completions for prefix: Min
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "imumLength"
root ::= completions

Top 20 Logits:
imum:21.3052
im:13.0306
Length:12.6821	rejected
(:12.3854	rejected
um:12.3365	rejected
imal:10.661	rejected
ium:10.5256	rejected
in:10.3714	rejected
_:9.56353	rejected
imin:9.0361	rejected
.:9.00153	rejected
m:8.96054	rejected
...:8.95922	rejected
length:8.92394	rejected
,:8.74547	rejected
L:8.60186	rejected
 :8.58465	rejected
..:8.53244	rejected
Min:8.3012	rejected
 (:8.15873	rejected
imm:8.01384	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, Minimum

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, Minimum
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Minimum>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "Minimum"))))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  Minimum
Nature of error: Constructor is not defined  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, Minimum else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Minimum
LSP: Generating Completions for prefix: Minimum
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Length"
root ::= completions

Top 20 Logits:
Length:24.1153
length:14.3267	rejected
L:14.2635
Leg:13.7675	rejected
_:13.2682	rejected
(:13.2044	rejected
Len:11.4092
Password:11.2441	rejected
 L:11.221	rejected
Char:11.1897	rejected
 length:11.0601	rejected
l:10.9227	rejected
Character:10.7421	rejected
Lower:10.6881	rejected
8:10.6165	rejected
Number:10.4498	rejected
,:10.3551	rejected
LENGTH:10.1295	rejected
Upper:9.99698	rejected
Size:9.79804	rejected
Long:9.79504	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <MinimumLength>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (Int -> (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength else ?
Nature of error: Expecting type Model but got inconsistent type ([?], ?)
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: MinimumLength
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: MinimumLength
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "]"
root ::= new-tokens

Top 20 Logits:
(:19.0327
 :13.255
,:12.1475
 (:11.9846
(?:11.9481	prefix accepted:(
(),:11.6008	prefix accepted:(
(_:11.591	rejected
(@:11.5845	prefix accepted:(
((:11.3757	prefix accepted:(
(!:11.1775	prefix accepted:(
(":10.9678	prefix accepted:(
($:10.8545	prefix accepted:(
[:10.4174	rejected
 m:10.389	rejected
(...:10.3858	rejected
([:10.3682	prefix accepted:(
(*:10.2725	prefix accepted:(
]:10.1563
(-:9.8796	prefix accepted:(
.:9.85172	rejected
8:9.8474	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(?) else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(?) else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(?) else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
8:19.2096
6:15.0005
4:14.4931
m:13.6634
5:13.3078
sin:13.249
3:13.1422
7:12.7676
1:12.7334
9:12.4278
min:11.9368
0:11.7566
2:11.7317
c:10.8009
int:10.6085
length:10.3789	rejected
len:10.1373	rejected
x:10.0325	rejected
s:9.87349
default:9.69935	rejected
Int:9.34179	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <8>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Integer literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Integer literal
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: 8
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: 8
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-floatlit | extend-intlit
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= completions | new-tokens

Top 20 Logits:
),:20.443	prefix accepted:)
)]:16.324	prefix accepted:)
):20.443
),\:12.5625	prefix accepted:)
L:10.7786	rejected
.:10.704
*:10.6992
,:10.6949
).:10.4732	rejected
);:10.4563	prefix accepted:)
),(:10.3991	prefix accepted:)
 +:10.3711
],:10.1093	rejected
+:10.0193
)\:9.99235	prefix accepted:)
)];:9.9483	prefix accepted:)
 *:9.88923
 ),:9.82438	prefix accepted: )
 as:9.4872	rejected
.),:9.42225	prefix accepted:.
)::9.41457	prefix accepted:)
Rejected the highest logit candidate ), with logit -inf

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "]"
root ::= new-tokens

Top 20 Logits:

:13.7385
 ,:13.0898
],:13.0617	prefix accepted:]
 Re:12.4821	rejected
 \:12.376
 ...:11.6872	rejected
 |:11.6787	rejected
 @:11.3706
 :11.3009
 ]:11.2491
@:10.9034
].:10.7707	rejected
 ..:10.6279	rejected
:::10.3393
 +:10.2536
  :9.99825
 :::9.95518
 (*:9.90091	prefix accepted: (
][:9.89238	prefix accepted:]
                :9.28664
]):9.25257	prefix accepted:]

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "else"
root ::= new-tokens

Top 20 Logits:
 @:16.9309

:16.6095
:::14.1079
 :14.0073
 +:13.567
@:13.5558
 :::13.4784
 ++:13.2096
 else:13.1362
 \:13.0003
  :12.8194
 //:12.2363	prefix accepted: /
 ::12.1153
 in:12.0162	rejected
 #:11.2796	rejected
 ||:11.1683	rejected
   :11.1437
 |:11.0721	rejected
                :11.0606
++:10.6816
#:10.6808	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]


LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "else"
root ::= new-tokens

Top 20 Logits:
       :17.9298
        :14.8382
         :14.7463
     :14.2522
          :13.7994
           :13.1661
	:12.7503	rejected
   :12.6882
      :12.5836
            :12.3325
                :12.2797
             :12.1313
  :11.3041

:11.2745
              :11.1351
    :11.082
               :10.9749
 :10.6142
else:10.0683
#:9.55869	rejected
(*:8.89862	prefix accepted:(

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
       

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
       
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "else"
root ::= new-tokens

Top 20 Logits:
 else:20.7166
 elif:17.1279	rejected
 els:16.6543
 @:13.9163
 end:13.7344	rejected
 if:13.6511	rejected
 el:13.5066
 \:13.0684
 #:12.6148	rejected
 c:12.0475	rejected
 fi:11.4356	rejected
 (\:11.405	prefix accepted: (
 sin:11.3729	rejected
 Re:11.235	rejected
 (:11.405
 List:11.0341	rejected
 []:10.9713	rejected
 |:10.9389	rejected
 //:10.7391	prefix accepted: /
 ::10.7376
 (*:10.721	prefix accepted: (

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 if:15.0405

:14.668
 List:13.4866	rejected
 [:13.4212
 []:13.2325
 :13.0603
 [],:12.0951	prefix accepted: []
 sin:12.0793
 filter:11.9724	rejected
 c:11.5103
 m:11.2253
 (:11.1588
 criteria:10.7113
if:10.6234
  :10.4589
 s:10.3232
 remove:10.1689	rejected
 Filter:9.90864	rejected
                :9.58908
 ([:9.31508	prefix accepted: (
 case:9.28514

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if ? then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 c:17.4144
 List:13.3509	rejected
 sin:12.0932
 :12.0526

:12.0253
 (:11.3046
 m:11.2961
 has:11.2175
 not:10.8718	rejected
 meets:10.6557
 Re:10.5278
 !:10.511
 ...:10.3999	rejected
 length:10.1876	rejected
 meet:9.84554
 s:9.71157
 list:9.70656	rejected
 string:9.6012
 met:9.20833
 is:9.15767
 Sin:9.0942	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <c>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = Bool; syn = (Var "PasswordCriteria")})))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  c
Nature of error: Expecting type Bool but got inconsistent type PasswordCriteria  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: c
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: c
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "alculateStrength" | "ase " | "eil" | "os" | "riteria"
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "then"
root ::= completions | new-tokens

Top 20 Logits:
 ==:19.7198
==:14.6022
 =:14.3388
 !=:14.0195
 ===:12.7892	prefix accepted: ==
 :12.3357
::10.8777
 in:10.7701	rejected
=:10.4933
 >:10.4514

:10.4301
 <:10.4195
 >=:10.4129
 @:10.2934
 <>:9.93738	prefix accepted: <
 ~:9.69699	rejected
 -:9.68135
.:9.6474	rejected
 <=:9.60136
 is:9.56087	rejected
 ->:9.47099	prefix accepted: -

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c ==

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c ==
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >==<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Integer Equality
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == ? then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Integer Equality
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == ? then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PasswordCriteria
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == ? then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex or complete: ==
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ==
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "."
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
 Re:17.848
 Min:14.8159
 :12.1444
 Has:10.9788	rejected
 require:10.7349	rejected
Re:10.6752

:10.6118
 (:10.2517
 Lower:9.80886	rejected
 Max:9.59555	rejected
 min:9.58084
 [:9.53695
  :9.38661
 has:9.12543
Min:8.98077
 R:8.9431
 ":8.80774
 :8.30849	rejected
   :8.25205
 Upper:8.18153	rejected
 Res:8.16542	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == Re

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == Re
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Re>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PasswordCriteria
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "Re"))))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) end in
  LSP: Info: ALL errors:
Error in term:
  Re
Nature of error: Constructor is not defined  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == Re then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Re
LSP: Generating Completions for prefix: Re
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "moveCriterion" | "quireLowercase" | "quireNumber" | "quireSpecialChar" | "quireUppercase"
root ::= completions

Top 20 Logits:
quire:26.7593
quired:17.4517	rejected
q:15.5026
qu:15.0111
require:12.9014	rejected
con:12.1525	rejected
a:11.8237	rejected
voke:11.7778	rejected
asure:11.6028	rejected
verse:11.3415	rejected
verage:11.294	rejected
ak:10.8904	rejected
qi:10.8511	rejected
ason:10.7447	rejected
vere:10.6292	rejected
qa:10.5981	rejected
aque:10.4352	rejected
ve:10.3911	rejected
mediate:10.3226	rejected
e:10.244	rejected
ordinate:10.093	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == Require

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == Require
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Require>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PasswordCriteria
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "Require"))))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) end in
  LSP: Info: ALL errors:
Error in term:
  Require
Nature of error: Constructor is not defined  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == Require then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Require
LSP: Generating Completions for prefix: Require
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Lowercase" | "Number" | "SpecialChar" | "Uppercase"
root ::= completions

Top 20 Logits:
Lower:22.4263
Special:19.2635
Number:19.0762
Upper:17.0733
Min:15.5214	rejected
L:14.6868
lower:13.8307	rejected
Num:13.7361
U:13.6648
Dig:13.5424	rejected
Numbers:13.499	rejected
N:13.2151
 Lower:12.4313	rejected
LOW:12.4232	rejected
Non:12.3155	rejected
Spec:12.2146
Length:12.0989	rejected
Middle:11.8354	rejected
Long:11.7526	rejected
High:11.6758	rejected
Password:11.6521	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLower

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLower
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <RequireLower>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PasswordCriteria
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "RequireLower"))))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  RequireLower
Nature of error: Constructor is not defined  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLower then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: RequireLower
LSP: Generating Completions for prefix: RequireLower
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "case"
root ::= completions

Top 20 Logits:
case:21.1893
Case:16.5939	rejected
cas:12.7385
ca:12.7237
 case:11.8604	rejected
c:11.8302
ase:10.8677	rejected
cases:10.7408	rejected
cs:10.4157	rejected
CASE:10.4007	rejected

:10.0803	rejected
C:10.0403	rejected
cc:9.9789	rejected
cast:9.78156	rejected
care:9.74623	rejected
 :9.12309	rejected
 then:9.03787	rejected
ac:9.02228	rejected
ance:8.94963	rejected
rc:8.90725	rejected
sc:8.78385	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <RequireLowercase>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PasswordCriteria
  LSP: Info: Seft type: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: RequireLowercase
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: RequireLowercase
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "then"
root ::= new-tokens

Top 20 Logits:
 then:18.512
 :15.3118

:14.8964
 ||:12.8669	rejected
 &&:12.5005
  :10.846
 \:10.5704
 or:10.537	rejected
 the:10.5303
 than:9.8622	rejected
then:9.62666
 and:9.37167	rejected
 =>:9.27095	prefix accepted: =
 Then:8.99407	rejected
 ?:8.90895	rejected
   :8.86907
 ==:8.82755
 them:8.80345	rejected
 |:8.7091	rejected
 THEN:8.65544	rejected
 ->:8.60744	prefix accepted: -

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:19.7388
 :18.665
 [:15.8921
  :15.01
 []:13.4532
   :13.0238
        :13.0122
          :12.6879
                :12.5751
     :12.1763
    :12.1287
            :12.1173
[:12.0169
      :11.5428
           :11.2403
 Re:11.1643
	:10.953	rejected
              :10.9387
         :10.8558
       :10.8334
 c:10.4364

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then


LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
         :20.8335
          :18.4987
           :18.1086
        :17.8414
            :16.0487
       :15.3029
             :15.2037
	:15.0397	rejected
                :14.2248
               :13.943
              :13.8915
     :12.916
      :12.5326
   :12.4307
 :12.2033
  :12.105

:11.6737
    :11.0857
[:10.6365
#:9.55439	rejected
  :8.8521	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
         

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
         
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 [:19.9376
 []:15.7429
 List:15.1988	rejected
 Re:14.5181
 sin:13.861
 [(:13.8146	prefix accepted: [
 m:13.2728
 if:13.0904
 (:12.9455
 c:12.9162
 let:12.6356
 met:12.5198
 (*:12.406	prefix accepted: (
 meet:12.2901
 ([:11.8233	prefix accepted: (
 calculate:11.8049
 criteria:11.6678
 ...:11.6171	rejected
 s:11.5322
 [":11.411	prefix accepted: [
 [...]:11.4103	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <[ ]<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-convex or complete: [
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: [
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "]"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
Re:18.8593
Min:14.6532
Required:12.2717	rejected
 Re:12.2592

:12.2068
require:12.1478	rejected
Has:11.7459	rejected
has:11.1892
c:10.93
min:10.3675
Me:9.85096	rejected
Remove:9.59731
 :9.4131
 ]:9.06532	rejected
R:9.04952
@:8.80978	rejected
m:8.79569
Upper:8.78167	rejected
x:8.72688	rejected
re:8.70631	rejected
We:8.69576

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [Re

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [Re
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Re>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "Re"))))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  Re
Nature of error: Constructor is not defined  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then Re else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Re
LSP: Generating Completions for prefix: Re
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "moveCriterion" | "quireLowercase" | "quireNumber" | "quireSpecialChar" | "quireUppercase"
root ::= completions

Top 20 Logits:
quire:23.8651
qu:16.1762
q:15.5359
require:12.375	rejected
u:12.2019	rejected
quare:11.745	rejected
que:11.5919	rejected
a:11.528	rejected
qi:11.4953	rejected
qui:11.2841
quer:11.0868	rejected
quis:10.7665	rejected
query:10.6045	rejected
comm:10.3951	rejected
Q:10.2978	rejected
queue:10.2139	rejected
ac:9.96177	rejected
qa:9.76941	rejected
quired:9.75067	rejected
quier:9.7478	rejected
v:9.54275	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [Require

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [Require
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Require>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "Require"))))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  Require
Nature of error: Constructor is not defined  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then Require else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Require
LSP: Generating Completions for prefix: Require
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Lowercase" | "Number" | "SpecialChar" | "Uppercase"
root ::= completions

Top 20 Logits:
Upper:21.419
Special:16.6878
Lower:16.629
Number:16.0933
U:15.7032
Min:14.5779	rejected
C:12.9224	rejected
upper:12.7256	rejected
L:12.6025
Length:12.5225	rejected
Up:12.3451
High:11.6915	rejected
Other:11.4899	rejected
 Upper:11.4105	rejected
Numbers:11.3046	rejected
Num:11.1529
UP:10.9057	rejected
Cap:10.7704	rejected
Dig:10.7273	rejected
N:10.716
M:10.6751	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUpper

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUpper
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <RequireUpper>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "RequireUpper"))))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else ) end in
  LSP: Info: ALL errors:
Error in term:
  RequireUpper
Nature of error: Constructor is not defined  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUpper else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: RequireUpper
LSP: Generating Completions for prefix: RequireUpper
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "case"
root ::= completions

Top 20 Logits:
case:21.8246
Case:17.9303	rejected
cas:14.2144
ca:13.5701
c:13.0215
cases:12.3414	rejected
ase:12.1316	rejected
,:12.0171	rejected
C:11.833	rejected
CASE:11.7793	rejected
care:11.3107	rejected
cast:11.0275	rejected
Char:10.8343	rejected
cs:10.6152	rejected
ac:10.5858	rejected
cc:10.4661	rejected
L:10.2485	rejected
 case:10.0222	rejected
cache:9.94642	rejected
cade:9.67385	rejected
(:9.57453	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <RequireUppercase>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-concave or complete: RequireUppercase
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: RequireUppercase
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "]"
root ::= new-tokens

Top 20 Logits:
,:19.0518
 ,:12.9355
]:12.4987
 Min:11.846	rejected
(),:11.4436	prefix accepted:(
(:11.4436
 :10.7106
Min:10.2902	rejected
 Re:10.2703	rejected
;:9.88037	rejected
:::9.67628
,,:9.64547	prefix accepted:,
 |:9.63764	rejected
 :::9.59069
():9.43798	prefix accepted:(
 @:9.31783
@:9.22113
  :9.16733
::9.09337
],:9.05408	prefix accepted:]

:8.92279

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 Min:18.4804
 :13.8741
 Re:13.657
Min:13.1632
  :11.505

:11.3138
 Max:10.8719	rejected
 min:10.8474
   :10.0018
 ...:9.44556	rejected
 (:9.30975
 M:9.2809
 minimum:9.22503	rejected
 ":8.87338
 [:8.83154
 c:8.82131
 ,:8.80462	rejected
 m:8.78501
 Mod:8.74908
 Me:8.43261	rejected
 *:8.34841	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, Min

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, Min
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Min>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "Min"))))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  Min
Nature of error: Constructor is not defined  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, Min else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Min
LSP: Generating Completions for prefix: Min
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "imumLength"
root ::= completions

Top 20 Logits:
imum:21.5649
um:14.5448	rejected
im:14.3462
imal:12.0043	rejected
imate:11.635	rejected
ium:11.2905	rejected
m:10.8269	rejected
imin:10.7168	rejected
imeter:10.5847	rejected
Update:10.4817	rejected
in:10.0243	rejected
em:9.93354	rejected
u:9.81762	rejected
umin:9.58561	rejected
uminate:9.45272	rejected
min:9.42086	rejected
ima:9.3656	rejected
umeric:9.13033	rejected
umm:8.96514	rejected
 minimum:8.86043	rejected
ument:8.84	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, Minimum

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, Minimum
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Minimum>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "Minimum"))))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  Minimum
Nature of error: Constructor is not defined  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, Minimum else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Minimum
LSP: Generating Completions for prefix: Minimum
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Length"
root ::= completions

Top 20 Logits:
Length:22.693
L:15.366
length:14.2913	rejected
Lower:13.4837	rejected
Leg:13.4247	rejected
(:12.3011	rejected
Upper:12.0271	rejected
 L:11.6054	rejected
Left:11.4979	rejected
l:11.4669	rejected
Level:11.4011	rejected
_:11.3552	rejected
Let:11.0331	rejected
LENGTH:10.9321	rejected
Height:10.7238	rejected
Le:10.5776
Long:10.5196	rejected
Len:10.3693
C:10.335	rejected
 length:10.2672	rejected
Language:10.2344	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <MinimumLength>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (Int -> (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: MinimumLength
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: MinimumLength
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "]"
root ::= new-tokens

Top 20 Logits:
(:21.5901
 (:13.4577
 :12.4655
]:12.1986
():11.7038	prefix accepted:(
((:11.5877	prefix accepted:(
8:10.5627	rejected
[:10.2306	rejected
,:10.196
(_:10.107	rejected
(-:9.83436	prefix accepted:(
([:9.22357	prefix accepted:(

:9.19239
 ]:9.075
(?:9.04249	prefix accepted:(
(@:9.04178	prefix accepted:(
(":8.94233	prefix accepted:(
](:8.85282	prefix accepted:]
  :8.82005
s:8.74893	rejected
(),:8.71896	prefix accepted:(

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(?) else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(?) else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(?) else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
8:22.1806
6:16.4232
7:15.1747
4:15.1664
9:14.8094
5:14.6788
3:14.2578
1:14.1678
 :12.8633
2:12.7561
0:12.5049
c:12.0012
min:11.2909
s:11.0645
Re:11.0233
m:10.6254
e:10.2623
x:10.2464	rejected
n:10.2316
i:10.2126
?):10.0269	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <8>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Integer literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Integer literal
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: 8
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: 8
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-floatlit | extend-intlit
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= completions | new-tokens

Top 20 Logits:
)]:22.1158	prefix accepted:)
):22.1158
),:16.4581	prefix accepted:)
)];:13.1601	prefix accepted:)
 ):11.899
))]:11.7197	prefix accepted:))
)):11.7197
)](:11.0092	prefix accepted:)
);:10.7603	prefix accepted:)
,:10.6494
)|:10.3507	prefix accepted:)
]):10.0767	rejected
)*:9.95919	prefix accepted:)
)}:9.87449	prefix accepted:)
)":9.63733	prefix accepted:)
)\:9.48303	prefix accepted:)
)::9.47171	prefix accepted:)
)`:9.36336	prefix accepted:)
]:9.35624	rejected
.:9.1944
):9.16641	rejected
Rejected the highest logit candidate )] with logit -inf

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8)

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "]"
root ::= new-tokens

Top 20 Logits:
 ]:16.6492

:15.6672
],:15.3261	prefix accepted:]
]):14.3187	prefix accepted:]
 :14.0742
][:13.4035	prefix accepted:]
 @:13.3025
].:13.0259	rejected
  :12.9713
 |:12.6379	rejected
 \:12.4715
]:15.3261
   :11.9196
@:11.8017
 +:11.7704
    :11.462
     :11.4104
        :11.4074
                :11.3688
 ||:11.1935	rejected
          :11.1568

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ]

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ]
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "else"
root ::= new-tokens

Top 20 Logits:

:18.536
 :17.1283
  :14.793
          :13.852
   :13.5708
        :13.0313
    :12.9881
 @:12.7191
     :12.6513
 else:12.3605
                :12.2739
 end:11.9929	rejected
            :11.9486
else:11.7352
@:11.7043
           :11.7023
      :11.6998
       :11.2931
         :10.9578
             :10.8495
              :10.7875

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "else"
root ::= new-tokens

Top 20 Logits:

:21.7591
 else:15.3627
	:15.1673	rejected
 @:15.1614
 #:14.7166	rejected
 end:14.4328	rejected
 //:13.7257	prefix accepted: /
 \:12.4744
 (*:12.3594	prefix accepted: (
 *:12.1187
 +:11.5897
 elif:11.4364	rejected
 in:11.2945	rejected
 %:11.2337	rejected
3:11.2217	rejected
 ):11.1929	rejected
 ///:11.1686	prefix accepted: /
1:11.1118	rejected
0:10.9937	rejected
 |:10.9693	rejected
4:10.8118	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 


LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "else"
root ::= new-tokens

Top 20 Logits:
       :18.1383
     :15.0916
        :14.1825
          :13.7157
   :13.4782
         :13.3337
	:13.0525	rejected
      :12.8068
    :12.4939
            :12.319
else:12.1818
           :12.1692
                :12.0776
 :11.7883
  :11.7255
             :11.628

:10.873
              :10.8506
               :10.831
#:9.85819	rejected
end:9.44979	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
       

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
       
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "else"
root ::= new-tokens

Top 20 Logits:
 else:20.1749
 elif:16.0077	rejected
 end:15.9897	rejected
 els:14.895
 #:13.6372	rejected
 @:13.1585
 el:13.1142
 ...:12.9748	rejected
 fi:12.8128	rejected
 (*:12.5863	prefix accepted: (
 []:12.288	rejected
 if:12.2483	rejected
 \:11.6778
 es:11.6766	rejected
 //:11.5684	prefix accepted: /
 |:11.5254	rejected
 sin:11.5006	rejected
 List:11.4498	rejected
 [:11.4433	rejected
 m:11.4163	rejected
 c:11.2703	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 if:15.8663

:14.3574
 [:13.7278
 :13.5349
 []:13.5215
 criteria:13.0325
 sin:12.9457
 List:12.5551	rejected
 m:11.5052
  :11.2907
 [],:11.2845	prefix accepted: []
 s:11.0867
 (:10.5596
 c:10.5414
 let:10.4127
                :10.3943
 (*:9.85012	prefix accepted: (
    :9.67458
   :9.64834
 _:9.5501	rejected
[:9.41967

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if ? then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 c:16.878
 List:12.2877	rejected
 :11.6284
 (:11.1799
 sin:11.0184

:10.7451
 meets:10.7152
 m:10.5386
 is:10.4721
 s:10.4375
 has:10.2272
 string:10.1849
 meet:9.82968
 not:9.80697	rejected
 case:9.80617
 int:9.5391
 Int:9.38691	rejected
 eq:9.3328	rejected
 f:9.23021
 Re:9.20174
 min:9.18635

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <c>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = Bool; syn = (Var "PasswordCriteria")})))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  c
Nature of error: Expecting type Bool but got inconsistent type PasswordCriteria  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: c
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: c
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "alculateStrength" | "ase " | "eil" | "os" | "riteria"
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "then"
root ::= completions | new-tokens

Top 20 Logits:
 ==:19.469
 =:15.7464
==:13.9777
 !=:12.7296
 >=:12.208
 :12.1182
.:11.9813	rejected
 ===:11.9377	prefix accepted: ==
 <:11.895
 =~:11.5977	prefix accepted: =
 >:11.5078
 in:11.2279	rejected
 is:11.1652	rejected
@:11.0683
 @:10.9895
 <=:10.9452
 instanceof:10.8517	rejected
=:10.439
::10.2792
 <>:10.1638	prefix accepted: <

:10.101

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c ==

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c ==
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >==<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Integer Equality
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == ? then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Integer Equality
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == ? then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PasswordCriteria
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == ? then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex or complete: ==
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ==
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "."
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
 Min:16.4303
 Re:15.4966
 (:14.5968
 :11.8322
Min:11.2905
 min:10.0838
 Max:10.0173	rejected

:8.74246
 Remove:8.67835
  :8.60858
 Mod:8.44942
 [:8.43542
Re:8.38495
 require:8.30703	rejected
 Number:8.30001	rejected
 minimum:8.2307	rejected
 Has:8.19956	rejected
 Minor:8.19665	rejected
 M:8.16512
(:8.01645
 Lower:7.90381	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == Min

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == Min
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Min>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PasswordCriteria
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "Min"))))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) end in
  LSP: Info: ALL errors:
Error in term:
  Min
Nature of error: Constructor is not defined  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == Min then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Min
LSP: Generating Completions for prefix: Min
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "imumLength"
root ::= completions

Top 20 Logits:
imum:20.3097
im:14.5692
um:14.0626	rejected
in:13.0495	rejected
ium:12.5437	rejected
m:11.2543	rejected
(:11.11	rejected
Length:10.9409	rejected
imal:10.9398	rejected
ima:9.87284	rejected
imm:9.60502	rejected
u:9.51063	rejected
imin:9.29951	rejected
L:9.21608	rejected
_:8.92835	rejected
umin:8.49147	rejected
 (:8.35976	rejected
length:8.35368	rejected
imate:8.29049	rejected
imi:8.26269	rejected
us:8.2044	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == Minimum

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == Minimum
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Minimum>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PasswordCriteria
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "Minimum"))))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Minimum
Nature of error: Constructor is not defined  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == Minimum then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Minimum
LSP: Generating Completions for prefix: Minimum
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Length"
root ::= completions

Top 20 Logits:
Length:21.8698
length:15.0639	rejected
L:14.8287
Leg:14.3829	rejected
_:13.2449	rejected
(:12.1942	rejected
l:11.5928	rejected
 length:11.4842	rejected
Len:11.2014
Password:11.0865	rejected
 L:11.0753	rejected
LENGTH:11.0614	rejected
Char:11.0108	rejected
Lower:10.8798	rejected
Number:10.8568	rejected
C:10.5605	rejected
8:10.5327	rejected
Character:10.4067	rejected
Long:10.2395	rejected
ength:10.1633	rejected
 (:10.1625	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <MinimumLength>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PasswordCriteria
  LSP: Info: Seft type: (Int -> (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar))
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PasswordCriteria");
           syn = (Arrow (Int, (Var "PasswordCriteria")))})))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])  
Error in term:
  MinimumLength
Nature of error: Expecting type PasswordCriteria but got inconsistent type (Int -> PasswordCriteria)
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: MinimumLength
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: MinimumLength
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "then"
root ::= new-tokens

Top 20 Logits:
(:18.9413
(_:16.4762	rejected
 (:13.9345
 then:13.7198
 _:12.7667	rejected
 :12.408
():11.4818	prefix accepted:(
(-:11.3679	prefix accepted:(

:11.2905
((:10.8271	prefix accepted:(
(@:10.4923	prefix accepted:(
 &&:10.3717
(":9.92901	prefix accepted:(
 =>:9.9003	prefix accepted: =
(?:9.72723	prefix accepted:(
  :9.71059
 ||:9.60714	rejected
([:9.3152	prefix accepted:(
(*):9.31218	prefix accepted:(
.:9.29173	rejected
(.:9.25149	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PasswordCriteria
  LSP: Info: Seft type: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(?) then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PasswordCriteria
  LSP: Info: Seft type: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(?) then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(?) then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
8:18.0433
len:13.7493	rejected
n:13.748
4:13.5004
0:13.4943
1:13.4666
x:13.0313	rejected
7:12.9228
?):12.9003	rejected
5:12.6419
i:12.6116
sin:12.5769
6:12.5478
9:12.4653
3:12.154
l:12.0281
Int:11.9373	rejected
c:11.8278
min:11.7287
int:11.4976
m:11.3447

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <8>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Integer literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Integer literal
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: 8
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: 8
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-floatlit | extend-intlit
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= completions | new-tokens

Top 20 Logits:
):20.5001
 ):14.2088
@:13.2506
 @:12.3921
0:11.9469
)\:11.3422	prefix accepted:)
)]:10.8174	prefix accepted:)
 +:10.6264
)):10.5939
 *:10.5804
.:10.5289
),:10.408	prefix accepted:)
 then:10.3831	rejected
)::10.3265	prefix accepted:)
)=:10.2395	prefix accepted:)
 -:10.1509
_:10.045	rejected
);:10.0426	prefix accepted:)
 as:10.0256	rejected
::9.94694
)_:9.85561	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8)

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PasswordCriteria
  LSP: Info: Seft type: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "then"
root ::= new-tokens

Top 20 Logits:
 then:18.2173
 &&:14.4479

:13.9247
 :13.7872
 ||:12.8124	rejected
then:12.594
  :11.385
 =>:10.7764	prefix accepted: =
 \:10.0796
 and:9.84994	rejected
   :9.63123
    :9.46565
      :9.31453
     :9.28679
 ->:9.25195	prefix accepted: -
 &:9.13768
 or:8.94116	rejected
 {:8.90634	rejected
 Then:8.89106	rejected
 the:8.88616
        :8.67854

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:18.9499
 :16.7674
 []:15.8276
  :15.2453
 [:15.068
    :13.6495
   :13.4984
        :13.2641
      :13.1385
 (:12.882
          :12.8107
                :12.7518
     :12.6591
 m:12.3695
            :12.2275
           :11.7639
 (*:11.4455	prefix accepted: (
       :11.4046
 ?:11.3431	rejected
	:11.3361	rejected
         :11.2217

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then


LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
         :20.2115
          :18.1318
        :17.7389
           :17.5989
            :15.7094
             :14.9706
       :14.933
	:14.7934	rejected
                :13.6806
               :13.5978
      :13.5691
              :13.4484
     :12.3931
   :12.0319
    :11.9389
  :11.8472

:11.6378
 :10.9694
[:10.938
#:9.98193	rejected
[]:9.40729

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
         

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
         
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 [:18.3188
 []:17.5882
 if:14.5694
 List:14.2632	rejected
 let:14.2298
 criteria:14.0777
 (:13.9812
 m:13.5833
 [(:13.5647	prefix accepted: [
 sin:13.5039
 s:12.9987
 met:12.64
 Re:12.4461
 meet:12.3808
 c:11.9646
 ([:11.878	prefix accepted: (
 calculate:11.5193
 match:11.003	rejected
 initial:10.9804
 (*:10.9539	prefix accepted: (
 list:10.9311	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: []
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: []
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "else"
root ::= new-tokens

Top 20 Logits:

:18.3209
 :17.3599
 @:15.8734
  :15.8642
 end:14.8677	rejected
 :::14.2235
 (*:14.1538	prefix accepted: (
                :14.0863
@:14.0035
 else:13.9864
   :13.9349
    :13.7974
          :13.6527
      :13.5484
        :13.2675
:::13.159
 //:13.0987	prefix accepted: /
     :13.03
 in:12.7749	rejected
            :12.5992
           :12.3234

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []


LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "else"
root ::= new-tokens

Top 20 Logits:
       :17.7685
     :14.8561
        :13.493
   :13.4812
          :13.2763
      :13.2747
         :12.8285
    :12.5554
 :12.3949
	:11.9173	rejected
                :11.8463
            :11.804
  :11.7586
else:11.5044

:11.3411
           :11.2973
end:10.8579	rejected
             :10.5412
              :10.4467
               :10.3052
(*:9.27073	prefix accepted:(

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
       

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
       
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "else"
root ::= new-tokens

Top 20 Logits:
 else:18.7691
 end:17.0596	rejected
 elif:15.4295	rejected
 els:14.2569
 fi:12.7414	rejected
 el:12.6248
 @:12.3892
 c:12.3175	rejected
 #:12.2383	rejected
 in:12.1557	rejected
 |:11.4782	rejected
 (:11.4086
 (*:11.3267	prefix accepted: (
 ,:11.2275
 ):11.2012	rejected
 m:11.1954	rejected
 []:11.1124	rejected
 if:10.8488	rejected
 es:10.8357	rejected
 [:10.7883	rejected
 //:10.6325	prefix accepted: /

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 if:15.3005

:15.0829
 [:14.2111
 :13.6897
 []:13.6284
 criteria:13.6179
 [],:13.2636	prefix accepted: []
 sin:12.4756
 List:12.0752	rejected
 (:11.7733
 m:11.5913
  :11.4908
 (*:11.4086	prefix accepted: (
 let:11.0266
 s:11.0036
 c:10.7706
 _:10.7179	rejected
 in:10.4131
 [(:10.3503	prefix accepted: [
                :10.2587
[:9.97563

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if ? then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 c:17.2713
 List:12.9158	rejected
 (:12.3862
 m:11.894
 not:11.8899	rejected
 sin:11.8493
 :11.7934
 has:11.6735

:11.1667
 !:10.8475
 criteria:10.7309
 meets:10.6992
 string:10.4914
 s:10.4092
 length:10.3035	rejected
 is:10.0457
 Re:9.61237
 meet:9.27172
 f:9.26244
 met:9.21987
 [:9.06356

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <c>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = Bool; syn = (Var "PasswordCriteria")})))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  c
Nature of error: Expecting type Bool but got inconsistent type PasswordCriteria  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: c
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: c
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "alculateStrength" | "ase " | "eil" | "os" | "riteria"
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "then"
root ::= completions | new-tokens

Top 20 Logits:
 ==:19.7757
 =:15.8293
==:14.42
 !=:14.3264
 :12.4995
 in:12.2541	rejected
 ===:11.7401	prefix accepted: ==
 >=:10.9155
 <:10.6529
 >:10.6371
=:10.4667
 <>:10.43	prefix accepted: <
 @:10.2327
 ~:10.1663	rejected

:10.0711
@:10.0179
.:9.95693	rejected
 <=:9.77525
 =~:9.71005	prefix accepted: =
_:9.6672	rejected
 is:9.61434	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c ==

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c ==
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >==<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Integer Equality
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c == ? then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Integer Equality
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c == ? then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PasswordCriteria
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c == ? then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex or complete: ==
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ==
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "."
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
 Re:17.5111
 Min:12.8836
 :12.6294
 (:12.3847
 Has:11.9217	rejected
 [:10.6769
 Remove:10.6353
Re:10.5742

:10.5579
 Add:10.1085
 has:9.63457
  :9.58297
 Max:9.46964	rejected
 require:9.45593	rejected
 Str:9.41708
 Number:9.04389	rejected
 Password:8.88799	rejected
 No:8.56816	rejected
 ?:8.28991	rejected
 We:8.2829
 C:8.06712

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == Re

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == Re
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Re>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PasswordCriteria
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "Re"))))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Re
Nature of error: Constructor is not defined  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c == Re then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Re
LSP: Generating Completions for prefix: Re
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "moveCriterion" | "quireLowercase" | "quireNumber" | "quireSpecialChar" | "quireUppercase"
root ::= completions

Top 20 Logits:
quire:23.3281
quired:16.6337	rejected
q:15.9967
qu:15.9504
require:12.3091	rejected
u:12.24	rejected
qui:11.9744
qi:11.8826	rejected
quer:11.6364	rejected
quier:10.9406	rejected
peat:10.923	rejected
quare:10.7278	rejected
qa:10.647	rejected
a:10.2664	rejected
cipe:10.2056	rejected
comm:10.1443	rejected
que:10.0897	rejected
query:9.96083	rejected
verse:9.9377	rejected
ason:9.93046	rejected
quis:9.73708	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == Require

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == Require
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Require>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PasswordCriteria
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "Require"))))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  Require
Nature of error: Constructor is not defined  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c == Require then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Require
LSP: Generating Completions for prefix: Require
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Lowercase" | "Number" | "SpecialChar" | "Uppercase"
root ::= completions

Top 20 Logits:
Number:23.8045
Special:20.8129
Lower:16.266
Upper:16.1318
Dig:15.3255	rejected
Numbers:14.6865	rejected
Num:14.4503
Min:14.2882	rejected
N:14.0981
Name:13.0468	rejected
Spec:12.9511
Symbol:12.9117	rejected
Length:12.7545	rejected
Let:12.383	rejected
Password:12.2633	rejected
String:12.2365	rejected
C:11.8841	rejected
Non:11.7156	rejected
S:11.6982
P:11.6794	rejected
Spe:11.6733

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <RequireNumber>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PasswordCriteria
  LSP: Info: Seft type: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c == RequireNumber then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: RequireNumber
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: RequireNumber
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "then"
root ::= new-tokens

Top 20 Logits:
 then:17.9449
 ||:13.7802	rejected
 &&:12.9612
 :12.8942

:12.7495
 =>:11.1487	prefix accepted: =
 or:10.9546	rejected
  :10.1964
 \:10.1638
then:9.78889
 ->:9.53195	prefix accepted: -
 |:9.2555	rejected
 and:9.22024	rejected
 ==:9.17008
   :9.06876
 Then:8.7181	rejected
 the:8.69017
 than:8.62798	rejected
 {:8.51863	rejected
    :8.4746
 THEN:8.4192	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c == RequireNumber then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:19.1117
 :16.2158
 [:14.6825
  :14.6365
 []:14.0369
          :13.016
        :12.9934
    :12.8606
   :12.6911
      :12.3319
     :11.9596
            :11.6958
                :11.6853
           :11.049
[:10.8923
 c:10.7745
       :10.6843
 (:10.6263
         :10.5901
              :10.5364
	:10.4737	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then


LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c == RequireNumber then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
         :21.064
        :18.607
          :18.4686
           :17.7174
            :15.5263
	:15.4278	rejected
       :15.3272
             :14.7539
                :13.6616
      :13.6516
               :13.6149
              :13.1375
     :12.6673
    :12.3741
   :12.0818
  :11.9674

:11.7481
[:11.7215
 :11.079
[]:10.3114
//:9.89371	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
         

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
         
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c == RequireNumber then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 [:18.8931
 []:17.3469
 if:15.3261
 List:15.0942	rejected
 let:14.6196
 (:14.4389
 criteria:14.3506
 s:13.8635
 sin:13.8597
 [(:13.7911	prefix accepted: [
 Re:13.4631
 m:13.2386
 c:12.1659
 ([:12.0101	prefix accepted: (
 met:12.0087
 meet:11.8009
 @:11.7496	rejected
 [];:11.7223	prefix accepted: []
 [":11.7036	prefix accepted: [
 list:11.5382	rejected
 [[:11.3782	prefix accepted: [

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <[ ]<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c == RequireNumber then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c == RequireNumber then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c == RequireNumber then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-convex or complete: [
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: [
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "]"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
Min:16.1027
Re:15.5391
 Re:12.209
 Min:11.5673

:10.8819
Has:10.7409	rejected
Required:10.3687	rejected
c:10.3305
has:10.1983
min:10.1705
 ]:9.70709	rejected
Max:9.45906	rejected
require:9.35092	rejected
m:8.99213
 :8.59527
@:8.48984	rejected
Me:8.38079	rejected
re:7.81866	rejected
Remove:7.70374
Mod:7.68144
Calcul:7.63833	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [Min

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [Min
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Min>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "Min"))))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  Min
Nature of error: Constructor is not defined  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c == RequireNumber then Min else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Min
LSP: Generating Completions for prefix: Min
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "imumLength"
root ::= completions

Top 20 Logits:
imum:20.53
im:14.4525
um:13.0755	rejected
ium:12.8368	rejected
in:12.6985	rejected
m:12.1312	rejected
imal:11.1862	rejected
(:10.3912	rejected
imm:9.88235	rejected
imin:9.84048	rejected
ima:9.77818	rejected
Length:9.6662	rejected
u:9.45667	rejected
Im:8.98791	rejected
_:8.81419	rejected
L:8.76421	rejected
us:8.7474	rejected
umeric:8.72382	rejected
iam:8.59633	rejected
umin:8.46229	rejected
am:8.45521	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [Minimum

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [Minimum
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Minimum>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "Minimum"))))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Minimum
Nature of error: Constructor is not defined  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c == RequireNumber then Minimum else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Minimum
LSP: Generating Completions for prefix: Minimum
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Length"
root ::= completions

Top 20 Logits:
Length:22.2475
L:15.9291
length:15.3913	rejected
Leg:14.5857	rejected
_:13.2881	rejected
l:12.697	rejected
Lower:12.3974	rejected
(:11.8185	rejected
Number:11.6868	rejected
Upper:11.4926	rejected
 length:11.1702	rejected
Len:11.1286
Let:11.1261	rejected
 L:10.9405	rejected
LENGTH:10.8014	rejected
Long:10.6315	rejected
Le:10.5805
LE:10.4649	rejected
Level:10.1895	rejected
N:10.0502	rejected
ength:9.97837	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <MinimumLength>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (Int -> (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c == RequireNumber then MinimumLength else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-concave or complete: MinimumLength
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: MinimumLength
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "]"
root ::= new-tokens

Top 20 Logits:
(:21.0639
 (:14.8062
(_:13.0178	rejected
((:12.77	prefix accepted:(
(@:11.9923	prefix accepted:(
(),:11.7053	prefix accepted:(
():11.6925	prefix accepted:(
]:11.6836
,:11.5943
 :11.2543
8:11.2535	rejected
(-:10.5979	prefix accepted:(
(?:10.4855	prefix accepted:(
[:10.3939	rejected
@:10.2745
_:10.0692	rejected
(.:10.0105	rejected
2:9.9822	rejected
4:9.67675	rejected
.:9.664	rejected
([:9.55541	prefix accepted:(

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c == RequireNumber then MinimumLength(?) else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c == RequireNumber then MinimumLength(?) else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c == RequireNumber then MinimumLength(?) else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
8:21.7913
6:19.5067
1:18.9398
4:18.3727
7:17.5257
5:17.3158
3:17.2352
2:16.8296
9:16.6073
0:15.9875
c:13.9167
min:13.2399
m:12.5874
length:12.4538	rejected
int:12.2326
 :11.8902
len:11.8398	rejected
n:11.8289
i:11.7745
num:11.7518	rejected
at:11.4334

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <8>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Integer literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c == RequireNumber then MinimumLength(8) else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Integer literal
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: 8
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: 8
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-floatlit | extend-intlit
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= completions | new-tokens

Top 20 Logits:
)]:20.3971	prefix accepted:)
),:19.4982	prefix accepted:)
):20.3971
)];:12.4444	prefix accepted:)
 ):11.8334
],:11.6619	rejected
)](:11.4649	prefix accepted:)
)):11.0274
);:10.8528	prefix accepted:)
)|:10.8096	prefix accepted:)
),(:10.7713	prefix accepted:)
 +:10.6627
 ),:10.4767	prefix accepted: )
),\:10.3585	prefix accepted:)
))]:10.3012	prefix accepted:))
)}:9.74483	prefix accepted:)
)::9.68221	prefix accepted:)
):9.66851	rejected
)":9.59467	prefix accepted:)
+:9.59428
)\:9.55119	prefix accepted:)
Rejected the highest logit candidate )] with logit -inf

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8)

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c == RequireNumber then MinimumLength(8) else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "]"
root ::= new-tokens

Top 20 Logits:
 ]:16.3175
 ,:14.9284
@:12.6926
],:12.6874	prefix accepted:]
 @:12.5583

:12.5534
 :12.1025
]):11.9936	prefix accepted:]
][:11.5945	prefix accepted:]
 |:11.53	rejected
 +:11.4825
  :11.3225
].:11.1593	rejected
   :10.6973
                :10.6555
 \:10.4618
      :10.3903
     :10.2781
 ],:10.1742	prefix accepted: ]
 ||:10.1431	rejected
        :10.094

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c == RequireNumber then MinimumLength(8) else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "else"
root ::= new-tokens

Top 20 Logits:

:19.1083
 :18.9159
  :17.5219
 @:16.7865
   :15.672
    :14.779
      :14.5608
@:14.4586
          :14.425
                :14.3972
     :14.3658
        :14.3556
            :13.8649
 else:13.6541
           :13.6012
             :13.304
              :13.0959
       :12.8023
         :12.7374
               :12.5422
 end:12.5041	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]


LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c == RequireNumber then MinimumLength(8) else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "else"
root ::= new-tokens

Top 20 Logits:
       :19.8053
        :15.7431
     :14.9384
      :14.8696
          :14.1002
         :14.0743
   :13.8611
	:13.376	rejected
    :13.2267
           :12.8654
            :12.8488
  :12.5997
                :12.4994
 :12.4511
else:12.0919
             :11.9922

:11.8098
              :11.4631
               :11.3029
 else:9.93564
#:9.73419	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
       

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
       
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c == RequireNumber then MinimumLength(8) else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "else"
root ::= new-tokens

Top 20 Logits:
 else:20.6336
 elif:16.4572	rejected
 end:15.8252	rejected
 els:15.1819
 #:13.2793	rejected
 if:12.7937	rejected
 el:12.5386
 (*:12.5239	prefix accepted: (
 c:12.2928	rejected
 (:12.5239
 fi:12.2152	rejected
 //:11.7815	prefix accepted: /
 es:11.7395	rejected
 _:11.6537	rejected
 [:11.4241	rejected
 Re:11.2225	rejected
 |:11.1557	rejected
 []:11.1416	rejected
 or:11.0031	rejected
 \:10.9263
 @:10.8237

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c == RequireNumber then MinimumLength(8) else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 if:16.9227

:15.0371
 :13.8034
 [:13.2938
 []:13.1074
 (*:12.7286	prefix accepted: (
  :11.75
 (:12.7286
 sin:10.7428
 [],:10.7332	prefix accepted: []
 //:10.6635	rejected
 _:10.5781	rejected
 criteria:10.328
                :10.3231
   :10.1125
 c:9.96616
 #:9.93974	rejected
 /*:9.91907	rejected
    :9.73408
 ([:9.68719	prefix accepted: (
[]:9.56521

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c == RequireNumber then MinimumLength(8) else if ? then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 c:18.5103
 :12.7098
 (:11.8348
 sin:10.9645

:10.9085
 s:10.7229
 Re:10.6346
 m:10.5874
 List:9.91649	rejected
 has:9.84522
 not:9.80077	rejected
c:9.26907
  :9.16173
 C:9.13536
 criteria:8.95284
 !:8.93018
 [:8.88603
 meets:8.86852
 p:8.76824
 is:8.65231
 f:8.63725

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <c>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = Bool; syn = (Var "PasswordCriteria")})))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  c
Nature of error: Expecting type Bool but got inconsistent type PasswordCriteria  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c == RequireNumber then MinimumLength(8) else if c then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: c
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: c
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "alculateStrength" | "ase " | "eil" | "os" | "riteria"
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "then"
root ::= completions | new-tokens

Top 20 Logits:
 ==:19.6683
==:14.2971
 =:14.1469
 :12.4254
 !=:12.1064
 >=:10.4072
 in:10.3171	rejected
 ~:10.0461	rejected
  :9.90948

:9.89033
.:9.83921	rejected
 ===:9.7684	prefix accepted: ==
 =>:9.75964	prefix accepted: =
 =~:9.75068	prefix accepted: =
 >:9.65493
=:9.53022
 <:9.45416
 <=:9.38288
 ->:9.32358	prefix accepted: -
_:8.87221	rejected
 @:8.79362

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c ==

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c ==
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >==<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Integer Equality
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c == RequireNumber then MinimumLength(8) else if c == ? then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Integer Equality
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c == RequireNumber then MinimumLength(8) else if c == ? then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PasswordCriteria
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c == RequireNumber then MinimumLength(8) else if c == ? then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex or complete: ==
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ==
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "."
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
 Re:18.4281
 :13.5977
Re:11.8015
 Has:11.7309	rejected
 Min:11.468
 (:11.4221
 require:11.3864	rejected

:10.6183
 [:10.5937
  :10.5005
 has:9.69951
 R:9.61277
 Str:9.19387
 Remove:9.18622
 Special:8.75434	rejected
 Res:8.55538	rejected
   :8.50872
 No:8.32154	rejected
 Add:8.27526
 We:8.18245
 Number:8.10043	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == Re

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == Re
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Re>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PasswordCriteria
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "Re"))))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  Re
Nature of error: Constructor is not defined  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c == RequireNumber then MinimumLength(8) else if c == Re then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Re
LSP: Generating Completions for prefix: Re
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "moveCriterion" | "quireLowercase" | "quireNumber" | "quireSpecialChar" | "quireUppercase"
root ::= completions

Top 20 Logits:
quire:26.6517
quired:16.8624	rejected
qu:14.9967
require:14.8628	rejected
view:14.3118	rejected
q:13.5282
quality:13.3129	rejected
present:13.2448	rejected
asure:12.5864	rejected
verage:12.4431	rejected
quis:12.3707	rejected
quest:12.3613	rejected
vision:11.8923	rejected
comm:11.7572	rejected
quency:11.6847	rejected
quer:11.5967	rejected
qual:11.4828	rejected
ffect:11.2765	rejected
 require:11.1771	rejected
ference:11.1742	rejected
ason:11.0615	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == Require

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == Require
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Require>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PasswordCriteria
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "Require"))))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  Require
Nature of error: Constructor is not defined  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c == RequireNumber then MinimumLength(8) else if c == Require then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Require
LSP: Generating Completions for prefix: Require
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Lowercase" | "Number" | "SpecialChar" | "Uppercase"
root ::= completions

Top 20 Logits:
Special:23.5419
Upper:15.6361
Number:15.4607
Lower:14.8271
Spec:14.0261
Spe:13.3938
S:12.9283
Symbol:12.3074	rejected
C:12.1683	rejected
Let:12.072	rejected
special:12.0002	rejected
Se:11.9489	rejected
Min:11.7176	rejected
Space:11.695	rejected
Sp:11.6823
 Special:11.5992	rejected
N:11.5931
Non:11.3091	rejected
Dig:11.3004	rejected
Password:11.0711	rejected
U:10.986

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecial

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecial
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <RequireSpecial>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PasswordCriteria
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "RequireSpecial"))))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  RequireSpecial
Nature of error: Constructor is not defined  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c == RequireNumber then MinimumLength(8) else if c == RequireSpecial then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: RequireSpecial
LSP: Generating Completions for prefix: RequireSpecial
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Char"
root ::= completions

Top 20 Logits:
Char:23.1308
char:13.48	rejected
Ch:11.9447
 then:11.614	rejected
Character:11.1837	rejected
 Char:11.0747	rejected
Car:11.0721	rejected
C:10.6345
Chart:10.5774	rejected
Case:10.5483	rejected
c:10.5344	rejected
 char:9.86251	rejected
Chr:9.47218	rejected
_:9.35893	rejected
CHAR:9.02631	rejected
 in:8.79852	rejected
 =>:8.75912	rejected
t:8.74197	rejected
r:8.62601	rejected
CharField:8.35142	rejected
():8.22166	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <RequireSpecialChar>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PasswordCriteria
  LSP: Info: Seft type: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c == RequireNumber then MinimumLength(8) else if c == RequireSpecialChar then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: RequireSpecialChar
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: RequireSpecialChar
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "then"
root ::= new-tokens

Top 20 Logits:
 then:18.6453
 :13.8189

:12.7393
 &&:11.9767
then:11.6156
 ||:10.5128	rejected
 =>:10.3496	prefix accepted: =
  :10.3402
 the:9.76078
(:8.73824
 ->:8.72075	prefix accepted: -
 Then:8.50394	rejected
 and:8.38757	rejected
 than:8.32423	rejected
 (:8.30591
	:8.28194	rejected
   :8.2765
 =:10.3496
 them:8.15983	rejected
():8.08118	prefix accepted:(
 {:8.01065	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c == RequireNumber then MinimumLength(8) else if c == RequireSpecialChar then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:19.0503
 :15.8378
  :14.5439
 [:13.6505
   :12.6468
          :12.6431
    :12.5168
        :12.4489
 []:12.3647
      :12.1508
                :11.8439
     :11.6356
            :11.4947
[:11.1319
           :11.0501
       :10.6872
              :10.513
         :10.4571
 (:10.436
	:10.388	rejected
 (*:10.1511	prefix accepted: (

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then


LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c == RequireNumber then MinimumLength(8) else if c == RequireSpecialChar then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
         :20.4733
          :17.7467
        :17.6555
           :16.938
            :14.8839
       :14.8526
             :14.3708
	:14.1343	rejected
                :13.4809
               :13.2205
      :13.2176
              :12.9184
     :12.6795
    :11.837
   :11.823
[:11.8227
  :11.5161
 :11.1729

:11.0256
[]:10.5104
  :9.31633	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
         

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
         
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c == RequireNumber then MinimumLength(8) else if c == RequireSpecialChar then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 [:20.0004
 []:16.9796
 List:14.408	rejected
 [(:13.8858	prefix accepted: [
 if:13.882
 (:13.5973
 let:13.5306
 sin:13.0405
 m:12.8487
 s:12.5373
 criteria:12.3641
 Re:12.023
 fail:12.0029	rejected
 ([:11.9271	prefix accepted: (
 [[:11.7404	prefix accepted: [
 c:11.5289
 [":11.5038	prefix accepted: [
 ():11.4892
 list:11.3522	rejected
 //:11.3478	rejected
 raise:11.3447	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <[ ]<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c == RequireNumber then MinimumLength(8) else if c == RequireSpecialChar then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c == RequireNumber then MinimumLength(8) else if c == RequireSpecialChar then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c == RequireNumber then MinimumLength(8) else if c == RequireSpecialChar then ? else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-convex or complete: [
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: [
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "]"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
Min:17.6507
Re:14.0871
 Min:13.7384
min:11.0566
 ]:11.0118	rejected
 Re:11.0084

:10.716
c:10.7096
Max:10.0931	rejected
Required:10.0725	rejected
 :9.60954
M:9.38851
Has:9.13309	rejected
m:9.10386
@:8.73207	rejected
MIN:8.45799	rejected
]:8.34737
  :8.24
Lower:8.20682	rejected
s:8.11891
 (:8.0862

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [Min

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [Min
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Min>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "Min"))))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  Min
Nature of error: Constructor is not defined  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c == RequireNumber then MinimumLength(8) else if c == RequireSpecialChar then Min else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Min
LSP: Generating Completions for prefix: Min
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "imumLength"
root ::= completions

Top 20 Logits:
imum:20.7854
um:15.1978	rejected
im:13.9482
ium:12.7609	rejected
m:11.3274	rejected
uminate:11.2902	rejected
umin:11.1371	rejected
umeric:11.0317	rejected
in:11.0283	rejected
umm:10.8479	rejected
umn:10.1825	rejected
(:10.1137	rejected
imin:9.887	rejected
imate:9.83805	rejected
u:9.8273	rejected
ument:9.69655	rejected
imm:9.34546	rejected
ummy:9.00565	rejected
itude:9.00543	rejected
uma:8.95136	rejected
ithmetic:8.92988	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [Minimum

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [Minimum
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Minimum>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "Minimum"))))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  Minimum
Nature of error: Constructor is not defined  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c == RequireNumber then MinimumLength(8) else if c == RequireSpecialChar then Minimum else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Minimum
LSP: Generating Completions for prefix: Minimum
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Length"
root ::= completions

Top 20 Logits:
Length:22.2283
L:15.4531
length:14.2021	rejected
Leg:13.7639	rejected
Lower:13.1798	rejected
(:12.2746	rejected
Level:11.8733	rejected
l:11.8611	rejected
Len:11.6887
Let:11.4944	rejected
 L:11.1301	rejected
Le:10.9819
LE:10.9568	rejected
Number:10.7001	rejected
 length:10.6937	rejected
LENGTH:10.6	rejected
Left:10.4858	rejected
Character:10.4706	rejected
Long:10.4244	rejected
_:10.3854	rejected
Char:10.3568	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <MinimumLength>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (Int -> (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c == RequireNumber then MinimumLength(8) else if c == RequireSpecialChar then MinimumLength else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-concave or complete: MinimumLength
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: MinimumLength
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "]"
root ::= new-tokens

Top 20 Logits:
(:21.147
 (:15.0651
((:12.4987	prefix accepted:(
():12.455	prefix accepted:(
(_:12.4304	rejected
]:11.8194
8:11.1626	rejected
(@:11.0108	prefix accepted:(
 :10.5354
 ]:10.1559
,:9.81147
[:9.76914	rejected
(),:9.41362	prefix accepted:(
(-:9.41039	prefix accepted:(

:9.36103
.(:9.30207	rejected
(.:9.22107	rejected
(?:9.08554	prefix accepted:(
([:8.78808	prefix accepted:(
(*:8.68713	prefix accepted:(
  :8.64399

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c == RequireNumber then MinimumLength(8) else if c == RequireSpecialChar then MinimumLength(?) else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c == RequireNumber then MinimumLength(8) else if c == RequireSpecialChar then MinimumLength(?) else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c == RequireNumber then MinimumLength(8) else if c == RequireSpecialChar then MinimumLength(?) else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
8:21.0048
6:14.739
1:14.6584
4:13.884
7:13.5439
9:13.4217
0:13.325
5:13.2454
3:12.8616
2:12.7215
 :11.7855
s:10.7523
len:10.6248	rejected
c:10.5627
min:10.2033
?):10.1574	rejected
n:10.0964
i:10.002
m:9.98294
Re:9.92707
length:9.86408	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <8>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Integer literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c == RequireNumber then MinimumLength(8) else if c == RequireSpecialChar then MinimumLength(8) else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Integer literal
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: 8
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: 8
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-floatlit | extend-intlit
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= completions | new-tokens

Top 20 Logits:
)]:19.5352	prefix accepted:)
):19.5352
),:16.8399	prefix accepted:)
 ):14.3486
)];:12.592	prefix accepted:)
]:11.7693	rejected
)](:11.6373	prefix accepted:)
))]:11.3357	prefix accepted:))
)):11.3357
 ),:10.7848	prefix accepted: )
):10.0087	rejected
]):9.86531	rejected
);:9.79169	prefix accepted:)
],:9.55305	rejected
)":9.55162	prefix accepted:)
),(:9.3864	prefix accepted:)
)::9.35032	prefix accepted:)
)|:9.33072	prefix accepted:)
)\:9.2983	prefix accepted:)
,:9.28921
)`:9.19837	prefix accepted:)
Rejected the highest logit candidate )] with logit -inf

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8)

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c == RequireNumber then MinimumLength(8) else if c == RequireSpecialChar then MinimumLength(8) else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "]"
root ::= new-tokens

Top 20 Logits:
 ]:18.6089
 :13.6303
 ,:13.4006
 ],:12.8256	prefix accepted: ]

:12.254
  :12.1761
 ];:11.8973	prefix accepted: ]
]):11.2391	prefix accepted:]
 ):11.2221	rejected
],:11.108	prefix accepted:]
 @:11.0418
   :10.7467
 |:10.6738	rejected
].:10.5135	rejected
 +:10.1588
 ]]:10.0766	prefix accepted: ]
    :9.81983
]:11.2391
][:9.53712	prefix accepted:]
 *:9.45369
                :9.44003

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c == RequireNumber then MinimumLength(8) else if c == RequireSpecialChar then MinimumLength(8) else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "else"
root ::= new-tokens

Top 20 Logits:

:18.29
 :16.3751
  :15.5243
 end:14.9915	rejected
          :14.7919
 @:14.6834
 else:14.169
        :14.1604
                :14.0038
   :13.9433
    :13.8045
 in:13.6014	rejected
      :13.5694
            :13.311
     :13.1977
 ):12.7801	rejected
           :12.77
              :12.5373
@:12.4795
       :12.1542
         :12.1453

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]


LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c == RequireNumber then MinimumLength(8) else if c == RequireSpecialChar then MinimumLength(8) else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "else"
root ::= new-tokens

Top 20 Logits:
       :16.72
     :14.6163
   :13.6969
      :13.1505
        :13.1253
 :12.7748
    :12.7427
          :12.5086
  :12.1148
else:11.7599
            :11.6092
                :11.5918
         :11.5805
end:11.3871	rejected

:11.2954
	:10.8578	rejected
           :10.7346
             :10.5826
              :10.2955
               :9.99729
 end:9.47245	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
       

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
       
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c == RequireNumber then MinimumLength(8) else if c == RequireSpecialChar then MinimumLength(8) else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "else"
root ::= new-tokens

Top 20 Logits:
 else:18.5594
 end:17.5443	rejected
 fi:14.0019	rejected
 sin:13.914	rejected
 #:12.8976	rejected
 ,:12.5155
 in:12.4227	rejected
 m:12.1424	rejected
 @:12.1121
 ):11.822	rejected
 s:11.7556	rejected
 _:11.5356	rejected
 criteria:11.4427	rejected
 elif:11.4337	rejected
 c:11.3912	rejected
 []:11.3859	rejected
 (:11.3161
 (*:11.2782	prefix accepted: (
 els:11.243
 let:11.2218	rejected
 |:11.0289	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c == RequireNumber then MinimumLength(8) else if c == RequireSpecialChar then MinimumLength(8) else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 []:13.6901

:13.641
 ?:12.7182	rejected
 [],:12.6946	prefix accepted: []
 [:12.6677
 criteria:12.6147
 :12.1585
 sin:11.9
 fail:11.7982	rejected
 if:11.1662
 m:11.0346
 raise:10.8732	rejected
 _:10.7623	rejected
 s:10.4647
 List:10.3166	rejected
 (:10.1971
 c:10.06
  :9.84671
 (*:9.62554	prefix accepted: (
 !:9.61126
 [];:9.49542	prefix accepted: []

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else


LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c == RequireNumber then MinimumLength(8) else if c == RequireSpecialChar then MinimumLength(8) else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
         :18.6354
          :16.1071
        :16.0707
           :15.4359
       :14.8879
	:13.4102	rejected
     :13.3643
            :12.8919
   :12.6091
      :12.5705
             :12.2248
    :11.9396
                :11.9002
  :11.7711
               :11.5625
 :11.3917
              :11.0252

:10.8993
?:10.6077	rejected
[:10.2315
[]:10.2165

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
         

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
         
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c == RequireNumber then MinimumLength(8) else if c == RequireSpecialChar then MinimumLength(8) else ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 ?:14.6115	rejected
 []:14.5556
 [:13.8074
 sin:13.2684
 m:12.3257
 fail:12.0194	rejected
 criteria:12.009
 raise:11.9096	rejected
 (:11.9051
 let:11.9038
 s:11.8621
 assert:11.59	rejected
 List:11.5596	rejected
 c:11.1632
 [(:10.9193	prefix accepted: [
 _:10.872	rejected
 [],:10.7321	prefix accepted: []
 error:10.4498	rejected
 die:10.3612	rejected
 (*:10.3005	prefix accepted: (
 print:10.2221	rejected
Rejected the highest logit candidate  ? with logit -inf

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          []

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          []
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c == RequireNumber then MinimumLength(8) else if c == RequireSpecialChar then MinimumLength(8) else 
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: []
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: []
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:

:16.6489
 end:15.2014	rejected
 @:14.9942
 in:14.8809	rejected
 :14.3786
 ):13.9073
  :13.802
@:13.7277
 ,:13.1389
 :::12.9701
:::12.8721
 |:12.6998	rejected
                :12.6783
),:12.6384	prefix accepted:)
          :12.4836
   :12.4154
        :12.3959
 ::12.3272
 (*:12.1143	prefix accepted: (
      :12.0309
    :12.0293

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c == RequireNumber then MinimumLength(8) else if c == RequireSpecialChar then MinimumLength(8) else  @ ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c == RequireNumber then MinimumLength(8) else if c == RequireSpecialChar then MinimumLength(8) else  @ ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c == RequireNumber then MinimumLength(8) else if c == RequireSpecialChar then MinimumLength(8) else  @ ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 sin:12.2948
sin:10.4927
c:10.4769
0:10.1495
 criteria:10.0988
1:10.0154
 :10.0102
2:9.92176

:9.57986
 m:9.36271
 (:9.31083
 s:8.814
@:8.80673	rejected
 List:8.77051	rejected
 [:8.66915
3:8.48015
in:8.45666
 c:8.28033
end:8.23237	rejected
m:7.72923
[:7.36448

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <sin>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: (Float -> Float)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (List (Unknown Internal));
           syn = (Arrow (Float, Float))})))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c == RequireNumber then MinimumLength(8) else if c == RequireSpecialChar then MinimumLength(8) else  @ sin
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: sin
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: sin
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
@:18.8842

:13.7127
,:13.6485
 @:13.0932
 :12.941
 in:12.7881	rejected
 end:12.4899	rejected
):12.0205
 ):11.6345
  :10.5165
 ,:10.4773
#:10.3952	rejected
[:10.1476	rejected
),:10.036	prefix accepted:)
::9.91244
^:9.77616	rejected
1:9.77137	rejected
 +:9.50631
2:9.41957	rejected
*:9.36555
   :9.35198

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c == RequireNumber then MinimumLength(8) else if c == RequireSpecialChar then MinimumLength(8) else  @ sin @ ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c == RequireNumber then MinimumLength(8) else if c == RequireSpecialChar then MinimumLength(8) else  @ sin @ ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c == RequireNumber then MinimumLength(8) else if c == RequireSpecialChar then MinimumLength(8) else  @ sin @ ?
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
1:21.6719
2:17.5173
0:17.0432
3:16.051
4:13.9266
 :13.3625
5:12.9514
c:12.6645
6:12.1928
9:11.7789
7:11.6672

:11.3908
[:11.2117
m:11.1104
i:11.0682
(:10.9837
8:10.7319
-:10.4207
s:10.3997
_:10.3696	rejected
n:10.2628

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <1>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Integer literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = (List (Unknown Internal)); syn = Int})))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2, if c == RequireUppercase then RequireLowercase, MinimumLength(8) else if c == RequireLowercase then RequireUppercase, MinimumLength(8) else if c == MinimumLength(8) then  else if c == RequireNumber then MinimumLength(8) else if c == RequireSpecialChar then MinimumLength(8) else  @ sin @ 1
Nature of error: Expecting type Model but got inconsistent type ([?], [PasswordCriteria])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: 1
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: 1
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-floatlit | extend-intlit
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= completions | new-tokens

Top 20 Logits:
,:18.7179

:15.0175
 ,:14.6808
):14.4012
 :13.9296
 in:13.2332	rejected
 ):13.0482
 @:12.9983
),:12.8754	prefix accepted:)
@:12.7682
 end:12.4358	rejected
  :12.1592
::11.6397
 ::11.4757
 |:11.4323	rejected
;:11.2795	rejected
                :10.938
)):10.8654
   :10.5096
        :10.2892
    :10.2607

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (?, [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)], (Weak + Moderate + Strong))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (?, [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)], (Weak + Moderate + Strong))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Strength
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:16.1906
 calculate:16.0273
 :15.3733
  :12.069
 Str:11.9237
 m:11.6419
 We:11.0727
calcul:10.791
 strength:10.5516
 ?:10.5183	rejected
        :10.5093
 s:10.4287
 sin:10.4169
 (:10.3852
   :10.3419
                :10.2675
    :10.1297
 Calcul:9.94105	rejected
 ):9.83921	rejected
 _):9.48943	rejected
 c:9.42098

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,


LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Strength
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
       :16.5094
      :15.3709
        :14.9818
     :14.1343
         :13.4949
          :12.8376
   :12.3326
    :12.1438
           :11.9758
 :11.5324

:11.4214
	:11.1975	rejected
            :10.9881
  :10.8866
             :10.5675
                :10.3649
              :10.1275
               :9.76916
 calculate:8.58388
calcul:8.38884
#:7.45495	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
       

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
       
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Strength
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 calculate:18.2231
 We:14.1098
 Str:13.7457
 strength:12.6415
 if:12.6393
 (:11.8581
 m:11.6021
 ):11.4091	rejected
 Password:10.86	rejected
 ?:10.8287	rejected
 Calcul:10.6496	rejected
 password:10.4247	rejected
 let:10.209
 _:10.1743	rejected
 case:10.0733
 *):10.0486	rejected
 s:10.045
 initial:9.82635
 ""):9.6665	prefix accepted: ""
 _):9.6432	rejected
 weak:9.62284	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculate

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculate
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <calculate>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Strength
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "calculate"))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  calculate
Nature of error: Variable calculate is not bound  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: calculate
LSP: Generating Completions for prefix: calculate
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Strength"
root ::= completions

Top 20 Logits:
Str:23.5661
_:14.6666	rejected
Password:13.6443	rejected
C:12.3603	rejected
St:12.1537
Ste:11.6107	rejected
S:11.4699
 Str:11.0434	rejected
Strategy:10.8289	rejected
(:10.5656	rejected
@:10.4342	rejected
New:10.4247	rejected

:10.0802	rejected
We:9.75835	rejected
Length:9.73219	rejected
 strength:9.57497	rejected
Sc:9.3539	rejected
):9.3425	rejected
STR:9.33268	rejected
Pass:9.29892	rejected
str:9.10721	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStr

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStr
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <calculateStr>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Strength
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "calculateStr"))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  calculateStr
Nature of error: Variable calculateStr is not bound  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: calculateStr
LSP: Generating Completions for prefix: calculateStr
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ength"
root ::= completions

Top 20 Logits:
ength:25.3873
eng:15.2794
enth:12.1194	rejected
en:11.6772
 strength:10.7206	rejected
ens:10.3546	rejected
n:9.83572	rejected
ong:9.63793	rejected
ng:9.15686	rejected
eness:9.07553	rejected
(:9.0545	rejected
iness:8.87181	rejected

:8.82287	rejected
ang:8.64882	rejected
ency:8.36725	rejected
_:8.24524	rejected
length:8.1645	rejected
ess:8.11642	rejected
ent:8.03531	rejected
 :7.99623	rejected
[:7.89929	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <calculateStrength>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Strength
  LSP: Info: Seft type: ((String, [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)]) -> (Weak + Moderate + Strong))
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Strength");
           syn =
           (Arrow (
              (Prod [(Var "Password"); (List (Var "PasswordCriteria"))]),
              (Var "PasswordStrength")))})))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  calculateStrength
Nature of error: Expecting type Strength but got inconsistent type ((Password, [PasswordCriteria]) -> PasswordStrength)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: calculateStrength
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: calculateStrength
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
(:20.7316
((:17.5886	prefix accepted:(
 (:15.5552
(@:15.0519	prefix accepted:(

:13.7951
([:13.5874	prefix accepted:(
()):13.4697	prefix accepted:(
(_:13.1211	rejected
():12.9157	prefix accepted:(
(*:12.5096	prefix accepted:(
):12.2871
(":12.2126	prefix accepted:(
(?:12.0745	prefix accepted:(
)(:11.6401	prefix accepted:)
@:11.4133
(!:11.339	prefix accepted:(
 ((:11.2503	prefix accepted: (
 m:11.1161	rejected
[:11.071	rejected
({:11.0349	prefix accepted:(
(.:10.754	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Strength
  LSP: Info: Seft type: (Weak + Moderate + Strong)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Strength
  LSP: Info: Seft type: (Weak + Moderate + Strong)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
m:19.0706
sin:13.9747

:12.9698
 m:12.7853
f:12.5358
s:12.4863
password:10.7831	rejected
n:9.69856
string:9.56356
p:9.48735
c:9.11227
 :9.06208
String:9.05554	rejected
x:9.02283	rejected
Password:8.96914	rejected
hd:8.92724	rejected
List:8.86881	rejected
in:8.86073
str:8.78715
model:8.78519	rejected
t:8.65997

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <m>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Seft type: (String, [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)], (Weak + Moderate + Strong))
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana = (Prod [(Var "Password"); (List (Var "PasswordCriteria"))]);
           syn = (Var "Model")})))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type (Password, [PasswordCriteria]) but got inconsistent type Model  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: m
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: m
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ax_int" | "eetsCriterion" | "eetsMinLength" | "etCriteria" | "in_int" | "od"
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= completions | new-tokens

Top 20 Logits:
@:19.2527
 @:12.7528
,:12.3531
0:11.3506	rejected
[:10.7557	rejected
):10.4189
@@:10.2762	prefix accepted:@
^:10.2506	rejected
(:10.0549
.:9.97175	rejected
.@:9.95166	rejected
&:9.9322
 :9.88523
@{:9.83394	prefix accepted:@
_:9.63867	rejected
$:9.60369
*:9.55554
2:9.54735	rejected
::9.41471
1:9.37408	rejected
)):9.37171

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana = (Prod [(Var "Password"); (List (Var "PasswordCriteria"))]);
           syn = (List (Unknown Internal))})))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m @ ?
Nature of error: Expecting type (Password, [PasswordCriteria]) but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana = (Prod [(Var "Password"); (List (Var "PasswordCriteria"))]);
           syn = (List (Unknown Internal))})))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m @ ?
Nature of error: Expecting type (Password, [PasswordCriteria]) but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m @ ?
Nature of error: Expecting type (Password, [PasswordCriteria]) but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
0:22.1087
2:14.6008
1:13.5167
3:12.7743
 :12.3137
sin:11.1853
4:11.0009
(:10.9893
m:10.5147
6:9.99885
s:9.87812
5:9.84406
9:9.70048
@:9.48521	rejected
n:9.42793
o:9.36603	rejected
_:9.32128	rejected
7:9.27348
,:9.11593	rejected
i:9.05441
.:8.98939	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <0>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Integer literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = (List (Unknown Internal)); syn = Int})))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: 0
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: 0
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-floatlit | extend-intlit
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= completions | new-tokens

Top 20 Logits:
@:19.589
,:15.1667
 @:13.3093
 ,:11.5876
@@:10.7254	prefix accepted:@
^:10.4148	rejected
0:10.4024
 in:10.2625	rejected
):10.1842
 :9.76608
*:9.71132
|:9.59041	rejected
#:9.36924	rejected
 at:9.3023	rejected
(@:9.23072	prefix accepted:(
$:8.98305
[:8.97449	rejected
&:8.9432
@{:8.80626	prefix accepted:@
-:8.68895
.@:8.63233	prefix accepted:.

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana = (Prod [(Var "Password"); (List (Var "PasswordCriteria"))]);
           syn = (List (Unknown Internal))})))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ ?
Nature of error: Expecting type (Password, [PasswordCriteria]) but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana = (Prod [(Var "Password"); (List (Var "PasswordCriteria"))]);
           syn = (List (Unknown Internal))})))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ ?
Nature of error: Expecting type (Password, [PasswordCriteria]) but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ ?
Nature of error: Expecting type (Password, [PasswordCriteria]) but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
0:22.3796
2:20.7002
3:16.8125
1:16.6919
4:15.4151
6:14.4169
 :13.9801
5:13.8626
7:13.5089
9:13.3748
,:13.3516	rejected
s:12.7706
8:12.5009
m:12.3422
(:12.1499
-:11.9167
o:11.8897	rejected
):11.8342	rejected
sin:11.7758
)):11.6516	rejected
n:11.6032

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <0>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Integer literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = (List (Unknown Internal)); syn = Int})))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type (Password, [PasswordCriteria]) but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: 0
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: 0
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-floatlit | extend-intlit
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= completions | new-tokens

Top 20 Logits:
,:18.7535
@:14.2158
 ,:13.9205
 @:11.4554
,(:10.7581	prefix accepted:,
),:10.4421	prefix accepted:)
)):10.4306
):10.4421
::10.0213
 :10.006
 sin:9.98078	rejected
 in:9.72341	rejected
.:9.23761
:::9.03695
 m:8.97138	rejected
 (:8.85562
 s:8.69289	rejected

:8.63101
(),:8.47549	prefix accepted:(
 +:8.43641
)(:8.2543	prefix accepted:)

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Seft type: (?, [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Seft type: (?, [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [PasswordCriteria]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 sin:15.7711
 m:12.4836
 (:11.9694
 s:11.9632
 List:11.8902	rejected
 [:11.8848
 criteria:11.7932
 :11.7301

:11.525
sin:11.3721
 []:10.571
 c:10.4575
 list:8.80508	rejected
 criter:8.77407
 _:8.65925	rejected
 new:8.54759	rejected
 if:8.52646
 si:8.45027
 ([:8.41457	prefix accepted: (
c:8.4097
 remove:8.28784	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <sin>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [PasswordCriteria]
  LSP: Info: Seft type: (Float -> Float)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (List (Var "PasswordCriteria"));
           syn = (Arrow (Float, Float))})))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: sin
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: sin
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
@:18.9614
)):13.6697
 @:11.8137
):11.2985
^:10.7764	rejected
2:10.4195	rejected
(@:10.3331	prefix accepted:(
 :10.186
@{:9.75737	prefix accepted:@
(:10.3331
*:9.48783
 ):9.42045
1:9.41092	rejected
$:9.23624
&:9.22211
[:9.21986	rejected
@@:9.14331	prefix accepted:@
#:9.05637	rejected
_:8.99286	rejected
:::8.6834
::8.56994

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [PasswordCriteria]
  LSP: Info: Seft type: [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [PasswordCriteria]
  LSP: Info: Seft type: [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [PasswordCriteria]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "c" | "calculateStrength" | "case " | "ceil" | "cos" | "criteria" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
1:20.6606
2:19.2325
3:18.4794
4:15.2063
0:14.6778
 :13.6477
5:13.4622
)):12.7413	rejected
6:12.1516
[:11.7729
7:11.3477
9:11.2751
(:11.065
c:10.9433
s:10.9171
sin:10.5805
_:10.54	rejected
i:10.5138
8:10.3262
):10.3239	rejected
list:10.1661	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <1>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Integer literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [PasswordCriteria]
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (List (Var "PasswordCriteria")); syn = Int})))
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: 1
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: 1
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: criteria c action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-floatlit | extend-intlit
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= completions | new-tokens

Top 20 Logits:
)):18.3555
):15.1287
@:12.5359
 :12.3288
 ):11.937
 @:11.3647

:10.6834
)),:10.5967	prefix accepted:))
 +:10.1433
),:9.85799	prefix accepted:)
));:9.52224	prefix accepted:))
))):9.32624	prefix accepted:))
))]:9.1093	prefix accepted:))
  :8.97142
 -:8.58007
))$:8.50827	prefix accepted:))
:::8.41171
)))):8.36769	prefix accepted:))
 in:8.27691	rejected
+:8.01748
@@:7.86546	prefix accepted:@

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)], (Weak + Moderate + Strong))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:18.3546
 :17.4363
 in:15.5589	rejected
  :15.1561
 end:14.9746
   :13.8412
    :13.7426
        :13.7295
      :13.464
          :13.405
                :13.3378
     :12.8838
            :12.815
 @:12.7057
 #:12.2891	rejected
           :11.9481
              :11.5503
       :11.5146
             :11.4273
end:11.2657
         :11.1547

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))


LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)], (Weak + Moderate + Strong))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 :20.7607
  :17.1246
   :16.6686
    :15.9025
 |:15.868
      :15.4616
     :15.4177
        :15.1802
|:14.9161

:14.8762
          :13.9601
       :13.498
                :13.1857
            :12.9575
#:12.6932	rejected
end:12.5122
           :12.0078
	:11.7946	rejected
(*:11.6505	prefix accepted:(
         :11.6246
              :11.5045

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
 

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
 
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)], (Weak + Moderate + Strong))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {criteria: ?, c: PasswordCriteria, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:22.2003
 end:15.5535
 #:14.771	rejected
 (*:14.5438	prefix accepted: (
 //:12.9877	prefix accepted: /
 _:12.6425	rejected

:12.6108
 in:12.1608	rejected
 else:12.1259	rejected
 /*:12.0226	prefix accepted: /
 case:11.799	rejected
 (:14.5438
 ,:11.3171
 *:11.2124
 \:11.0273
 }:11.0196	rejected
 ||:10.7748	prefix accepted: |
 <:10.7125
 where:10.5916	rejected
 /:12.9877
 (**:10.4872	prefix accepted: (

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  |

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  |
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 _:16.8966
 (:15.4438
 _,:15.1068	prefix accepted: _
 m:14.8697
 model:13.3187
 p:12.7987
 password:12.7008
 (_:11.9396	rejected
 x:11.3893
 :10.7851
 ((:10.7834	prefix accepted: (
 s:10.702
 a:10.4479
 initial:10.2385
 old:9.95852
_:9.9182
_,:9.91462	prefix accepted:_
 ,:9.47091	rejected
 ":9.32134
 ms:9.26773
 t:9.26758

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized pattern
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: ((String, [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)], (Weak + Moderate + Strong)), (UpdatePassword(String) + ClearCriteria + AddCriterion((RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)) + RemoveCriterion((RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar))))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Parenthesized pattern
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Parenthesized pattern
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: ((String, [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)], (Weak + Moderate + Strong)), (UpdatePassword(String) + ClearCriteria + AddCriterion((RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)) + RemoveCriterion((RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar))))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Parenthesized pattern
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "()" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= completions | new-tokens

Top 20 Logits:
password:15.1751
p:14.7029
_,:14.5676	prefix accepted:_
pass:13.0076
old:12.5104
current:11.6526
m:10.886
s:10.8046
x:10.7689
ps:10.7204
a:10.584
model:10.5492
sin:10.1343
cur:9.99816
pas:9.74686
curr:9.71923
prev:9.29904
u:9.24529
 password:9.19018
str:9.1679
original:9.13071

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Wildcard
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Wildcard
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: _
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: _
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")" | ","
root ::= new-tokens

Top 20 Logits:
 ,:16.696
::13.6322	rejected
 as:13.0755	rejected
),:12.7591
:::12.6947	rejected
password:12.661	rejected
 ::11.8949	rejected
@:11.8495	rejected
 :::11.7521	rejected
p:11.5378	rejected
 @:10.5769	rejected
|:10.2593	rejected
x:10.2541	rejected
 |:10.0859	rejected
  :10.0622
pass:10.0104	rejected
 +:9.93794	rejected
,":9.8016	prefix accepted:,
 :9.75482
:@:9.74884	rejected
Password:9.28481	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ ,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ ,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: ((String, [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)], (Weak + Moderate + Strong)), (UpdatePassword(String) + ClearCriteria + AddCriterion((RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)) + RemoveCriterion((RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar))))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: ((String, [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)], (Weak + Moderate + Strong)), (UpdatePassword(String) + ClearCriteria + AddCriterion((RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)) + RemoveCriterion((RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar))))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 Update:15.9824
 _:12.8552
 password:12.3283
 _):11.3676	prefix accepted: _
 m:11.3444
 _,:11.1325	prefix accepted: _
 (:11.1172
 p:10.9696
 (_:10.363	rejected
Update:10.3192
 :9.52883
password:9.22474
 Min:9.1648
 Password:8.9857	rejected
 s:8.92951
_:8.89725

:8.7626
 model:8.68392
 x:8.59379
 update:8.42727
 Model:8.41586	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , Update

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , Update
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Update>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "Update"))))
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  Update
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Update
LSP: Generating Completions for prefix: Update
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Password"
root ::= completions

Top 20 Logits:
Password:21.8749
P:12.5156
Pass:12.3837
C:12.0989	rejected
password:11.2577	rejected
(:11.1485	rejected
(_:10.9341	rejected
_:10.2299	rejected
 Password:10.1829	rejected
 password:9.39727	rejected
 _:9.25292	rejected
Text:9.16167	rejected
Action:9.15762	rejected
User:9.01512	rejected
Str:8.8821	rejected
Login:8.8474	rejected
Username:8.83201	rejected
Pa:8.64797
):8.54134	rejected
Model:8.53565	rejected
 (:8.42716	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <UpdatePassword>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (String -> (UpdatePassword(String) + ClearCriteria + AddCriterion((RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)) + RemoveCriterion((RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar))))
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Var "Action");
           syn = (Arrow (String, (Var "Action")))})))
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  UpdatePassword
Nature of error: Expecting type Action but got inconsistent type (String -> Action)
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: UpdatePassword
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: UpdatePassword
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")" | ","
root ::= new-tokens

Top 20 Logits:
(:16.7188
(_:15.3334	rejected
(":12.5262	prefix accepted:(
 p:12.2562	rejected
 password:11.9586	rejected
):11.1773
 s:10.8718	rejected
 (:10.839
((:10.783	prefix accepted:(
 _):10.5105	rejected
),:10.1828
 str:10.1529	rejected
()):10.0422	prefix accepted:(
 new:9.48795	rejected
 _:9.48748	rejected
(?:8.98967	prefix accepted:(
 (_:8.88557	rejected
(@:8.82138	prefix accepted:(
(':8.76052	prefix accepted:(
 pass:8.66862	rejected
)(:8.64742	prefix accepted:)

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (UpdatePassword(String) + ClearCriteria + AddCriterion((RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)) + RemoveCriterion((RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (UpdatePassword(String) + ClearCriteria + AddCriterion((RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)) + RemoveCriterion((RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: String
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "()" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= completions | new-tokens

Top 20 Logits:
password:17.0107
p:16.5767
s:15.5674
new:15.3386
pass:14.3244
str:13.7276
x:12.9149
text:12.6855
input:12.3558
string:12.1624
n:12.1316
ps:12.0601
value:11.8985
v:11.261
txt:11.0561
c:10.8335
np:10.8113
updated:10.758
up:10.6351
pas:10.4217
next:10.3711

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <password>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: String
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {password: String, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: password
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: password
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
)):16.1873
)),:15.9792	prefix accepted:))
),:14.1121
):14.0434
::13.97	rejected
)::12.084	prefix accepted:)
))::11.6517	prefix accepted:))
_:11.3376
@:10.8213	rejected
))):10.8094	prefix accepted:))
')):10.5353	rejected
'):9.80038	rejected
 ::9.65782	rejected
'),:9.54248	rejected
 as:9.49756	rejected
,:9.39011
))]:9.24925	prefix accepted:))
));:9.23003	prefix accepted:))
:::9.00506	rejected
New:8.99246
':8.84967	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password))

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password))
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized pattern
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: ((String, [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)], (Weak + Moderate + Strong)), (UpdatePassword(String) + ClearCriteria + AddCriterion((RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)) + RemoveCriterion((RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar))))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {password: String, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Parenthesized pattern
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:17.3671
 ->:14.2442	rejected
 when:13.1923	rejected

:11.9419
 :11.6045
=>:11.4975
 as:11.4733	rejected
 |:10.9891	rejected
 +:10.6744	rejected
 if:10.6018	rejected
 in:10.3152	rejected
 ,:10.1532
 =:10.0845
 ||:10.0134	rejected
 :::9.92669	rejected
->:9.55233	rejected
  :9.35482
|:9.3486	rejected
 &&:9.32011	rejected
 _:9.30316	rejected
 m:9.03825	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {password: String, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: password action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "calculateStrength" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "password" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:17.8584
 (:16.38
 :15.9227
 m:14.4259
  :14.3137
 ((:13.6627	prefix accepted: (
 (_:13.5321	rejected
 (*:13.1094	prefix accepted: (
 let:13.096
    :12.7964
   :12.795
 update:12.6763
 {:12.4075	rejected
 calculate:12.2057
                :12.1953
      :12.0938
     :11.9557
        :11.7576
 (":11.6964	prefix accepted: (
 sin:11.5436
 _:11.5401	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>


LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {password: String, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: password action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "calculateStrength" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "password" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
   :19.1784
    :18.0922
     :17.5073
      :15.6575
  :14.8069
       :13.348
        :13.144
 :12.9151
          :11.662
	:11.4254	rejected
         :11.3327

:11.227
           :10.9505
                :10.832
#:10.688	rejected
            :10.3274
             :10.0647
              :9.58396
(:9.55099
               :9.47072
 (:9.17652

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
   

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
   
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {password: String, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: password action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "calculateStrength" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "password" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 let:20.1268
 (:18.9559
 (_:16.6157	rejected
 ((:16.6005	prefix accepted: (
 case:15.9415
 m:15.9413
 if:15.8695
 match:15.1661	rejected
 (*:15.0211	prefix accepted: (
 calculate:14.9761
 update:14.9303
 _:14.4406	rejected
 List:14.3457	rejected
 {:14.2086	rejected
 (":13.8121	prefix accepted: (
 ([:13.5048	prefix accepted: (
 #:13.4337	rejected
 s:13.3572
 ({:13.09	prefix accepted: (
 sin:13.0883
 model:12.9511	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {password: String, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 criteria:14.2196
 strength:14.0745
 password:11.775
 old:11.5333
 new:11.4453
 model:11.2126
 _:11.1293
 (:11.0845
 m:10.8734
 length:10.8553
 str:10.6477
 s:10.5873
 met:10.2567
 c:9.5862
 _,:9.27497	prefix accepted: _
 p:9.24633
 criter:9.22243
 len:9.18139
 current:9.14208

:9.08848
 :8.91912

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <strength>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {strength: ?, password: String, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: strength
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: strength
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
 =:19.1074
::14.6507
_:12.4521
 ::12.3934
':11.8899	rejected
=:11.6072
,:11.5158
 :11.3222
s:10.992
en:10.2634
  :10.1588
ened:10.021
Of:9.98193
 in:9.71791	rejected
In:9.34832
;:9.25414	rejected
 :=:9.1114	prefix accepted: :
1:9.00567

:8.67259
    :8.53792
C:8.49666

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength =

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength =
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {password: String, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: password action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "calculateStrength" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "password" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 calculate:15.9506

:12.685
 :12.2424
 sin:12.0204
 strength:11.7705
 s:11.7278
 (:11.233
 m:11.0377
 password:10.5214
 Calcul:10.1696	rejected
 if:10.1482
 in:9.94324
calcul:9.78142
 fun:9.74236
 calc:9.526
 List:9.30924	rejected
 Password:9.21301	rejected
 _:9.14479	rejected
 f:9.08095
 Str:8.98174
 str:8.96263

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculate

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculate
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <calculate>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "calculate"))
  LSP: Info: Typing Context: {password: String, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  calculate
Nature of error: Variable calculate is not bound  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: calculate
LSP: Generating Completions for prefix: calculate
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: password action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Strength"
root ::= completions

Top 20 Logits:
Str:20.9971
_:13.3123	rejected
Password:13.2495	rejected
C:11.9518	rejected
Ste:11.0821	rejected
New:10.7431	rejected
(:10.6491	rejected
St:10.4469
S:10.335
str:10.2867	rejected
 password:10.2324	rejected
Pass:10.1922	rejected
 Str:10.1118	rejected
Strategy:9.19836	rejected
 strength:9.12432	rejected
::9.09053	rejected
@:8.79397	rejected
P:8.65604	rejected
From:8.65362	rejected
 (:8.5052	rejected

:8.50408	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStr

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStr
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <calculateStr>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "calculateStr"))
  LSP: Info: Typing Context: {password: String, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  calculateStr
Nature of error: Variable calculateStr is not bound  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: calculateStr
LSP: Generating Completions for prefix: calculateStr
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: password action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ength"
root ::= completions

Top 20 Logits:
ength:22.5847
eng:15.2346
enth:12.7719	rejected
en:10.6582
(:9.13197	rejected
 strength:8.91905	rejected
ateg:8.68063	rejected
ong:8.67101	rejected
n:8.09053	rejected

:7.99039	rejected
u:7.9182	rejected
length:7.82199	rejected
ency:7.7911	rejected
ng:7.76989	rejected
C:7.72972	rejected
ucture:7.72874	rejected
():7.56353	rejected
ang:7.45946	rejected
Length:7.37492	rejected
e:7.32892
 (:7.31526	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <calculateStrength>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ((String, [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)]) -> (Weak + Moderate + Strong))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {password: String, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: calculateStrength
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: calculateStrength
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: password action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "in"
root ::= new-tokens

Top 20 Logits:
(:20.0379
((:16.2306	prefix accepted:(
 (:14.4154
(@:14.3002	prefix accepted:(
(_:14.214	rejected
([:13.6556	prefix accepted:(
 in:12.9057
 password:12.4936	rejected

:12.3794
(?:12.2676	prefix accepted:(
({:11.9563	prefix accepted:(
():11.6653	prefix accepted:(
(":11.5814	prefix accepted:(
($:11.5492	prefix accepted:(
(|:11.1733	prefix accepted:(
(*:11.1141	prefix accepted:(
(!:11.0317	prefix accepted:(
(.:10.9819	rejected
@:10.6934
 m:10.4624	rejected
?(:10.4158	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (Weak + Moderate + Strong)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {password: String, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (Weak + Moderate + Strong)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {password: String, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {password: String, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: password action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: password action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "calculateStrength" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "password" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
password:17.5148
sin:14.9878
m:13.8116

:13.1061
s:12.7418
 password:11.7496
f:11.0522
pass:10.6141
string:10.4995
p:10.3999
str:10.366
new:10.133	rejected
_,:9.70929	rejected
String:9.5853	rejected
action:9.58487
Password:9.58445	rejected
update:9.34449
n:9.25229
c:9.2189
pas:9.214
x:9.14811	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <password>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Seft type: String
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana = (Prod [(Var "Password"); (List (Var "PasswordCriteria"))]);
           syn = String})))
  LSP: Info: Typing Context: {password: String, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  password
Nature of error: Expecting type (Password, [PasswordCriteria]) but got inconsistent type String  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: password
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: password
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: password action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:19.5895
::15.1417
@:14.3259
 ,:13.2924
):12.1562
 ::11.9152
,(:11.6159	prefix accepted:,
 @:11.5928
^:11.2283	rejected
,[:11.0295	prefix accepted:,
@@:10.8791	prefix accepted:@
.:10.8584	rejected
 m:10.4636	rejected
!,:10.3496	prefix accepted:!
:@:10.3234	prefix accepted::
:::10.2646
),:10.2142	prefix accepted:)
 in:10.1409	rejected
',:10.1147	rejected
 sin:9.7688	rejected
 +:9.75784

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Seft type: (String, [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {password: String, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Seft type: (String, [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {password: String, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [PasswordCriteria]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {password: String, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: password action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: password action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "calculateStrength" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "password" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 m:16.5997
 s:15.2315
 sin:14.0542
 List:11.6288	rejected
 criteria:11.4561	rejected
 met:11.4286
 (:10.9483
 f:10.6775
 c:10.6519

:10.1843
 :9.97888
sin:9.82493
 [:9.74023
 _:9.65306	rejected
m:9.58107
 get:8.60362	rejected
 cin:8.59776	rejected
 _):8.52565	rejected
 list:8.47927	rejected
 ):8.33223	rejected
 meet:8.25936

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <m>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [PasswordCriteria]
  LSP: Info: Seft type: (String, [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)], (Weak + Moderate + Strong))
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (List (Var "PasswordCriteria"));
           syn = (Var "Model")})))
  LSP: Info: Typing Context: {password: String, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: m
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: m
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: password action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ax_int" | "eetsCriterion" | "eetsMinLength" | "etCriteria" | "in_int" | "od"
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= completions | new-tokens

Top 20 Logits:
@:17.902
 @:12.5189
@@:10.8017	prefix accepted:@
[:10.684	rejected
):10.4771
.@:10.3962	rejected
.:10.3137	rejected
^:9.82938	rejected
#:9.80704	rejected
t:9.80101	rejected
@{:9.76866	prefix accepted:@
::9.67255
!:9.40522
l:9.21558	rejected
\:8.93032
$:8.89855
&:8.84986
%:8.78366	rejected
2:8.78053	rejected
|:8.68668	rejected
:::8.59078

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [PasswordCriteria]
  LSP: Info: Seft type: [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {password: String, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [PasswordCriteria]
  LSP: Info: Seft type: [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {password: String, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [PasswordCriteria]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {password: String, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: password action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: password action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "calculateStrength" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "password" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
1:18.3773
2:16.7111
0:14.3735
sin:13.6069
(:11.5587
@:11.4666	rejected
c:11.2965
3:11.2942
s:10.8895
#:10.4442	rejected
 :10.3922
S:10.3045
[:10.0869
_:10.0127	rejected
C:9.95714
(@:9.70162	prefix accepted:(
*:9.58884	rejected
4:9.53755
<:9.50346	rejected
i:9.27097
::9.12481	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <1>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Integer literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [PasswordCriteria]
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (List (Var "PasswordCriteria")); syn = Int})))
  LSP: Info: Typing Context: {password: String, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: 1
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: 1
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: password action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-floatlit | extend-intlit
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= completions | new-tokens

Top 20 Logits:
@:16.2309
):14.8809
 in:13.9708	rejected
),:11.0398	prefix accepted:)
 ):10.8837
 @:10.8529
in:10.5299	rejected
,:10.4366
 end:9.68632	rejected
@@:9.25015	prefix accepted:@
^:9.10644	rejected
s:8.46932	rejected
 :8.26765
 at:8.23651	rejected
#:8.05357	rejected
sin:7.99243	rejected
);:7.88377	prefix accepted:)
(:7.87678
::7.82185
*:7.79516
.:7.74693

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [PasswordCriteria]
  LSP: Info: Seft type: [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {password: String, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [PasswordCriteria]
  LSP: Info: Seft type: [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {password: String, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [PasswordCriteria]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {password: String, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: password action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: password action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "calculateStrength" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "password" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
2:16.8975
0:15.8491
1:15.2436
3:14.6153
sin:12.032
):11.5997	rejected
4:11.4322
m:11.245
c:10.9569
_):10.3738	rejected
5:9.9731
(:9.75108
()):9.74643	prefix accepted:()
*):9.55085	rejected
-:9.49894
length:9.4439	rejected
len:9.40099	rejected
6:9.37938
s:9.34333
S:9.27169
end:9.18383	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <2>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Integer literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [PasswordCriteria]
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (List (Var "PasswordCriteria")); syn = Int})))
  LSP: Info: Typing Context: {password: String, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Password, [PasswordCriteria])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: 2
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: 2
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: password action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-floatlit | extend-intlit
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= completions | new-tokens

Top 20 Logits:
):18.8335
),:15.0127	prefix accepted:)
 in:14.8349	rejected
 ):14.2422
,:12.8417
);:12.7457	prefix accepted:)
@:11.6787
)):11.3268
 @:10.7846
)(:10.7806	prefix accepted:)
in:10.5381	rejected
sin:10.428	rejected
3:10.3233
::10.2513
 -:10.2123
).:10.1921	rejected
)::10.1739	prefix accepted:)
)|:10.0917	prefix accepted:)
)]:10.0035	prefix accepted:)

:9.98128
:@:9.95448	prefix accepted::

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2)

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (Weak + Moderate + Strong)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {password: String, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "in"
root ::= new-tokens

Top 20 Logits:
 in:18.3239

:13.4541
 :12.8522
in:11.999
 and:11.3588	rejected
 @:11.2164
  :10.2728
 end:8.95827	rejected
 &&:8.93511
 sin:8.74235	rejected
@:8.61475
    :8.58881
   :8.32057
 |:8.12788	rejected
 ?:7.95014	rejected
 ->:7.6484	prefix accepted: -
      :7.61606
 #:7.48951	rejected
 :::7.44547
 ;:7.42348	rejected
     :7.40573

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {strength: PasswordStrength, password: String, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: strength password action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "calculateStrength" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "password" | "pi" | "sin" | "sqrt" | "strength" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:19.5594
 :16.5201
  :15.5196
 (:14.7983
    :14.7014
      :13.8693
     :13.4461
   :13.0357
        :12.5143
          :12.1036
 m:11.9207
                :11.8992
 (*:11.7265	prefix accepted: (
 {:11.6084	rejected
            :11.5769
       :11.1689
	:11.1175	rejected
 ((:11.0317	prefix accepted: (
           :10.8052
         :10.7123
              :10.5444

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in


LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {strength: PasswordStrength, password: String, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: strength password action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "calculateStrength" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "password" | "pi" | "sin" | "sqrt" | "strength" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
     :20.6226
      :17.3117
    :17.2366
   :16.9148
       :15.2764
        :14.5346
  :13.8403
	:12.8107	rejected
 :12.5154
         :12.4882
          :12.0556

:11.9368
           :11.4819
                :11.3646
(:11.0942
            :11.0158
#:10.669	rejected
             :10.3092
 (:10.0017
               :9.61425
              :9.57196

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
     

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
     
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {strength: PasswordStrength, password: String, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: strength password action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "calculateStrength" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "password" | "pi" | "sin" | "sqrt" | "strength" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 (:19.7569
 if:18.2531
 ((:16.9189	prefix accepted: (
 (_:16.3782	rejected
 case:16.03
 m:15.6041
 password:15.2682
 match:15.2137	rejected
 _:15.0127	rejected
 (*:14.9392	prefix accepted: (
 let:14.618
 {:14.5018	rejected
 ([:14.449	prefix accepted: (
 update:14.4352
 s:14.0594
 List:14.0144	rejected
 [:13.9033
 ({:13.6647	prefix accepted: (
 print:13.6468	rejected
 (":13.1935	prefix accepted: (
 sin:13.0219

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)], (Weak + Moderate + Strong))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {strength: PasswordStrength, password: String, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)], (Weak + Moderate + Strong))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {strength: PasswordStrength, password: String, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {strength: PasswordStrength, password: String, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: strength password action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: strength password action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "calculateStrength" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "password" | "pi" | "sin" | "sqrt" | "strength" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
password:15.4469
m:14.9841
sin:13.0052
 password:11.2899
s:10.9638
update:10.4652

:10.3508
f:9.77185
 m:9.6988
_,:9.61431	rejected
 (:9.28673
pass:9.24224
str:8.94265
Update:8.63325
p:8.60726
Password:8.40164	rejected
((:8.38474	prefix accepted:(
up:8.23989
if:8.20453
new:7.89174	rejected
 _:7.68888	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <m>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)], (Weak + Moderate + Strong))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {strength: PasswordStrength, password: String, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: m
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: m
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: strength password action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ax_int" | "eetsCriterion" | "eetsMinLength" | "etCriteria" | "in_int" | "od"
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= completions | new-tokens

Top 20 Logits:
@:17.6395
 @:13.2766
@@:10.9877	prefix accepted:@
@{:10.851	prefix accepted:@
,:10.6137
^:10.024	rejected
[:9.84758	rejected
::9.6944
&:9.61282
*:9.27399
!:9.19147
{:9.16214	rejected
(:9.04719
|:9.03734	rejected
$:8.99484
 :8.98701
f:8.82792	rejected
 +:8.80872
#:8.60825	rejected
 at:8.54983	rejected
.:8.52532	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model"); syn = (List (Unknown Internal))})))
  LSP: Info: Typing Context: {strength: PasswordStrength, password: String, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ ?
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model"); syn = (List (Unknown Internal))})))
  LSP: Info: Typing Context: {strength: PasswordStrength, password: String, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ ?
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {strength: PasswordStrength, password: String, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m @ ?
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: strength password action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: strength password action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "calculateStrength" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "password" | "pi" | "sin" | "sqrt" | "strength" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
0:19.6894
2:16.1343
1:16.1311
3:14.5558
(:13.7161
password:12.2849
{:11.8657	rejected
4:11.6711
((:11.5819	prefix accepted:(
s:10.9751
 :10.9597
f:10.9488
_:10.9412	rejected
*:10.876	rejected
[:10.866
8:10.5814
5:10.5329
9:10.4757
-:10.4675
Update:10.2663
6:10.1518

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <0>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Integer literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = (List (Unknown Internal)); syn = Int})))
  LSP: Info: Typing Context: {strength: PasswordStrength, password: String, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: 0
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: 0
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: strength password action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-floatlit | extend-intlit
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= completions | new-tokens

Top 20 Logits:
@:18.063
,:14.8476
 @:12.2866
 ,:10.8411
^:10.7448	rejected
@@:10.3594	prefix accepted:@
 +:10.3547
+:9.7289
 -:9.36137
|:9.14558	rejected
::9.06446
:::8.91928
,(:8.89401	prefix accepted:,
@{:8.84003	prefix accepted:@
*:8.82657
(:8.64973
[:8.44174	rejected
0:8.41214
#:8.30189	rejected
&:8.24843
 :8.20788

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model"); syn = (List (Unknown Internal))})))
  LSP: Info: Typing Context: {strength: PasswordStrength, password: String, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m @ 0 @ ?
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model"); syn = (List (Unknown Internal))})))
  LSP: Info: Typing Context: {strength: PasswordStrength, password: String, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m @ 0 @ ?
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {strength: PasswordStrength, password: String, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m @ 0 @ ?
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: strength password action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: strength password action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "calculateStrength" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "password" | "pi" | "sin" | "sqrt" | "strength" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
0:18.6814
1:18.4819
2:17.8673
3:16.968
4:13.7076
str:12.9033
5:12.578
password:12.0481
(:11.9449
s:11.7453
6:11.6939
8:10.9401
7:10.7858
-:10.7792
strong:10.7602	rejected
[:10.4261
9:10.4165
m:10.2825
?,:10.2683	rejected
min:10.1767
len:10.0651	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <0>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Integer literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = (List (Unknown Internal)); syn = Int})))
  LSP: Info: Typing Context: {strength: PasswordStrength, password: String, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: 0
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: 0
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: strength password action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-floatlit | extend-intlit
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= completions | new-tokens

Top 20 Logits:
,:17.6057
@:14.7421
 ,:12.8759
 password:12.4933	rejected
 @:12.415
 +:11.4438
password:10.6075	rejected
):10.5539
::10.4423
:::10.2025
),:9.89014	prefix accepted:)
 ::9.85337
(:9.75732
,(:9.69667	prefix accepted:,
 ->:9.39713	prefix accepted: -
+:9.3345
 |:9.27621	rejected
 =:9.10646
 -:9.39713
^:9.08253	rejected
|:9.00078	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([?], ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model");
           syn = (Prod [(List (Unknown Internal)); (Unknown Internal)])})))
  LSP: Info: Typing Context: {strength: PasswordStrength, password: String, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0, ?
Nature of error: Expecting type Model but got inconsistent type ([?], ?)  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ([?], ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model");
           syn = (Prod [(List (Unknown Internal)); (Unknown Internal)])})))
  LSP: Info: Typing Context: {strength: PasswordStrength, password: String, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0, ?
Nature of error: Expecting type Model but got inconsistent type ([?], ?)  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {strength: PasswordStrength, password: String, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0, ?
Nature of error: Expecting type Model but got inconsistent type ([?], ?)  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: strength password action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: strength password action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "calculateStrength" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "password" | "pi" | "sin" | "sqrt" | "strength" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 m:15.7746
 password:14.3967
 sin:13.5859
 s:11.7123

:11.5656
m:10.8193
 :10.7512
 strength:10.6726
 (:10.4024
sin:10.054
 _:9.72128	rejected
 List:9.61614	rejected
 [:9.27323
 met:9.2498
 _,:9.19038	rejected
password:9.13382
 Password:8.54149	rejected
 str:8.4414
 calculate:8.34151
 c:8.22503
  :8.1756

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <password>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: String
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {strength: PasswordStrength, password: String, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0, password
Nature of error: Expecting type Model but got inconsistent type ([?], String)  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: password
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: password
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: strength password action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:16.9476
:::15.0624
):12.7116
@:12.3653
 :::12.1212
::11.876
 ,:11.5564
 @:11.4245
),:10.9462	prefix accepted:)
 ::9.73847
_:9.45241	rejected
@@:9.35696	prefix accepted:@
 in:9.23582	rejected
.:9.22056	rejected
 as:9.14596	rejected
 =:9.1225
 +:8.96289

:8.90595
 ):8.76113
:@:8.6861	prefix accepted::
 ==:8.54876

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password,

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (?, ?, (Weak + Moderate + Strong))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {strength: PasswordStrength, password: String, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  password
Nature of error: Expecting type Criteria but got inconsistent type String  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (?, ?, (Weak + Moderate + Strong))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {strength: PasswordStrength, password: String, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  password
Nature of error: Expecting type Criteria but got inconsistent type String  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Strength
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {strength: PasswordStrength, password: String, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  password
Nature of error: Expecting type Criteria but got inconsistent type String  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: strength password action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: strength password action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "calculateStrength" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "password" | "pi" | "sin" | "sqrt" | "strength" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 strength:15.7068
 m:13.2582
 sin:13.1988
 str:11.2055
 calculate:10.7594
 s:10.683
 :10.6674
 criteria:10.6596	rejected

:10.4816
 (:9.98596
 c:9.65275
 length:9.53912	rejected
 if:9.30191
 [:9.2426
 List:9.21948	rejected
str:9.05166
 _:9.04936	rejected
 met:8.89964
 Str:8.68688
 password:8.65851
 strong:8.59069	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <strength>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Strength
  LSP: Info: Seft type: (Weak + Moderate + Strong)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {strength: PasswordStrength, password: String, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  password
Nature of error: Expecting type Criteria but got inconsistent type String  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: strength
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: strength
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: strength password action m update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_of"
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= completions | new-tokens

Top 20 Logits:
):18.5166
 ):15.5095
@:13.0629
,:12.1494
);:12.0968	prefix accepted:)
 @:11.9387
),:11.9377	prefix accepted:)

:11.8752
 in:11.4747	rejected
)):11.4049
 :11.018
)]:10.6041	prefix accepted:)
s:10.0824	rejected
)|:10.0016	prefix accepted:)
::9.84755
 end:9.80392	rejected
)::9.73606	prefix accepted:)
)}:9.71909	prefix accepted:)
  :9.65639
 *:9.61022
 ==:9.29114

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)], (Weak + Moderate + Strong))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {strength: PasswordStrength, password: String, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  password
Nature of error: Expecting type Criteria but got inconsistent type String  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:18.456
 end:17.8853
 :16.7847
 in:16.2615	rejected
  :16.2009
    :15.032
      :14.5539
                :14.1574
        :13.8545
 @:13.5307
   :13.3701
          :13.1833
end:12.9944
 #:12.8617	rejected
         :12.8604
            :12.8256
     :12.485
              :12.0779
	:11.9413	rejected
           :11.8941
       :11.8282

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)


LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)], (Weak + Moderate + Strong))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {strength: PasswordStrength, password: String, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  password
Nature of error: Expecting type Criteria but got inconsistent type String  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 :17.5999
end:17.311
  :15.5816
 end:15.2802
   :14.9137
      :14.428
    :14.2343

:13.7899
        :13.4125
in:13.1466	rejected
|:13.0432
     :12.8548
#:12.5687	rejected
       :12.2442
 in:11.7718	rejected
          :11.7198
                :11.5498
else:11.4017	rejected
         :11.2837
(*:10.9937	prefix accepted:(
            :10.9336

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
 

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
 
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)], (Weak + Moderate + Strong))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {strength: PasswordStrength, password: String, action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  password
Nature of error: Expecting type Criteria but got inconsistent type String  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 end:20.7893
 |:17.7229
 else:14.9302	rejected
 #:14.2693	rejected
 (*:13.2336	prefix accepted: (
 in:12.8529	rejected
 where:11.8782	rejected

:11.5003
 //:11.4781	prefix accepted: /
 case:11.4182	rejected
 with:11.3953	rejected
 }:11.1767	rejected
 @:11.1364
 >:10.9845
 if:10.9591	rejected
 ||:10.819	prefix accepted: |
 _:10.8066	rejected
 *:10.4211
 of:10.241	rejected
 ]:10.161	rejected
 \:10.072

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
  end

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
  end
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <case end>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Case expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)], (Weak + Moderate + Strong))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  password
Nature of error: Expecting type Criteria but got inconsistent type String  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Model, Action) -> Model)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "in"
root ::= new-tokens

Top 20 Logits:
 in:16.6086

:16.1663
 :14.4748
  :13.6723
;:12.6866	rejected
    :12.373
 end:12.3178	rejected
      :11.2673
 with:11.1854	rejected
 where:11.1358	rejected
   :10.8999
                :10.7641
        :10.6145
in:10.1911
 ;:10.0174	rejected
 #:9.91474	rejected
#:9.86618	rejected
     :9.86225
 match:9.83642	rejected
	:9.59784	rejected
;;:9.56283	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
  end


LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
  end

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <case end>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Case expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar)], (Weak + Moderate + Strong))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  password
Nature of error: Expecting type Criteria but got inconsistent type String  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Model, Action) -> Model)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "in"
root ::= new-tokens

Top 20 Logits:
in:17.9707

:15.6566
  :15.5568
end:15.1775	rejected
 :15.1173
    :14.8031
#:14.5285	rejected
      :13.874
   :13.2459
 in:12.8134
```:12.4742	rejected
|:12.3196	rejected
        :12.2084
     :11.6622
                :11.6032
with:11.377	rejected
let:11.1451	rejected
          :11.0601
;;:11.0269	rejected
;:10.8674	rejected
            :10.7648

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
  end
in

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
  end
in
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  password
Nature of error: Expecting type Criteria but got inconsistent type String  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "calculateStrength" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:15.7203
 :12.753
  :12.4544
 update:12.4031
    :11.7542
      :10.9324
 {:10.4337	rejected
 initial:10.047
   :9.91735
                :9.72116
 #:9.4749	rejected
        :9.32588
 (:9.32296
     :9.21293
 [:9.19558
          :9.07652
;:8.6646	rejected
	:8.62756	rejected
         :8.46188
            :8.45119
       :8.39259

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
  end
in


LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
  end
in

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  password
Nature of error: Expecting type Criteria but got inconsistent type String  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "calculateStrength" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:17.4278
  :16.549
    :15.8129
#:15.6334	rejected
      :14.4291
let:14.0569
update:13.7148
 :13.464
```:13.3167	rejected
        :13.2764
                :12.7651
   :12.6717
          :12.3034
print:11.9462	rejected
     :11.881
            :11.6574
         :11.436
"":11.3632
initial:11.1772
(*:11.149	prefix accepted:(
       :11.0841

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
  end
in
  

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
  end
in
  
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  password
Nature of error: Expecting type Criteria but got inconsistent type String  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "calculateStrength" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:19.4676
 update:14.7752
 #:13.8697	rejected
	:12.7184	rejected
 initial:12.5872
 print:12.485	rejected
 {:12.4747	rejected
 let:12.1069
 (:12.0859
0:11.9645
 (*:11.6344	prefix accepted: (
 [:11.6132
 ":11.2268
1:11.0867
3:10.8443
 *:10.7508	rejected
 "":10.6057
 m:10.6038
 List:10.5694	rejected
 "#:10.5557
 ```:10.4915	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
  end
in
  


LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
  end
in
  

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  password
Nature of error: Expecting type Criteria but got inconsistent type String  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: update calculateStrength strength_of metCriteria meetsCriterion hasSpecialChar hasNumber hasLowercase hasUppercase hasFromSet meetsMinLength initialModel string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "calculateStrength" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hasFromSet" | "hasLowercase" | "hasNumber" | "hasSpecialChar" | "hasUppercase" | "if " | "infinity" | "initialModel" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "meetsCriterion" | "meetsMinLength" | "metCriteria" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "strength_of" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
#:15.2063	rejected
let:14.5723
type:13.2521

:11.4656
update:10.8351
  :10.7389
(*:10.512	prefix accepted:(
 :10.4248
module:10.31	rejected
print:10.3022	rejected
    :10.2332
open:10.138	rejected
initial:9.91639
 #:9.37301	rejected
{:9.29776	rejected
List:9.23586	rejected
      :8.96059
   :8.79168
(:10.512
##:8.64108	rejected
printf:8.62124	rejected
Rejected the highest logit candidate # with logit -inf

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
  end
in
  
let

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
  end
in
  
let
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  password
Nature of error: Expecting type Criteria but got inconsistent type String  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddCriterion" | "ClearCriteria" | "MinimumLength" | "Moderate" | "RemoveCriterion" | "RequireLowercase" | "RequireNumber" | "RequireSpecialChar" | "RequireUppercase" | "Strong" | "UpdatePassword" | "Weak" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 view:13.4517
 update:11.372
 main:10.978
 model:10.5399
 password:10.5308
 render:10.5248
 display:10.2018
 get:10.1708
 on:10.0224
 string:9.96355
 check:9.91176
 show:9.72598
 is:9.54571
 Password:9.51905	rejected
 init:9.45151
 html:9.44864
 View:9.42809	rejected
 meets:9.41751
 strength:9.35262
 test:9.34373
 initial:9.24395

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
  end
in
  
let view

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
  end
in
  
let view
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <view>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {view: ?, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  password
Nature of error: Expecting type Criteria but got inconsistent type String  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: view
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: view
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
::15.7679
Model:12.0514
Password:12.0121
_:11.5103
 ::11.3832
 =:11.2541
Str:11.1682
C:10.9094
 model:9.6511	rejected
Pass:9.48895
Action:9.43351
 (:9.40362
P:9.27918
model:8.70389
 password:8.51298	rejected
Input:8.43378
:(:8.35815	prefix accepted::
(:8.24104
Main:8.1647
With:8.09263
String:8.04734

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
  end
in
  
let view:

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
  end
in
  
let view:
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >:<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Annotation
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {view: ?, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  password
Nature of error: Expecting type Criteria but got inconsistent type String  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Annotation
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {view: ?, update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  password
Nature of error: Expecting type Criteria but got inconsistent type String  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty type hole
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  password
Nature of error: Expecting type Criteria but got inconsistent type String  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex or complete: :
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Strength Criteria Password PasswordStrength PasswordCriteria () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: :
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: UpdatePassword ClearCriteria AddCriterion RemoveCriterion Weak Moderate Strong Weak Moderate Strong RequireUppercase RequireLowercase MinimumLength RequireNumber RequireSpecialChar () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ":"
new-tokens ::= whitespace | "(" | "()" | "+" | "Action" | "Bool" | "Criteria" | "Float" | "Int" | "Model" | "Password" | "PasswordCriteria" | "PasswordStrength" | "Strength" | "String" | "[" | constructor
root ::= completions | new-tokens

Top 20 Logits:
 Model:16.6744
 (:14.5837
 ?:13.5368	rejected
 ((:12.1847	prefix accepted: (
 Password:12.0743
 (?:12.052	prefix accepted: (
 ([:12.0118	prefix accepted: (
 View:11.9678
 [:11.4739
 String:11.3456
 Int:11.2439
 ():10.6168
 :10.0917
Model:9.95735
 Html:9.82867
 Action:9.71088
 {:9.54688	rejected
 fun:9.46819	rejected
 Str:9.43613
 C:9.09403
 (_:9.08223	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
  end
in
  
let view: Model

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
  end
in
  
let view: Model
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Model>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  password
Nature of error: Expecting type Criteria but got inconsistent type String  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: Model
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Model
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Strength Criteria Password PasswordStrength PasswordCriteria () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
new-tokens ::= whitespace | "(" | "+" | "," | "->" | "="
root ::= completions | new-tokens

Top 20 Logits:
 ->:19.2852
->:12.9401
 =>:12.8531	prefix accepted: =
 *:11.9395	rejected
 =:12.8531
 :11.0579
 ~:10.8515	rejected
 -:10.6121
,:10.5868
 +:10.2616
 >:9.95578	rejected
 <:9.67033	rejected
 (*:9.51688	prefix accepted: (
 #:9.42815	rejected

:9.39718
 -->:9.36232	prefix accepted: -
 →:9.26662	rejected
 Render:9.24628	rejected
*:9.18175	rejected
 @:9.17213	rejected
.:9.08918	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
  end
in
  
let view: Model ->

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
  end
in
  
let view: Model ->
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >-><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Function type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  password
Nature of error: Expecting type Criteria but got inconsistent type String  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Function type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  password
Nature of error: Expecting type Criteria but got inconsistent type String  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty type hole
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  password
Nature of error: Expecting type Criteria but got inconsistent type String  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex or complete: ->
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Strength Criteria Password PasswordStrength PasswordCriteria () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ->
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Strength Criteria Password PasswordStrength PasswordCriteria () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "+" | "Action" | "Bool" | "Criteria" | "Float" | "Int" | "Model" | "Password" | "PasswordCriteria" | "PasswordStrength" | "Strength" | "String" | "[" | constructor
root ::= new-tokens

Top 20 Logits:
 Html:14.8553
 String:13.5927
 View:12.6805
 [:11.583
 ?:11.5019	rejected
 Dom:11.1956
 Page:10.7227
 (:10.71
 React:10.6485
 Password:10.6279
 DOM:10.5544
 Int:10.5285
 _:10.4725	rejected
 Mark:10.4473
 Model:10.4394
 html:10.3987	rejected
 <:10.2858	rejected
 HTML:10.2303
 Action:9.78368
 Element:9.77209
 Node:9.69994

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
  end
in
  
let view: Model -> Html

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
  end
in
  
let view: Model -> Html
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Html>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ (FreeTypeVariable "Html"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  password
Nature of error: Expecting type Criteria but got inconsistent type String  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  Html
Nature of error: Type variable Html is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Html
LSP: Generating Completions for prefix: Html
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Strength Criteria Password PasswordStrength PasswordCriteria () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
 =:12.8778	rejected
.:11.7143	rejected
(:10.6579	rejected
 Action:10.4648	rejected
<:10.293	rejected
Element:9.85353
Node:9.59108
 Msg:9.56766	rejected
Action:9.53145
 Element:9.04109	rejected
 msg:8.63269	rejected
[:8.61162	rejected
 String:8.58448	rejected
():8.51488	rejected
 View:8.44379	rejected
 Node:8.42725	rejected
 in:8.39243	rejected
 ->:8.35023	rejected
Model:8.30706

:8.28744	rejected
 +:8.27219	rejected
Rejected the highest logit candidate  = with logit -inf

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
  end
in
  
let view: Model -> HtmlNode

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
  end
in
  
let view: Model -> HtmlNode
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlNode>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ (FreeTypeVariable "HtmlNode"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  password
Nature of error: Expecting type Criteria but got inconsistent type String  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  HtmlNode
Nature of error: Type variable HtmlNode is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlNode
LSP: Generating Completions for prefix: HtmlNode
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Strength Criteria Password PasswordStrength PasswordCriteria () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
 =:13.9681	rejected
 Action:11.5169	rejected
<:10.1799	rejected
(:10.0779	rejected
=:9.20701	rejected
 String:9.15051	rejected
 *:9.10643	rejected
Action:8.90868
 [:8.48426	rejected
 :8.34699	rejected
([:8.30404	rejected
.:8.22096	rejected
 ->:8.21219	rejected
[:8.21088	rejected
 in:8.18514	rejected
[]:8.13074	rejected
 Body:8.1259	rejected
 action:8.10024	rejected

:8.08099	rejected
 Void:7.8952	rejected
 {:7.78277	rejected
Rejected the highest logit candidate  = with logit -inf

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
  end
in
  
let view: Model -> HtmlNodeType

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
  end
in
  
let view: Model -> HtmlNodeType
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlNodeType>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ (FreeTypeVariable "HtmlNodeType"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  password
Nature of error: Expecting type Criteria but got inconsistent type String  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  HtmlNodeType
Nature of error: Type variable HtmlNodeType is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlNodeType
LSP: Generating Completions for prefix: HtmlNodeType
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Strength Criteria Password PasswordStrength PasswordCriteria () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
 =:13.5841	rejected
<:10.9321	rejected
(:10.7011	rejected
 *:10.1162	rejected
 in:10.0069	rejected
=:9.81873	rejected
 ->:9.29583	rejected
 :9.20983	rejected
.:9.00707	rejected
 Action:8.9009	rejected
 +:8.79811	rejected
 [:8.7007	rejected
([:8.69289	rejected
[:8.37942	rejected
[]:8.32294	rejected

:8.30473	rejected
*:8.20213	rejected
(*:8.06197	rejected
 (*:7.78374	rejected
():7.76188	rejected
 (:7.64639	rejected
Rejected the highest logit candidate  = with logit -inf

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
  end
in
  
let view: Model -> HtmlNodeType_

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
  end
in
  
let view: Model -> HtmlNodeType_
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlNodeType_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ (FreeTypeVariable "HtmlNodeType_"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  password
Nature of error: Expecting type Criteria but got inconsistent type String  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  HtmlNodeType_
Nature of error: Type variable HtmlNodeType_ is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlNodeType_
LSP: Generating Completions for prefix: HtmlNodeType_
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Strength Criteria Password PasswordStrength PasswordCriteria () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
 =:11.3881	rejected
Html:10.2371
Element:10.0172
element:9.84918
Body:9.60492
body:8.99376
String:8.88549
Action:8.83597
html:8.73748
3:8.70434
1:8.68275
S:8.63377
<:8.54717	rejected
Raw:8.54231
div:8.52643
Password:8.49506
V:8.48645
 in:8.44147	rejected
of:8.31034
E:8.25844
Text:8.25755
Rejected the highest logit candidate  = with logit -inf

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
  end
in
  
let view: Model -> HtmlNodeType_Body

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
  end
in
  
let view: Model -> HtmlNodeType_Body
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlNodeType_Body>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ (FreeTypeVariable "HtmlNodeType_Body"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  password
Nature of error: Expecting type Criteria but got inconsistent type String  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  HtmlNodeType_Body
Nature of error: Type variable HtmlNodeType_Body is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlNodeType_Body
LSP: Generating Completions for prefix: HtmlNodeType_Body
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Strength Criteria Password PasswordStrength PasswordCriteria () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
 =:13.1978	rejected
Element:12.1456
Content:11.6174
Contents:10.5989
Node:10.5558
El:10.3371
Children:10.088
.:10.0814	rejected
Child:9.95028
_:9.86069
Tag:9.59494
E:9.49429
Elements:9.3519
Html:9.3283
(:9.23202	rejected
Item:8.98734
[]:8.74204	rejected
 *:8.69914	rejected
=:8.38629	rejected
():8.37362	rejected
Attributes:8.37267
Rejected the highest logit candidate  = with logit -inf

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
  end
in
  
let view: Model -> HtmlNodeType_BodyContents

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
  end
in
  
let view: Model -> HtmlNodeType_BodyContents
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlNodeType_BodyContents>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ (FreeTypeVariable "HtmlNodeType_BodyContents"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  password
Nature of error: Expecting type Criteria but got inconsistent type String  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  HtmlNodeType_BodyContents
Nature of error: Type variable HtmlNodeType_BodyContents is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlNodeType_BodyContents
LSP: Generating Completions for prefix: HtmlNodeType_BodyContents
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Strength Criteria Password PasswordStrength PasswordCriteria () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
 =:13.0254	rejected
_:9.56105
(:9.00779	rejected
List:8.83901
 :8.7776	rejected
Element:8.75333
[]:8.51085	rejected
=:8.50701	rejected
.:8.48507	rejected
Item:8.28996
':8.28008	rejected
Html:8.25424
Node:8.14117
*:8.12343	rejected
 *:8.10169	rejected
El:8.09437
__:8.07912
<:8.03605	rejected
 ->:7.94945	rejected
Type:7.85488
[:7.78376	rejected
Rejected the highest logit candidate  = with logit -inf

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
  end
in
  
let view: Model -> HtmlNodeType_BodyContents_

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
  end
in
  
let view: Model -> HtmlNodeType_BodyContents_
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlNodeType_BodyContents_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ (FreeTypeVariable "HtmlNodeType_BodyContents_"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  password
Nature of error: Expecting type Criteria but got inconsistent type String  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  HtmlNodeType_BodyContents_
Nature of error: Type variable HtmlNodeType_BodyContents_ is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlNodeType_BodyContents_
LSP: Generating Completions for prefix: HtmlNodeType_BodyContents_
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Strength Criteria Password PasswordStrength PasswordCriteria () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
Html:11.5211
Element:11.363
 =:10.5729	rejected
Body:10.5028
Div:10.4816
element:10.296
1:10.0923
3:10.0917
Content:9.99371
Children:9.74914
4:9.68725
2:9.6706
Tags:9.65702
List:9.64884
Only:9.63975
P:9.63335
body:9.61865
M:9.55082
Tag:9.45116
String:9.44137
6:9.43031

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
  end
in
  
let view: Model -> HtmlNodeType_BodyContents_Element

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
  end
in
  
let view: Model -> HtmlNodeType_BodyContents_Element
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlNodeType_BodyContents_Element>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ (FreeTypeVariable "HtmlNodeType_BodyContents_Element"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  password
Nature of error: Expecting type Criteria but got inconsistent type String  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  HtmlNodeType_BodyContents_Element
Nature of error: Type variable HtmlNodeType_BodyContents_Element is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlNodeType_BodyContents_Element
LSP: Generating Completions for prefix: HtmlNodeType_BodyContents_Element
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Strength Criteria Password PasswordStrength PasswordCriteria () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
 =:12.9068	rejected
Content:11.8667
Contents:11.0343
Node:10.8655
Type:10.4119
_:10.1411
Children:9.95606
Types:9.95321
(:9.41597	rejected
 *:9.29465	rejected
In:9.10548
Attributes:9.06682
 :8.81942	rejected
 ->:8.8056	rejected
=:8.78604	rejected
Like:8.7779
Attribute:8.72377
 in:8.69228	rejected
():8.66937	rejected
Class:8.66592
Plus:8.61773
Rejected the highest logit candidate  = with logit -inf

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
  end
in
  
let view: Model -> HtmlNodeType_BodyContents_ElementContent

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
  end
in
  
let view: Model -> HtmlNodeType_BodyContents_ElementContent
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlNodeType_BodyContents_ElementContent>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ (FreeTypeVariable "HtmlNodeType_BodyContents_ElementContent"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  password
Nature of error: Expecting type Criteria but got inconsistent type String  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  HtmlNodeType_BodyContents_ElementContent
Nature of error: Type variable HtmlNodeType_BodyContents_ElementContent is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlNodeType_BodyContents_ElementContent
LSP: Generating Completions for prefix: HtmlNodeType_BodyContents_ElementContent
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Strength Criteria Password PasswordStrength PasswordCriteria () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
 =:12.5347	rejected
_:12.0933
 *:9.13664	rejected
 :9.03808	rejected
Types:8.96572
=:8.7586	rejected
__:8.6636
<:8.65766	rejected
Spec:8.46661
 ->:8.41693	rejected

:8.35693	rejected
.:8.34088	rejected
Fun:8.33234
(:8.33097	rejected
_(:8.26851	prefix accepted:_
[]:7.99554	rejected
_*:7.95455	prefix accepted:_
*:7.87187	rejected
Text:7.87047
S:7.84091
In:7.80607
Rejected the highest logit candidate  = with logit -inf

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
  end
in
  
let view: Model -> HtmlNodeType_BodyContents_ElementContent_

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
  end
in
  
let view: Model -> HtmlNodeType_BodyContents_ElementContent_
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlNodeType_BodyContents_ElementContent_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ (FreeTypeVariable "HtmlNodeType_BodyContents_ElementContent_"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  password
Nature of error: Expecting type Criteria but got inconsistent type String  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  HtmlNodeType_BodyContents_ElementContent_
Nature of error: Type variable HtmlNodeType_BodyContents_ElementContent_ is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlNodeType_BodyContents_ElementContent_
LSP: Generating Completions for prefix: HtmlNodeType_BodyContents_ElementContent_
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Strength Criteria Password PasswordStrength PasswordCriteria () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
Flow:12.7377
Element:12.5755
P:12.3325
Html:11.9468
Normal:11.369
Tag:11.3525
A:10.9561
Text:10.6983
Span:10.6702
In:10.5953
element:10.474
Node:10.304
Non:10.0717
Inter:9.90274
Content:9.86328
Child:9.86159
HTML:9.67966
Form:9.57955
Body:9.52319
 =:9.46046	rejected
String:9.39025

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
  end
in
  
let view: Model -> HtmlNodeType_BodyContents_ElementContent_Element

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
  end
in
  
let view: Model -> HtmlNodeType_BodyContents_ElementContent_Element
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlNodeType_BodyContents_ElementContent_Element>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ (FreeTypeVariable "HtmlNodeType_BodyContents_ElementContent_Element"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  password
Nature of error: Expecting type Criteria but got inconsistent type String  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  HtmlNodeType_BodyContents_ElementContent_Element
Nature of error: Type variable HtmlNodeType_BodyContents_ElementContent_Element is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlNodeType_BodyContents_ElementContent_Element
LSP: Generating Completions for prefix: HtmlNodeType_BodyContents_ElementContent_Element
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Strength Criteria Password PasswordStrength PasswordCriteria () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
Content:13.9277
 =:12.7684	rejected
Node:11.168
Children:11.1362
Like:10.4689
Contents:10.3747
_:10.319
Child:10.0912
Type:10.0627
Tag:9.98038
Re:9.90007
Or:9.89627
With:9.50904
Constructor:9.23749
 ->:9.14189	rejected
=:9.05114	rejected
Attribute:9.0049
(:8.87809	rejected
Class:8.84307
Description:8.83806
Body:8.81239

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
  end
in
  
let view: Model -> HtmlNodeType_BodyContents_ElementContent_ElementContent

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
  end
in
  
let view: Model -> HtmlNodeType_BodyContents_ElementContent_ElementContent
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlNodeType_BodyContents_ElementContent_ElementContent>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ
   (FreeTypeVariable
      "HtmlNodeType_BodyContents_ElementContent_ElementContent"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  password
Nature of error: Expecting type Criteria but got inconsistent type String  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  HtmlNodeType_BodyContents_ElementContent_ElementContent
Nature of error: Type variable HtmlNodeType_BodyContents_ElementContent_ElementContent is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlNodeType_BodyContents_ElementContent_ElementContent
LSP: Generating Completions for prefix: HtmlNodeType_BodyContents_ElementContent_ElementContent
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Strength Criteria Password PasswordStrength PasswordCriteria () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
_:12.827
 =:12.6396	rejected
__:10.1077

:9.71282	rejected
_*:9.3506	prefix accepted:_
 :9.11234	rejected
_(:8.99984	prefix accepted:_
Body:8.9209
=:8.6984	rejected
P:8.65697
___:8.63329
S:8.54129
Unit:8.44361
List:8.42035
 in:8.32016	rejected
Item:8.09401
*:8.02678	rejected
1:7.79532
.:7.76621	rejected
':7.72008	rejected
Non:7.69506

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
  end
in
  
let view: Model -> HtmlNodeType_BodyContents_ElementContent_ElementContent_

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
  end
in
  
let view: Model -> HtmlNodeType_BodyContents_ElementContent_ElementContent_
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlNodeType_BodyContents_ElementContent_ElementContent_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ
   (FreeTypeVariable
      "HtmlNodeType_BodyContents_ElementContent_ElementContent_"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  password
Nature of error: Expecting type Criteria but got inconsistent type String  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  HtmlNodeType_BodyContents_ElementContent_ElementContent_
Nature of error: Type variable HtmlNodeType_BodyContents_ElementContent_ElementContent_ is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlNodeType_BodyContents_ElementContent_ElementContent_
LSP: Generating Completions for prefix: HtmlNodeType_BodyContents_ElementContent_ElementContent_
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Strength Criteria Password PasswordStrength PasswordCriteria () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
Element:13.3659
P:12.6616
Html:11.7764
Text:11.2208
Flow:11.1299
element:10.767
A:10.6495
Tag:10.3802
Span:10.359
No:10.1938
Node:10.1207
Normal:10.1112
Ph:9.87406
Non:9.85333
Form:9.83654
 =:9.72344	rejected
Body:9.63711
Content:9.62139
In:9.57556
Child:9.36353
V:9.33187

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
  end
in
  
let view: Model -> HtmlNodeType_BodyContents_ElementContent_ElementContent_Element

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
  end
in
  
let view: Model -> HtmlNodeType_BodyContents_ElementContent_ElementContent_Element
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlNodeType_BodyContents_ElementContent_ElementContent_Element>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ
   (FreeTypeVariable
      "HtmlNodeType_BodyContents_ElementContent_ElementContent_Element"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  password
Nature of error: Expecting type Criteria but got inconsistent type String  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  HtmlNodeType_BodyContents_ElementContent_ElementContent_Element
Nature of error: Type variable HtmlNodeType_BodyContents_ElementContent_ElementContent_Element is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlNodeType_BodyContents_ElementContent_ElementContent_Element
LSP: Generating Completions for prefix: HtmlNodeType_BodyContents_ElementContent_ElementContent_Element
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Strength Criteria Password PasswordStrength PasswordCriteria () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
Content:15.0686
 =:12.8591	rejected
Children:10.8211
Contents:10.3462
Node:10.3044
_:10.094
Cont:10.0302
Tag:9.99826
Type:9.70511
=:9.4138	rejected
With:9.35796
Like:9.22013

:8.93119	rejected
 ->:8.74792	rejected
List:8.67677
Mod:8.65202
Re:8.56007
Or:8.53575
Attributes:8.47066
Text:8.41278
Class:8.34603

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
  end
in
  
let view: Model -> HtmlNodeType_BodyContents_ElementContent_ElementContent_ElementContent

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
  end
in
  
let view: Model -> HtmlNodeType_BodyContents_ElementContent_ElementContent_ElementContent
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlNodeType_BodyContents_ElementContent_ElementContent_ElementContent>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ
   (FreeTypeVariable
      "HtmlNodeType_BodyContents_ElementContent_ElementContent_ElementContent"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  password
Nature of error: Expecting type Criteria but got inconsistent type String  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  HtmlNodeType_BodyContents_ElementContent_ElementContent_ElementContent
Nature of error: Type variable HtmlNodeType_BodyContents_ElementContent_ElementContent_ElementContent is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlNodeType_BodyContents_ElementContent_ElementContent_ElementContent
LSP: Generating Completions for prefix: HtmlNodeType_BodyContents_ElementContent_ElementContent_ElementContent
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Strength Criteria Password PasswordStrength PasswordCriteria () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
_:13.3073
 =:13.1137	rejected

:9.84059	rejected
 :9.58819	rejected
__:9.28053
 in:9.19902	rejected
=:9.11728	rejected
_(:8.54493	prefix accepted:_
*:8.41846	rejected
 *:8.11593	rejected
 ->:7.81632	rejected
(:7.64044	rejected
<:7.59073	rejected
.:7.58756	rejected
List:7.57745
 _:7.5772	rejected
_*:7.38299	prefix accepted:_
(_:7.36964	rejected
():7.35787	rejected
[]:7.31688	rejected
->:7.27717	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
  end
in
  
let view: Model -> HtmlNodeType_BodyContents_ElementContent_ElementContent_ElementContent_

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
  end
in
  
let view: Model -> HtmlNodeType_BodyContents_ElementContent_ElementContent_ElementContent_
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlNodeType_BodyContents_ElementContent_ElementContent_ElementContent_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ
   (FreeTypeVariable
      "HtmlNodeType_BodyContents_ElementContent_ElementContent_ElementContent_"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  password
Nature of error: Expecting type Criteria but got inconsistent type String  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  HtmlNodeType_BodyContents_ElementContent_ElementContent_ElementContent_
Nature of error: Type variable HtmlNodeType_BodyContents_ElementContent_ElementContent_ElementContent_ is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlNodeType_BodyContents_ElementContent_ElementContent_ElementContent_
LSP: Generating Completions for prefix: HtmlNodeType_BodyContents_ElementContent_ElementContent_ElementContent_
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Strength Criteria Password PasswordStrength PasswordCriteria () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
Element:13.671
Html:12.2766
P:12.0265
Text:11.6617
Flow:10.8112
A:10.7689
Span:10.71
Node:10.3309
element:10.172
Tag:10.1476
Form:10.078
No:9.98125
In:9.84897
HTML:9.78588
Input:9.68523
String:9.6007
Body:9.58273
Non:9.56348
Content:9.53943
Normal:9.52163
V:9.47104

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
  end
in
  
let view: Model -> HtmlNodeType_BodyContents_ElementContent_ElementContent_ElementContent_Element

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
  end
in
  
let view: Model -> HtmlNodeType_BodyContents_ElementContent_ElementContent_ElementContent_Element
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlNodeType_BodyContents_ElementContent_ElementContent_ElementContent_Element>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ
   (FreeTypeVariable
      "HtmlNodeType_BodyContents_ElementContent_ElementContent_ElementContent_Element"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  password
Nature of error: Expecting type Criteria but got inconsistent type String  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  HtmlNodeType_BodyContents_ElementContent_ElementContent_ElementContent_Element
Nature of error: Type variable HtmlNodeType_BodyContents_ElementContent_ElementContent_ElementContent_Element is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlNodeType_BodyContents_ElementContent_ElementContent_ElementContent_Element
LSP: Generating Completions for prefix: HtmlNodeType_BodyContents_ElementContent_ElementContent_ElementContent_Element
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Strength Criteria Password PasswordStrength PasswordCriteria () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
Content:15.4424
 =:12.7435	rejected
Children:10.4962
_:10.2768
Cont:10.1964
Contents:10.1616
Tag:9.65164
Node:9.6363
Type:9.57531
=:9.4739	rejected
With:9.14724
Attributes:8.56659
List:8.55738
 ->:8.55142	rejected
Like:8.50406

:8.50043	rejected
Attribute:8.33761
Text:8.29047
Mod:8.28113
C:8.24234
 *:8.23323	rejected

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
  end
in
  
let view: Model -> HtmlNodeType_BodyContents_ElementContent_ElementContent_ElementContent_ElementContent

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
  end
in
  
let view: Model -> HtmlNodeType_BodyContents_ElementContent_ElementContent_ElementContent_ElementContent
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlNodeType_BodyContents_ElementContent_ElementContent_ElementContent_ElementContent>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ
   (FreeTypeVariable
      "HtmlNodeType_BodyContents_ElementContent_ElementContent_ElementContent_ElementContent"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  password
Nature of error: Expecting type Criteria but got inconsistent type String  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  HtmlNodeType_BodyContents_ElementContent_ElementContent_ElementContent_ElementContent
Nature of error: Type variable HtmlNodeType_BodyContents_ElementContent_ElementContent_ElementContent_ElementContent is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlNodeType_BodyContents_ElementContent_ElementContent_ElementContent_ElementContent
LSP: Generating Completions for prefix: HtmlNodeType_BodyContents_ElementContent_ElementContent_ElementContent_ElementContent
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Strength Criteria Password PasswordStrength PasswordCriteria () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
_:13.5484
 =:13.22	rejected

:9.74317	rejected
 :9.54688	rejected
 in:9.35194	rejected
=:9.25639	rejected
__:9.09791
*:8.63654	rejected
_(:8.60209	prefix accepted:_
 *:8.29443	rejected
(:7.87563	rejected
s:7.80962
 ->:7.76924	rejected
 _:7.60841	rejected
->:7.56904	rejected
():7.54924	rejected
[]:7.50987	rejected
_*:7.47768	prefix accepted:_
<:7.46778	rejected
(_:7.4211	rejected
List:7.41825

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
  end
in
  
let view: Model -> HtmlNodeType_BodyContents_ElementContent_ElementContent_ElementContent_ElementContent_

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
  end
in
  
let view: Model -> HtmlNodeType_BodyContents_ElementContent_ElementContent_ElementContent_ElementContent_
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlNodeType_BodyContents_ElementContent_ElementContent_ElementContent_ElementContent_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ
   (FreeTypeVariable
      "HtmlNodeType_BodyContents_ElementContent_ElementContent_ElementContent_ElementContent_"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  password
Nature of error: Expecting type Criteria but got inconsistent type String  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  HtmlNodeType_BodyContents_ElementContent_ElementContent_ElementContent_ElementContent_
Nature of error: Type variable HtmlNodeType_BodyContents_ElementContent_ElementContent_ElementContent_ElementContent_ is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlNodeType_BodyContents_ElementContent_ElementContent_ElementContent_ElementContent_
LSP: Generating Completions for prefix: HtmlNodeType_BodyContents_ElementContent_ElementContent_ElementContent_ElementContent_
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Strength Criteria Password PasswordStrength PasswordCriteria () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
Element:13.8789
Html:12.3585
P:12.1851
Text:11.8937
A:10.9016
Span:10.8009
Node:10.4085
In:10.3229
Flow:10.1994
element:10.1343
Form:9.9892
Tag:9.92723
No:9.8735
String:9.84938
HTML:9.79355
Input:9.7276
V:9.62388
Div:9.54913
Comment:9.4736
Body:9.41646
S:9.38156

================

# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
  end
in
  
let view: Model -> HtmlNodeType_BodyContents_ElementContent_ElementContent_ElementContent_ElementContent_Element

LSP: Command: Completions(Context)
LS: New token mode: 
# Update Password Strength Checker app model based on an action #

let update: (Model, Action) -> Model = fun m, action ->
  case m, action
  | _ , ClearCriteria => (m@0@2)
  | _ , AddCriterion(c) =>
    let criteria = sin@1 in
      (m@0@1, c::sin@1, calculateStrength(m@0@0, sin@1))
  | _ , RemoveCriterion(c) =>
     let criteria = sin@1 in
       (m@0@2,
        if c == RequireUppercase then
          [RequireLowercase, MinimumLength(8)]
        else if c == RequireLowercase then
          [RequireUppercase, MinimumLength(8) ] 
        else if c == MinimumLength(8) then
          []
        else if c == RequireNumber then
          [MinimumLength(8) ]
        else if c == RequireSpecialChar then
          [MinimumLength(8) ]
        else
          [] @ sin@1,
        calculateStrength(m@0@0, sin@1))
  | (_ , UpdatePassword(password)) =>
    let strength = calculateStrength(password, m@1@2) in
      (m@0@0, password, strength)
  end
in
  
let view: Model -> HtmlNodeType_BodyContents_ElementContent_ElementContent_ElementContent_ElementContent_Element
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <HtmlNodeType_BodyContents_ElementContent_ElementContent_ElementContent_ElementContent_Element>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ
   (FreeTypeVariable
      "HtmlNodeType_BodyContents_ElementContent_ElementContent_ElementContent_ElementContent_Element"))
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), calculateStrength: ((Password, [PasswordCriteria]) -> PasswordStrength), strength_of: (Int -> PasswordStrength), metCriteria: ((Password, [PasswordCriteria]) -> [Bool]), meetsCriterion: ((Password, PasswordCriteria) -> Bool), hasSpecialChar: (Password -> Bool), hasNumber: (Password -> Bool), hasLowercase: (Password -> Bool), hasUppercase: (String -> Bool), hasFromSet: ((String, String) -> Bool), meetsMinLength: ((String, Int) -> Bool), UpdatePassword: (String -> Action), ClearCriteria: Action, AddCriterion: (PasswordCriteria -> Action), RemoveCriterion: (PasswordCriteria -> Action), Action:: (UpdatePassword(String) + ClearCriteria + AddCriterion(PasswordCriteria) + RemoveCriterion(PasswordCriteria)), initialModel: Model, Model:: (Password, Criteria, Strength), Weak: Strength, Moderate: Strength, Strong: Strength, Strength:: PasswordStrength, Criteria:: [PasswordCriteria], Password:: String, Weak: PasswordStrength, Moderate: PasswordStrength, Strong: PasswordStrength, PasswordStrength:: (Weak + Moderate + Strong), RequireUppercase: PasswordCriteria, RequireLowercase: PasswordCriteria, MinimumLength: (Int -> PasswordCriteria), RequireNumber: PasswordCriteria, RequireSpecialChar: PasswordCriteria, PasswordCriteria:: (RequireUppercase + RequireLowercase + MinimumLength(Int) + RequireNumber + RequireSpecialChar), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  m @ 0 @ 1
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  1
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Model  
Error in term:
  password
Nature of error: Expecting type Criteria but got inconsistent type String  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  sin
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type (Float -> Float)  
Error in term:
  sin
Nature of error: Expecting type [?] but got inconsistent type (Float -> Float)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ 0 @ 0
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  1
Nature of error: Expecting type [PasswordCriteria] but got inconsistent type Int  
Error in term:
  m @ 0 @ 2
Nature of error: Expecting type Password but got inconsistent type [?]  
Error in term:
  0
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  2
Nature of error: Expecting type [?] but got inconsistent type Int  
Error in term:
  HtmlNodeType_BodyContents_ElementContent_ElementContent_ElementContent_ElementContent_Element
Nature of error: Type variable HtmlNodeType_BodyContents_ElementContent_ElementContent_ElementContent_ElementContent_Element is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Model -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: HtmlNodeType_BodyContents_ElementContent_ElementContent_ElementContent_ElementContent_Element
LSP: Generating Completions for prefix: HtmlNodeType_BodyContents_ElementContent_ElementContent_ElementContent_ElementContent_Element
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Strength Criteria Password PasswordStrength PasswordCriteria () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
root ::= completions

Top 20 Logits:
Content:15.5465
 =:12.6492	rejected
Cont:10.4433
Contents:10.25
_:10.2475
Children:10.0898
Type:9.36001
Tag:9.2993
=:9.29714	rejected
Node:9.24943
With:8.92219
Attributes:8.58864
List:8.54965
Attribute:8.5013
 ->:8.40639	rejected
Ref:8.3492
Style:8.31376
Cl:8.24125
Dec:8.22863
C:8.20504
 *:8.18536	rejected
