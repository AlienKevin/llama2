

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((Model, Action) -> Model)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((Model, Action) -> Model)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "add" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "toggle" | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:17.4781
 :16.3724
 fun:15.1736
  :13.4225
    :12.4937
                :12.2859
   :12.1469
 (:11.6577
 function:11.5135	rejected
      :11.1549
 #:10.9569	rejected
        :10.9271
     :10.677
fun:10.4572
            :10.4231
 switch:10.4071	rejected
         :10.3866
 match:10.3339	rejected
 \:10.2221	rejected
 action:10.2066	rejected
	:10.1913	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =


LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((Model, Action) -> Model)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((Model, Action) -> Model)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "add" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "toggle" | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 :21.162
   :16.3167
  :15.0691
fun:14.7799
 fun:14.5433
 let:13.0963

:12.7827
    :12.3384
	:12.2149	rejected
let:11.9929
#:11.526	rejected
     :11.3908
 switch:11.1513	rejected
switch:10.8689	rejected
 func:10.6885	rejected
 match:10.5406	rejected
|:10.329	rejected
func:10.3078	rejected
match:10.2797	rejected
      :10.2371
       :10.0575

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
 

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
 
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((Model, Action) -> Model)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((Model, Action) -> Model)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "add" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "toggle" | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 fun:18.7375
 let:15.3876
 switch:12.9978	rejected
 match:12.8372	rejected
 (:12.4229
 function:12.01	rejected
 #:11.7863	rejected
 f:11.4806
 (*:11.2161	rejected
 |:11.0566	rejected
 case:10.7755
 Model:10.6037
 {:10.5228	rejected
 action:10.2273	rejected
 with:10.1847	rejected
 func:10.1215	rejected
 ~:10.073	rejected
 fn:10.0674	rejected
 ((:10.052	rejected
 handle:10.0313	rejected
 go:9.893	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "RemoveTodo" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 (:18.004
 ((:16.7138	rejected
 model:16.658
 m:15.7951
 ({:14.8522	rejected
 state:14.5032
 old:12.9239
 {:12.6391	rejected
 todo:12.628
(:12.28
 current:12.0579
 prev:11.9978
 s:11.9355
 x:11.9237
 _:11.6352
 init:11.573
 :11.5324
((:11.3834	rejected
 data:11.3335
 t:11.1583
 previous:11.132

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized pattern
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: ((String, [(String, Bool)]), (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in
  LSP: Info: BidiCtx: Cls: Parenthesized pattern
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Parenthesized pattern
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: ((String, [(String, Bool)]), (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in
  LSP: Info: BidiCtx: Cls: Parenthesized pattern
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "RemoveTodo" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= completions | new-tokens

Top 20 Logits:
buffer:17.4772
description:16.2735
model:15.4441
desc:14.254
buf:14.1172
_,:14.0836	prefix accepted:_
b:14.0488
buff:13.342
d:12.9762
des:12.5532
state:12.5042
text:12.255
input:12.19
t:12.1591
old:12.0182
s:11.5596
current:11.5384
m:11.4051
tod:10.9382
title:10.9343
x:10.301

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <buffer>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: (Model, Action), update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: buffer
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: buffer
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
,:19.3031
_:13.7716
_,:13.5973	prefix accepted:_
1:13.5251
',:13.382	rejected
0:13.2102
 ,:13.198
Model:11.4282
$,:11.1969	rejected
__:10.8641
::10.8525	rejected
 $:10.7738	rejected
 as:10.538	rejected
,[:10.3092	rejected
2:10.1214
Text:9.97427
Description:9.8786
$:9.79943	rejected
T:9.76685
ed:9.7173
,,:9.62946	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer,

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: ((String, [(String, Bool)]), (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: ((String, [(String, Bool)]), (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "RemoveTodo" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 todos:15.7334
 todo:13.9116
 ts:12.394
 _:12.1239
 state:11.8638
 model:11.6615
 list:11.2835
tod:11.1305
 items:11.0799
 tod:10.928
 old:10.8921
 xs:10.4436
 entries:10.2666
 (:10.2575
 _):9.96032	prefix accepted: _
 tasks:9.87316
 Tod:9.82877	rejected
 current:9.48605
 to:9.33957
 {:9.32637	rejected
 t:9.28969

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <todos>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: todos
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: todos
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
),:18.3734	rejected
):14.978
 as:14.5463	rejected
_:13.0406
,:12.1056
)::11.2772	rejected
1:11.2297
),(:11.202	rejected
 ),:10.7892	rejected
)->:10.7345	rejected
0:10.6129
'),:9.95888	rejected
)=:9.91395	rejected
::9.44995	rejected
)(:9.28195	rejected
2:8.8888
 ::8.83796	rejected
()),:8.83621	rejected
 =:8.8024	rejected
',:8.65877	rejected
)):8.60487	rejected
Rejected the highest logit candidate ), with logit -inf

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos)

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized pattern
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: ((String, [(String, Bool)]), (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Parenthesized pattern
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "->"
root ::= new-tokens

Top 20 Logits:
 action:15.958	rejected
 ->:13.9911
 ,:13.7483
 a:12.4868	rejected
 todo:12.3251	rejected
 act:11.771	rejected
 as:11.7106	rejected
 (:11.6279
 x:11.4036	rejected
 _,:11.3943	rejected
 model:11.3498	rejected
 +:11.2908	rejected
 =:10.8103	rejected
 m:10.53	rejected
 {:10.3681	rejected
 _:10.205	rejected
 ::10.0743	rejected

:10.0502
 :9.97132
 ac:9.96383	rejected
 =>:9.93043	rejected
Rejected the highest logit candidate  action with logit -inf

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Model, Action) -> Model)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todos" | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:15.9436
 fun:13.9077
 action:13.6609	rejected
 :13.5653
 function:13.057	rejected
 case:12.6189
 match:12.5509	rejected
  :11.784
    :11.76
 (:11.1959
   :10.9937
 #:10.7421	rejected
 Action:10.7054	rejected
 let:10.6711
 switch:10.4806	rejected
                :10.4641
 ?:10.4281	rejected
 {:10.3872	rejected
     :10.3402
      :10.1475
        :9.89472

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->


LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Model, Action) -> Model)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todos" | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
   :21.4439
 :17.1658
  :16.6664
     :16.4372
    :16.1406

:14.4277
case:13.8757
      :13.844
	:13.4536	rejected
       :13.4217
         :13.2326
        :13.0452
match:12.6847	rejected
switch:12.3481	rejected
           :12.2819
                :12.1896
#:12.0278	rejected
 case:11.7874
          :11.7262
            :11.4185
             :11.3839

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
   

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
   
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Model, Action) -> Model)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todos" | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 case:15.9894
 match:14.958	rejected
 fun:14.487
 let:13.5463
 function:12.9606	rejected
 switch:12.6267	rejected
 action:12.5784	rejected
 (:11.2592
 if:10.4206
 Action:10.3125	rejected
 #:10.1698	rejected
 todo:9.90562
 |:9.78045	rejected
 with:9.71136	rejected
 model:9.51452	rejected
 {:9.4283	rejected
 \:9.36905	rejected
 Update:9.31988
 func:9.31692	rejected
 f:9.29703
 update:9.19004

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <case end<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todos" | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 action:14.0636	rejected
 a:11.9595
 todo:11.4201
 buffer:11.3221

:11.0467
 :10.4877
 _:10.4708	rejected
 @:10.081	rejected
 $:10.0227	rejected
 todos:9.6758
 act:9.50074	rejected
_:9.49499	rejected
 Action:9.35411	rejected
 #:9.27322	rejected
 ac:9.26947
 ?:9.21915	rejected
 update:8.94289
 msg:8.86817	rejected
 in:8.68665
 event:8.66736	rejected
 t:8.65133
Rejected the highest logit candidate  action with logit -inf

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case a

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case a
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <a>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "a"))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  a
Nature of error: Variable a is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: a
LSP: Generating Completions for prefix: a
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "bs" | "bs_float" | "cos" | "dd" | "sin" | "tan"
root ::= completions

Top 20 Logits:

:15.6811	rejected
 :13.6396	rejected
 of:13.4435	rejected
  :12.8177	rejected
    :12.0675	rejected
::11.9044	rejected
 in:11.8801	rejected
 with:11.366	rejected
     :11.0647	rejected
      :11.0509	rejected
 ->:11.0406	rejected
 ::10.9814	rejected
 #:10.6221	rejected
1:10.5253	rejected
   :10.5157	rejected
                :10.4538	rejected
 =>:10.3768	rejected
 //:10.1962	rejected
 =:10.1863	rejected
_:10.1728	rejected
Action:10.1402	rejected
Rejected the highest logit candidate 
 with logit -inf

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case aco

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case aco
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <aco>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "aco"))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  aco
Nature of error: Variable aco is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: aco
LSP: Generating Completions for prefix: aco
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "s"
root ::= completions

Top 20 Logits:

:12.9287	rejected
in:11.5606	rejected
es:11.4671	rejected
ction:10.475	rejected
 :10.3695	rejected
 in:10.3417	rejected
  :10.048	rejected
id:9.70096	rejected
 of:9.56965	rejected
a:9.44571	rejected
z:9.36526	rejected
.:9.25458	rejected
 with:9.01686	rejected
action:8.87965	rejected
,:8.87161	rejected
ion:8.8664	rejected
on:8.79972	rejected
om:8.54529	rejected
i:8.52784	rejected
ord:8.46559	rejected
    :8.45971	rejected
Rejected the highest logit candidate 
 with logit -inf

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <acos>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (Float -> Float)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: acos
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Generating Completions for prefix: acos
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:12.7006
 :10.5235
.:10.2022	rejected
nt:9.7165	rejected
  :9.34314
,:9.3056
(:9.24105
ume:9.10038	rejected
nd:9.08129	rejected
ns:8.93412	rejected
se:8.91236	rejected
 of:8.88502	rejected
_:8.77896	rejected
::8.6219
y:8.57235	rejected
 in:8.5134	rejected
 #:8.19068	rejected
    :7.99305
 as:7.85949	rejected
 action:7.81005	rejected
as:7.7653	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos


LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <acos>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (Float -> Float)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
   :17.4727
     :15.5431
    :14.259
  :13.7156
 :13.1715

:13.1
      :12.5235
#:12.5029	rejected
       :11.8381
        :11.7775
|:11.7572
         :11.4291
	:10.9201	rejected
                :10.4771
          :10.3078
 |:10.2302
           :9.9755
\:9.70302
            :9.67889
             :9.5976
end:9.57032

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
   

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
   
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <acos>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (Float -> Float)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:18.0261
 #:13.008	rejected
 +:11.5162
 Add:11.3836	rejected
 when:10.6998	rejected
 match:10.6559	rejected
 Update:10.1301	rejected
 of:10.0006	rejected
 action:9.92723	rejected
 ~:9.36981	rejected
 <:9.28154
 end:9.2074
 {:9.17419	rejected
 (*:8.95471	rejected
 ##:8.9514	rejected
 (:8.94473
 -:8.80831
 When:8.76521	rejected
 a:8.66313	rejected
 []:8.6549	rejected
 //:8.63022	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    |

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    |
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Float -> Float)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: (Float -> Float)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "RemoveTodo" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 Add:17.3717
 Update:13.4228
 _:11.6034
 (:11.4328
 Remove:10.8826
 Tod:10.8282	rejected
 T:10.7145
 _,:10.5277	prefix accepted: _
Add:10.364
 add:10.2883
 Action:10.257	rejected
 #:9.98494	rejected
 A:9.80116
 :9.68554
 Ac:9.39558	rejected
 a:9.25285
 action:9.17421
 ADD:9.16883	rejected
 {:9.14506	rejected
 [:9.02676
 ":8.96465

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | Add

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | Add
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Add>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Float -> Float)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "Add"))))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  Add
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: (Float -> Float)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Add
LSP: Generating Completions for prefix: Add
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Todo"
root ::= completions

Top 20 Logits:
T:18.5925
 =>:12.3886	rejected
To:12.1697
 ->:11.5507	rejected
t:11.3023	rejected
(:11.0328	rejected
_:10.9101	rejected
TO:10.8541	rejected
 todo:10.5717	rejected
Action:10.4502	rejected
():10.0431	rejected
 Tod:9.71319	rejected
Text:9.64036	rejected
    :9.63421	rejected
New:9.57191	rejected
      :9.52633	rejected
     :9.52119	rejected
         :9.30247	rejected
  :9.02897	rejected
Description:8.89465	rejected
Add:8.84284	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddT

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddT
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <AddT>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Float -> Float)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "AddT"))))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  AddT
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: (Float -> Float)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: AddT
LSP: Generating Completions for prefix: AddT
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "odo"
root ::= completions

Top 20 Logits:
odo:22.2769
odos:15.3804	rejected
od:13.8925
oto:12.9394	rejected
do:11.0761	rejected
oda:10.7313	rejected
ogo:10.7163	rejected
d:10.5378	rejected
odd:10.0349	rejected
udo:9.77552	rejected
og:9.7347	rejected
os:9.55708	rejected
ode:9.46332	rejected
oco:9.38853	rejected
dd:9.08953	rejected
odon:9.0661	rejected
of:9.05417	rejected
ado:9.0499	rejected
oso:8.88117	rejected
ot:8.71106	rejected
oc:8.70593	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <AddTodo>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Float -> Float)
  LSP: Info: Seft type: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String))
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Arrow (Float, Float)); syn = (Var "Action")})))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: (Float -> Float)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: AddTodo
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: AddTodo
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:18.0487
 ->:13.6625	rejected
     :13.2683
      :13.1661
         :12.9878
    :12.9212
        :12.6274
():12.463	rejected
          :12.158
  :12.0788
       :11.9674
                :11.8001
           :11.6866
             :11.4697
   :11.4042
 :11.3928
            :11.3924
(_:11.3607	rejected
 _:11.31	rejected
(:11.2504
 when:11.1146	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo =>

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo =>
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todos" | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 (:15.7521
 add:14.3628

:14.0991
 :13.2172
 (":13.1659	rejected
 buffer:12.8008
 Model:12.6781
 let:12.2419
 if:11.5644
  :11.5196
 ?:11.449	rejected
 List:11.4386	rejected
 f:11.1754
                :11.0075
 ((:11.0041	rejected
 todo:10.9697
 ():10.7694
    :10.7228
 (\:10.6271	rejected
 {:10.6032	rejected
      :10.5651

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(String, Bool)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(String, Bool)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todos" | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
buffer:14.4299
 "",:12.1414	rejected
List:11.4073	rejected
?,:11.3392	rejected
add:11.1843
buf:11.1457

:11.1442
b:10.9146
model:10.7762	rejected
String:10.6269	rejected
(":10.3949	rejected
if:10.2968
f:10.0572
_,:10.0516	rejected
Model:10.0118
action:9.94134	rejected
update:9.8644
[":9.53374	rejected
description:9.53272	rejected
new:9.49298	rejected
<:9.48375	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <buffer>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(String, Bool)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: buffer
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: buffer
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:16.073
 @:13.2726
 +:12.3096
 $:12.1268
.:11.4748	rejected
 "",:11.4201	rejected
@:10.7002
 ,:10.6159
 =:10.2915
1:10.2596	rejected
 &:10.0804
 ^:10.0482	rejected
 |:9.77603	rejected
,":9.73916	rejected
_:9.64828	rejected
=":9.59022	rejected
:::9.57424
 ++:9.39779
',:9.24476	rejected
,[:9.19608	rejected
 <>:9.03183	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer,

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (?, [(String, Bool)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (?, [(String, Bool)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todos" | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 add:17.3621
 List:12.7534	rejected
 todos:12.3522
 [:11.6071
 todo:11.5224
 (:11.48
 buffer:11.471
 Tod:11.4689
 Model:10.3054
 :10.1869
add:10.0631
         :10.0553
  :10.0158
    :9.87467
                :9.62378
      :9.55364
     :9.54399
 f:9.44884
        :9.39936
 [],:9.32583	rejected
            :9.29912

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <add>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ((String, [(String, Bool)]) -> [(String, Bool)])
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (List (Var "Todo"));
           syn = (Arrow ((Var "Model"), (List (Var "Todo"))))})))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  add
Nature of error: Expecting type [Todo] but got inconsistent type (Model -> [Todo])  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: add
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: add
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
(:18.4371
((:15.0946	rejected
()):13.1451	rejected
):13.0132
([:12.0368	rejected
 (:11.7732
 todos:11.271	rejected
 buffer:11.0205	rejected
({:10.688	rejected
 todo:10.199	rejected
 ((:10.041	rejected
():9.95238	rejected
_:9.88932	rejected
(...:9.77981	rejected
[:9.72453	rejected
,:9.71526
(@:9.61971	rejected
(":9.4678	rejected
)(:9.44578	rejected
:(:9.3257	rejected
tod:9.27272	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [(String, Bool)]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [(String, Bool)]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todos" | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
tod:16.7463
buffer:15.5851
t:11.0958
description:10.5552	rejected
td:10.2111	rejected
des:10.1493	rejected
to:9.91849
List:9.77662	rejected
buf:9.714
model:9.70268	rejected
 todos:9.65592
 buffer:9.65536
buff:9.29118
desc:9.22695	rejected
list:8.91417	rejected
b:8.73424
Buffer:8.67246	rejected
d:8.51714	rejected
0:8.49914
Model:8.4515
toString:8.37358	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <buffer>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(String, Bool)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: buffer
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: buffer
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:17.6084
)):14.3372	rejected
:::12.27
.:12.2108	rejected
@:11.3383
 @:11.147
 ,:11.1407
 :::10.9003
 +:10.8745
):10.7152
),:10.5548	rejected
)(:10.4637	rejected
 todos:10.2021	rejected
 $:9.89148
 todo:9.87709	rejected
=:9.75538
)),:9.7314	rejected
tod:9.3794	rejected
^:9.13099	rejected
 ^:9.0528	rejected
;:9.03188	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer,

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (?, [(String, Bool)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (?, [(String, Bool)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todos" | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 todos:16.3173
tod:12.5124
 todo:11.717
 tod:11.3562
 ts:10.0676	rejected
 t:10.035
 buffer:9.85016
 list:9.64876	rejected
 Tod:9.62406
 :9.52385
 to:9.17685
 [:9.16645
 List:9.0388	rejected
 td:8.97931	rejected
 (:8.90995
 xs:8.90762	rejected
 x:8.85162	rejected
 add:8.80939
 tokens:8.18536	rejected
 ?:8.14088	rejected
 descri:8.0906	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <todos>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String))
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (List (Var "Todo")); syn = (Var "Action")})))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: todos
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: todos
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
)):19.8413	rejected
)),:14.4679	rejected
):13.8924
))):12.4642	rejected
));:12.3977	rejected
),:12.0246	rejected
))::11.4005	rejected
,:11.2707
)).:10.7512	rejected
)::10.6258	rejected
);:10.2023	rejected
)[:9.55134	rejected
)))):9.49428	rejected
))$:9.4663	rejected
)}:9.45838	rejected
)));:9.44397	rejected
)]:9.43407	rejected
)(:9.40187	rejected
 :9.36208
))]:9.25381	rejected

:9.18304
Rejected the highest logit candidate )) with logit -inf

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [(String, Bool)]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:

:15.029
 ):14.6557
 end:12.4327	rejected
  :12.3674
 :12.0686
    :11.9457
     :11.6421
                :11.5937
      :11.5051
 @:10.9902
        :10.8961
   :10.6462
            :10.4806
         :10.4312
 ::10.3818
 in:10.1662	rejected
()):10.1633	rejected
          :10.1321
 (:10.0155
       :9.8632
           :9.85403

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)


LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [(String, Bool)]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
   :19.0995
    :14.5381
     :13.7438

:13.7154
                :13.619
  :13.6173
	:12.9082	rejected
 :12.8099
#:12.472	rejected
      :12.1159
|:11.9275	rejected
end:11.8615	rejected
        :11.8561
       :11.2967
            :11.1676
         :11.1259
               :10.9515
}:10.6396	rejected
          :10.5958
           :10.4885
\:10.4398

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
   

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
   
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [(String, Bool)]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
 |:18.7037	rejected
 #:13.1712	rejected
 end:11.5429	rejected
 ...:11.0706	rejected
 _:11.0403	rejected
 //:10.5917	rejected
 ?:10.4821	rejected
 ,:10.4425
 T:10.4197	rejected
 <:10.3688
 \:10.2978
 +:10.1882
 ):10.1855
 Update:10.0819	rejected
 $:9.95455
 ~:9.87002	rejected
 return:9.71916	rejected
 case:9.68503	rejected
 ||:9.64277	rejected
 {:9.62677	rejected
 (:9.54654
Rejected the highest logit candidate  | with logit -inf

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    <

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    <
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: ><<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Integer Less Than
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: (Exp
   (Common (Inconsistent Expectation {ana = (List (Var "Todo")); syn = Bool})))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  add(buffer, todos) < ?
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Integer Less Than
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: (Exp
   (Common (Inconsistent Expectation {ana = (List (Var "Todo")); syn = Bool})))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  add(buffer, todos) < ?
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  add(buffer, todos) < ?
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: <
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: <
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "." | "=" | "=."
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todos" | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
|:11.1895	rejected
 Remove:10.5403
Remove:10.1991
+:9.21761	rejected
li:8.83497	rejected

:8.77189
$:8.44417	rejected
 Update:8.36499
*:8.34596	rejected
#:8.21352	rejected
@:8.13899	rejected
 Add:8.06842
sn:7.8639	rejected
br:7.74051	rejected
~:7.65488	rejected
--:7.54937	rejected
Add:7.52587
T:7.52344
d:7.475	rejected
=>:7.4487	rejected
Update:7.22153
Rejected the highest logit candidate | with logit -inf

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < Remove

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < Remove
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Remove>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "Remove"))))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  Remove
Nature of error: Constructor is not defined  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  add(buffer, todos) < Remove
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Remove
LSP: Generating Completions for prefix: Remove
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Todo"
root ::= completions

Top 20 Logits:
T:16.6699
(:12.3449	rejected
To:11.5391
 todo:11.1944	rejected
 Tod:10.7576	rejected
TO:10.5278	rejected
Action:10.2239	rejected
 =>:9.75097	rejected
 (:9.39301	rejected
((:9.31946	rejected
_:9.12575	rejected
::8.75379	rejected
Item:8.67221	rejected
Index:8.66449	rejected
 ->:8.57065	rejected
 action:8.54342	rejected
Add:8.43836	rejected
Toggle:8.15717	rejected

:8.12988	rejected
 TODO:7.97685	rejected
 ::7.77473	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveT

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveT
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <RemoveT>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "RemoveT"))))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  add(buffer, todos) < RemoveT
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  RemoveT
Nature of error: Constructor is not defined  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: RemoveT
LSP: Generating Completions for prefix: RemoveT
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "odo"
root ::= completions

Top 20 Logits:
odo:19.1185
od:14.042
odos:11.8233	rejected
oto:11.723	rejected
do:11.1815	rejected
d:10.8306	rejected
odd:10.7855	rejected
udo:10.7202	rejected
oda:10.7006	rejected
ogo:10.0203	rejected
og:9.84414	rejected
dd:9.78708	rejected
ode:9.39732	rejected
(:9.1106	rejected
odon:8.79083	rejected
odu:8.70416	rejected
of:8.69366	rejected
oco:8.59982	rejected
0:8.30422	rejected
ody:8.29062	rejected
ok:8.19708	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <RemoveTodo>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: (Int -> (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)))
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = Int; syn = (Arrow (Int, (Var "Action")))})))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  add(buffer, todos) < RemoveTodo
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  RemoveTodo
Nature of error: Expecting type Int but got inconsistent type (Int -> Action)  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: RemoveTodo
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: RemoveTodo
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
(:15.5189
 index:14.0848	rejected
 i:13.0966	rejected
 idx:12.2467	rejected
 n:12.1533	rejected
 =>:11.907	rejected
(_:10.7438	rejected
 id:10.5686	rejected
 (:10.4936
 ->:10.3449	rejected
 :::10.3145
::10.241
,:9.91085
 x:9.87616	rejected

:9.79564
 k:9.72389	rejected
 ::9.41715
:::9.19798
 _:9.02124	rejected
 =:8.97386
 todo:8.96417	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String))
  LSP: Info: Error Status: (Exp (Common (Inconsistent Expectation {ana = Int; syn = (Var "Action")})))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  add(buffer, todos) < RemoveTodo(?)
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(?)
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String))
  LSP: Info: Error Status: (Exp (Common (Inconsistent Expectation {ana = Int; syn = (Var "Action")})))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  add(buffer, todos) < RemoveTodo(?)
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(?)
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  add(buffer, todos) < RemoveTodo(?)
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(?)
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todos" | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
index:17.6117	rejected
i:15.8494
idx:15.1863	rejected
n:14.5437
Int:13.7442	rejected
id:13.5283	rejected
x:12.9708	rejected
int:12.6611
t:12.1269
Index:11.3693	rejected
ix:11.2773	rejected
0:11.0188
k:10.7305	rejected
a:10.5691
ind:10.4824	rejected
key:10.479	rejected
_,:10.3533	rejected
pos:10.3406	rejected
1:10.0565
 index:9.91083	rejected
j:9.81528	rejected
Rejected the highest logit candidate index with logit -inf

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(i

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(i
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <i>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "i"))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  i
Nature of error: Variable i is not bound  
Error in term:
  add(buffer, todos) < RemoveTodo(i)
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(i)
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: i
LSP: Generating Completions for prefix: i
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "f " | "nfinity" | "nt_of_float" | "nt_of_string" | "s_finite" | "s_infinite" | "s_nan"
root ::= completions

Top 20 Logits:
):16.0585	rejected
),:13.2018	rejected
)::12.9444	rejected
)):11.184	rejected
 as:11.1745	rejected
::11.1293	rejected
=:11.0332	rejected
)->:10.7998	rejected
)=:10.6077	rejected
)>:10.4918	rejected
1:10.3974	rejected
,:10.3636	rejected
:::9.85797	rejected
0:9.71215	rejected
 =>:9.60114	rejected
)|:9.47062	rejected
 =:9.42662	rejected
);:9.11254	rejected
)?:8.82115	rejected
 ::8.71972	rejected
 +:8.65023	rejected
Rejected the highest logit candidate ) with logit -inf

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <int>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "int"))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  add(buffer, todos) < RemoveTodo(int)
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  int
Nature of error: Variable int is not bound  
Error in term:
  RemoveTodo(int)
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: int
LSP: Generating Completions for prefix: int
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_of_float" | "_of_string"
root ::= completions

Top 20 Logits:
):13.4018	rejected
),:11.0454	rejected
 index:10.9168	rejected
 i:9.79332	rejected
)::9.40289	rejected
dex:9.36198	rejected
)->:9.27005	rejected
)):9.08584	rejected
)>:8.88045	rejected
y:8.80692	rejected
 =>:8.64082	rejected
)=:8.56997	rejected
 n:8.56351	rejected
_:8.50006
 ):8.01537	rejected
,:7.9876	rejected
ed:7.97924	rejected
s:7.92577	rejected
 x:7.90603	rejected
 idx:7.90487	rejected
x:7.8887	rejected
Rejected the highest logit candidate ) with logit -inf

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <int_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "int_"))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  int_
Nature of error: Variable int_ is not bound  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  add(buffer, todos) < RemoveTodo(int_)
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_)
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: int_
LSP: Generating Completions for prefix: int_
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "of_float" | "of_string"
root ::= completions

Top 20 Logits:
index:12.1127	rejected
eq:12.0799	rejected
idx:11.7387	rejected
val:11.4357	rejected
t:11.4318	rejected
to:11.4286	rejected
value:11.1355	rejected
of:11.1285
x:10.6679	rejected
id:10.0694	rejected
n:9.85653	rejected
i:9.78881	rejected
1:9.73823	rejected
num:9.70664	rejected
e:9.45225	rejected
add:9.3526	rejected
var:9.3118	rejected
as:9.15566	rejected
a:9.1278	rejected
pos:9.12434	rejected
v:9.08109	rejected
Rejected the highest logit candidate index with logit -inf

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <int_of>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "int_of"))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  int_of
Nature of error: Variable int_of is not bound  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of)
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of)
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: int_of
LSP: Generating Completions for prefix: int_of
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_float" | "_string"
root ::= completions

Top 20 Logits:
_:14.8992
(:11.4957	rejected
):10.8965	rejected
 index:10.7727	rejected
s:10.2375	rejected
 i:10.176	rejected
 buffer:8.72326	rejected
 string:8.60686	rejected
,:8.5338	rejected
 int:8.24423	rejected
 n:8.06799	rejected
(":7.88685	rejected
 s:7.86025	rejected
String:7.85513	rejected
_):7.7962	prefix accepted:_
($:7.73966	rejected
),:7.726	rejected
<:7.72444	rejected
 x:7.68302	rejected
.:7.66133	rejected
()):7.65935	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <int_of_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "int_of_"))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  int_of_
Nature of error: Variable int_of_ is not bound  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_)
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_)
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: int_of_
LSP: Generating Completions for prefix: int_of_
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "float" | "string"
root ::= completions

Top 20 Logits:
string:16.0407
str:13.9254
char:13.0013	rejected
int:12.7574	rejected
index:12.5291	rejected
float:12.4667
nat:11.9344	rejected
action:11.4326	rejected
s:11.2733
num:11.1158	rejected
String:11.0969	rejected
t:11.0959	rejected
id:10.8031	rejected
json:10.6871	rejected
text:10.6677	rejected
base:10.5259	rejected
value:10.4546	rejected
ch:10.4019	rejected
idx:10.3779	rejected
msg:10.3601	rejected
input:10.3319	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <int_of_string>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: (String -> Int)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = Int; syn = (Arrow (String, Int))})))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string)
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  int_of_string
Nature of error: Expecting type Int but got inconsistent type (String -> Int)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string)
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: int_of_string
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: int_of_string
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
(:12.9707
):11.2689
 index:10.7728	rejected
 i:10.0956	rejected
 buffer:9.73513	rejected
()):9.46803	rejected
,:9.16423
)):8.98976	rejected
 s:8.95023	rejected
(_:8.83096	rejected
($:8.71057	rejected
),:8.68957	rejected
_:8.64247	rejected
(":8.62847	rejected
 action:8.57359	rejected
 x:8.44347	rejected
 n:8.40201	rejected
 a:8.25373	rejected
():8.21927	rejected
 todo:8.18655	rejected
 input:8.16731	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(?))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(?))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(?))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(?))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: String
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(?))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(?))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todos" | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
buffer:13.1757
index:12.0514	rejected
input:11.7685	rejected
i:11.059
s:10.9681
b:10.9237
action:10.7426	rejected
x:10.6904	rejected
str:10.5829
buf:10.5442
id:10.3462	rejected
a:10.3265
t:10.1532
int:10.0707
String:10.0467	rejected
remove:9.80244
description:9.71223	rejected
n:9.71134
v:9.54387	rejected
xs:9.2332	rejected
update:9.1895

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <buffer>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: String
  LSP: Info: Seft type: (String, [(String, Bool)])
  LSP: Info: Error Status: (Exp (Common (Inconsistent Expectation {ana = String; syn = (Var "Model")})))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: buffer
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: buffer
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
)):15.204	rejected
),:13.2286	rejected
))):13.2281	rejected
):12.6248
)),:12.511	rejected
,:11.3466
.:9.61208	rejected
))::9.22851	rejected
 +:8.98903
));:8.96144	rejected
)))):8.90707	rejected
);:8.66752	rejected
)));:8.62107	rejected
 as:8.602	rejected
_:8.57595	rejected
)>:8.50011	rejected
).:8.47764	rejected

:8.43492
)::8.40981	rejected
)->:8.26345	rejected
 ->:8.16285	rejected
Rejected the highest logit candidate )) with logit -inf

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer,

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: String
  LSP: Info: Seft type: ((String, [(String, Bool)]), ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = String;
           syn = (Prod [(Var "Model"); (Unknown Internal)])})))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, ?
Nature of error: Expecting type String but got inconsistent type (Model, ?)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, ?))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, ?))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: String
  LSP: Info: Seft type: ((String, [(String, Bool)]), ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = String;
           syn = (Prod [(Var "Model"); (Unknown Internal)])})))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, ?
Nature of error: Expecting type String but got inconsistent type (Model, ?)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, ?))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, ?))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, ?
Nature of error: Expecting type String but got inconsistent type (Model, ?)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, ?))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, ?))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todos" | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 todos:11.8089
 i:11.1247
 :9.65
 int:9.38833
 buffer:9.19317
 todo:8.82198
 Int:8.68748	rejected
 [:8.5493
tod:8.45529
 index:8.27473	rejected
 to:8.01816
 tod:7.88416
 remove:7.85012
 List:7.79642	rejected
 ":7.7548
 String:7.57446	rejected
 s:7.46927
 ?:7.4617	rejected
 (:7.45709

:7.39473
 xs:7.26571	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, i

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, i
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <i>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "i"))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  i
Nature of error: Variable i is not bound  
Error in term:
  buffer, i
Nature of error: Expecting type String but got inconsistent type (Model, ?)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, i))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, i))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: i
LSP: Generating Completions for prefix: i
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "f " | "nfinity" | "nt_of_float" | "nt_of_string" | "s_finite" | "s_infinite" | "s_nan"
root ::= completions

Top 20 Logits:
)):14.6775	rejected
):12.9675	rejected
))):12.9133	rejected
),:11.9592	rejected
)),:11.4147	rejected
,:10.2054	rejected
)::9.77587	rejected
 ->:9.66676	rejected
x:9.65913	rejected
:::9.51746	rejected
)->:9.20414	rejected
))]:9.19472	rejected
))::9.17189	rejected
)));:9.07892	rejected
xs:9.01508	rejected
 =>:8.93297	rejected
->:8.57617	rejected
.:8.49531	rejected

:8.4543	rejected
));:8.44473	rejected
 +:8.39786	rejected
Rejected the highest logit candidate )) with logit -inf

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <int>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "int"))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, int
Nature of error: Expecting type String but got inconsistent type (Model, ?)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  int
Nature of error: Variable int is not bound  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: int
LSP: Generating Completions for prefix: int
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_of_float" | "_of_string"
root ::= completions

Top 20 Logits:
)):13.8597	rejected
):12.6299	rejected
_:12.283
))):12.2158	rejected
),:11.139	rejected
)),:11.0483	rejected
3:10.2109	rejected
 ->:9.72571	rejected
,:9.71662	rejected
->:9.64372	rejected
6:9.54711	rejected
:::9.38702	rejected
.:9.09427	rejected
(:8.74155	rejected
)::8.71672	rejected
))::8.65585	rejected
s:8.62202	rejected
 i:8.59408	rejected

:8.40589	rejected
 =>:8.25592	rejected
)->:8.13114	rejected
Rejected the highest logit candidate )) with logit -inf

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <int_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "int_"))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, int_
Nature of error: Expecting type String but got inconsistent type (Model, ?)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  int_
Nature of error: Variable int_ is not bound  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: int_
LSP: Generating Completions for prefix: int_
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "of_float" | "of_string"
root ::= completions

Top 20 Logits:
of:15.1404
to:14.0973	rejected
max:11.7642	rejected
str:11.6522	rejected
eq:11.4506	rejected
t:11.0893	rejected
size:11.0605	rejected
add:10.9999	rejected
val:10.6126	rejected
base:10.3677	rejected
tod:10.1695	rejected
list:10.0988	rejected
from:9.96836	rejected
remove:9.83942	rejected
parse:9.80461	rejected
su:9.78693	rejected
min:9.74049	rejected
i:9.73547	rejected
int:9.73278	rejected
error:9.70386	rejected
len:9.67713	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <int_of>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "int_of"))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, int_of
Nature of error: Expecting type String but got inconsistent type (Model, ?)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  int_of
Nature of error: Variable int_of is not bound  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: int_of
LSP: Generating Completions for prefix: int_of
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_float" | "_string"
root ::= completions

Top 20 Logits:
_:16.2839
(:10.4136	rejected
 string:9.90065	rejected
 _:9.62656	rejected
)):9.59744	rejected
-:9.25323	rejected
string:9.21492	rejected
):9.21301	rejected
 buffer:9.08179	rejected
_(:8.55621	prefix accepted:_
.:8.39576	rejected
<:8.21745	rejected
__:8.11117	rejected

:7.96306	rejected
(_:7.8068	rejected
():7.71148	rejected
String:7.68738	rejected
 -:7.59663	rejected
s:7.59269	rejected
,:7.53769	rejected
_):7.45515	prefix accepted:_

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <int_of_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "int_of_"))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, int_of_
Nature of error: Expecting type String but got inconsistent type (Model, ?)  
Error in term:
  int_of_
Nature of error: Variable int_of_ is not bound  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: int_of_
LSP: Generating Completions for prefix: int_of_
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "float" | "string"
root ::= completions

Top 20 Logits:
string:14.4316
int:12.6388	rejected
str:12.211
char:12.1675	rejected
index:11.8423	rejected
float:11.7722
bool:11.4117	rejected
t:11.4096	rejected
action:11.3463	rejected
st:11.2839
s:10.6867
tod:10.4609	rejected
String:10.299	rejected
list:10.0975	rejected
to:10.0678	rejected
buffer:9.96036	rejected
nat:9.95074	rejected
base:9.81537	rejected
option:9.69364	rejected
i:9.59821	rejected
n:9.43603	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <int_of_string>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (String -> Int)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, int_of_string
Nature of error: Expecting type String but got inconsistent type (Model, (String -> Int))  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: int_of_string
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: int_of_string
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
(:13.3112
)):12.6489	rejected
):11.2096
))):10.9428	rejected
_:9.65744	rejected
),:9.42336	rejected
((:9.36462	rejected

:9.34421
():9.21242	rejected
()):9.12583	rejected
(":9.03376	rejected
,:8.99621
())):8.75011	rejected
)),:8.72454	rejected
.:8.46958	rejected
(_:8.32673	rejected
 -:8.01897
(-:7.99579	rejected
($:7.75335	rejected
 +:7.63599
<:7.4746

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, int_of_string(?)
Nature of error: Expecting type String but got inconsistent type (Model, Int)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(?)))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(?)))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, int_of_string(?)
Nature of error: Expecting type String but got inconsistent type (Model, Int)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(?)))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(?)))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: String
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, int_of_string(?)
Nature of error: Expecting type String but got inconsistent type (Model, Int)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(?)))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(?)))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todos" | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
buffer:13.4822
tod:12.7063
i:11.1444
0:10.3714
int:10.203
t:10.193
index:9.97147	rejected
s:9.92364
str:9.70062
1:9.67197
b:9.64
remove:9.43255
List:9.35803	rejected
a:9.22973
action:9.21879	rejected
to:9.19863

:9.17478
x:9.0156	rejected
input:8.92132	rejected
String:8.90312	rejected
update:8.76075

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <buffer>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: String
  LSP: Info: Seft type: (String, [(String, Bool)])
  LSP: Info: Error Status: (Exp (Common (Inconsistent Expectation {ana = String; syn = (Var "Model")})))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  buffer, int_of_string(buffer)
Nature of error: Expecting type String but got inconsistent type (Model, Int)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer)))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer)))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: buffer
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: buffer
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:13.6947
)):13.4605	rejected
))):12.7071	rejected
):11.5172
)))):11.1878	rejected
),:10.7251	rejected
)),:10.4546	rejected

:10.3412
.:9.80587	rejected
_:8.99325	rejected
 +:8.94679
 -:8.60669
[:8.23202	rejected
 :8.02405
(:7.99409
2:7.96119	rejected
)]:7.5984	rejected
$:7.58656
 ,:7.48286
 /:7.46403
)));:7.35688	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer,

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: String
  LSP: Info: Seft type: ((String, [(String, Bool)]), ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = String;
           syn = (Prod [(Var "Model"); (Unknown Internal)])})))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, ?
Nature of error: Expecting type String but got inconsistent type (Model, ?)  
Error in term:
  buffer, int_of_string(buffer, ?)
Nature of error: Expecting type String but got inconsistent type (Model, Int)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, ?)))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, ?)))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: String
  LSP: Info: Seft type: ((String, [(String, Bool)]), ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = String;
           syn = (Prod [(Var "Model"); (Unknown Internal)])})))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, ?
Nature of error: Expecting type String but got inconsistent type (Model, ?)  
Error in term:
  buffer, int_of_string(buffer, ?)
Nature of error: Expecting type String but got inconsistent type (Model, Int)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, ?)))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, ?)))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, ?
Nature of error: Expecting type String but got inconsistent type (Model, ?)  
Error in term:
  buffer, int_of_string(buffer, ?)
Nature of error: Expecting type String but got inconsistent type (Model, Int)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, ?)))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, ?)))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todos" | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 i:11.223
 todos:10.7084
 buffer:10.2767
 :10.1311
 int:10.1077
 todo:9.04642
 s:8.7357
 "":8.72277
 remove:8.66866
 ":8.64941

:8.47835
 [:8.2746
 []:8.25119
 add:8.16467
 index:8.07988	rejected
 (:8.04079
tod:8.01571
 string:7.86332
 tod:7.7819
 ""):7.72575	rejected
 List:7.71712	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <todos>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, int_of_string(buffer, todos)
Nature of error: Expecting type String but got inconsistent type (Model, Int)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: todos
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: todos
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
)):14.4792	rejected
))):13.7941	rejected
):13.2051
)))):12.723	rejected

:10.7397
)),:10.6228	rejected
),:10.5923	rejected
)]:10.2231	rejected
,:9.54927
)}:9.1396	rejected
));:8.752	rejected
(:8.57134
);:8.48486	rejected
[:8.36895	rejected
)));:8.35351	rejected
)).:8.01954	rejected
 :7.98563
))]:7.97309	rejected
.:7.97119	rejected
 ):7.96841
)(:7.85852	rejected
Rejected the highest logit candidate )) with logit -inf

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, int_of_string(buffer, todos)
Nature of error: Expecting type String but got inconsistent type (Model, Int)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:

:15.5511
 ):12.8966
 in:12.5116	rejected
 end:12.4784	rejected
 :12.3734
  :11.8687
    :11.3002
 |:10.9175	rejected
 >:10.8996
 -:10.728
<:10.7249
 @:10.5354
     :10.4703
 #:10.3838	rejected
 =>:10.2795	rejected
 <:10.2548
      :10.1766
                :9.98518
 ->:9.96337	rejected
   :9.90396
        :9.83437

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)


LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, int_of_string(buffer, todos)
Nature of error: Expecting type String but got inconsistent type (Model, Int)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
   :18.1016
     :15.1185
#:14.0733	rejected
    :14.0705
  :13.7066
 :13.4143

:13.2387
                :13.2363
       :13.2213
      :12.247
	:12.1147	rejected
|:11.7043	rejected
end:11.6063	rejected
               :11.1863
         :11.1282
        :11.0832
           :10.8508
<:10.6886
             :10.5691
}:10.1962	rejected
):10.1787

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
   

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
   
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, int_of_string(buffer, todos)
Nature of error: Expecting type String but got inconsistent type (Model, Int)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
 <:16.1848
 |:14.8472	rejected
 >:13.2452
 #:12.234	rejected
 T:12.1019	rejected
 =>:11.2858	rejected
 ~:11.0662	rejected
 ):11.035
 </:10.8964	rejected
 ?:10.8449	rejected
 =:10.8422
 \:10.4941
 end:10.3589	rejected
 if:10.3489	rejected
 _:10.3466	rejected
 <>:10.1713	rejected
 Update:10.1429	rejected
 toggle:9.96876	rejected
 ,:9.86215
 >>:9.65632	rejected
 $:9.61782

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    <

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    <
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: ><<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Integer Less Than
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, int_of_string(buffer, todos) < ?
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ?))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ?))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Integer Less Than
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, int_of_string(buffer, todos) < ?
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ?))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ?))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, int_of_string(buffer, todos) < ?
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ?))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ?))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: <
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: <
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "." | "=" | "=."
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todos" | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
 T:16.6447
 Update:13.7448
 To:11.1071
 Tod:10.5094
Toggle:10.0369
 Set:9.69774	rejected
 TODO:9.68282	rejected
 Clear:9.31888	rejected
 Add:9.27086
 :9.15458
 toggle:9.10944
 _:8.90846	rejected
 Up:8.64536
 Change:8.60622	rejected
 Remove:8.48701
 TO:8.45282	rejected
 Map:8.23227	rejected
 (:8.12319
|:8.11331	rejected
 ...:8.08705	rejected
 Edit:7.9781	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < T

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < T
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <T>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "T"))))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, int_of_string(buffer, todos) < T
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < T))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  T
Nature of error: Constructor is not defined  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < T))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: T
LSP: Generating Completions for prefix: T
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "odo.eq" | "oggleTodo"
root ::= completions

Top 20 Logits:
oggle:19.72
og:13.7219
ogle:12.0319	rejected
gl:9.33356	rejected
Toggle:9.09518	rejected
ogo:9.01449	rejected
toggle:8.90654	rejected
oga:8.89236	rejected
ou:8.8615	rejected
oge:8.86034	rejected
g:8.79372	rejected
oc:8.15157	rejected
gg:8.10007	rejected
ug:8.09559	rejected
oto:8.08469	rejected
d:7.90752	rejected
ort:7.78144	rejected
org:7.69796	rejected
Update:7.4894	rejected
ick:7.47439	rejected
ogn:7.29155	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < Toggle

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < Toggle
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Toggle>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "Toggle"))))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  Toggle
Nature of error: Constructor is not defined  
Error in term:
  buffer, int_of_string(buffer, todos) < Toggle
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < Toggle))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < Toggle))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Toggle
LSP: Generating Completions for prefix: Toggle
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Todo"
root ::= completions

Top 20 Logits:
T:16.7672
To:13.3889
TO:12.5872	rejected
(:11.537	rejected
 todo:10.0127	rejected
Done:9.92879	rejected
Toggle:9.90931	rejected
 Tod:9.68332	rejected
_:9.44492	rejected
Do:9.31467	rejected
Add:9.28858	rejected
D:9.08842	rejected
Index:8.95873	rejected
Item:8.73658	rejected
 TODO:8.46205	rejected
B:8.4129	rejected
t:8.29824	rejected
Int:8.24706	rejected
to:8.17846	rejected
TD:8.11078	rejected
Update:8.06012	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleT

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleT
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <ToggleT>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "ToggleT"))))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleT
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleT))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  ToggleT
Nature of error: Constructor is not defined  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleT))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: ToggleT
LSP: Generating Completions for prefix: ToggleT
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "odo"
root ::= completions

Top 20 Logits:
odo:20.3372
od:14.7501
odos:14.47	rejected
oto:12.9107	rejected
do:12.2205	rejected
oda:11.3457	rejected
odd:11.3379	rejected
d:11.3306	rejected
ogo:11.1813	rejected
ode:11.0108	rejected
og:10.9537	rejected
udo:10.6238	rejected
odon:10.6136	rejected
oo:10.4982	rejected
odot:9.99389	rejected
o:9.90011
os:9.88052	rejected
DO:9.8328	rejected
odu:9.65643	rejected
ob:9.51727	rejected
dd:9.49605	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <ToggleTodo>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: (Int -> (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)))
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = Int; syn = (Arrow (Int, (Var "Action")))})))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  ToggleTodo
Nature of error: Expecting type Int but got inconsistent type (Int -> Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: ToggleTodo
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: ToggleTodo
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
(:16.5355
(_:11.0385	rejected
 =>:10.6445	rejected
((:10.6013	rejected
 (:10.2416
 i:10.2353	rejected
 int:9.70459	rejected

:9.48501
():9.44554	rejected
::9.40856
($:9.38136	rejected
i:9.15452	rejected
 index:8.96741	rejected
 ->:8.846	rejected
 =:8.74683
Int:8.66846	rejected
_:8.57087	rejected
([:8.5616	rejected
.:8.46859	rejected
[:8.42302	rejected
(":8.39974	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String))
  LSP: Info: Error Status: (Exp (Common (Inconsistent Expectation {ana = Int; syn = (Var "Action")})))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(?)
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(?)
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(?)))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(?)))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String))
  LSP: Info: Error Status: (Exp (Common (Inconsistent Expectation {ana = Int; syn = (Var "Action")})))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(?)
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(?)
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(?)))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(?)))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(?)
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(?)
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(?)))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(?)))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todos" | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
int:14.7481
i:13.9146
index:11.9107	rejected
in:11.3614
Int:11.1764	rejected
buffer:10.3979
n:9.92171
to:9.71933
aint:9.57878	rejected
t:9.25505
j:9.1988	rejected
into:9.04351	rejected
integer:8.93524	rejected
ints:8.87016	rejected
id:8.82767	rejected
oint:8.79744	rejected
0:8.61741
ini:8.57084	rejected

:8.49446
tod:8.47775
parseInt:8.42902	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <int>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "int"))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  int
Nature of error: Variable int is not bound  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int)
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int)
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int)))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int)))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: int
LSP: Generating Completions for prefix: int
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_of_float" | "_of_string"
root ::= completions

Top 20 Logits:
_:14.4014
):11.0724	rejected
Of:10.324	rejected
(:9.85137	rejected
 of:9.82791	rejected
)):9.40842	rejected
6:9.10181	rejected
3:8.95321	rejected
os:8.6607	rejected
,:8.59558	rejected
n:8.41819	rejected
.:8.29886	rejected
-:8.18394	rejected
 i:8.03144	rejected
g:7.73358	rejected
0:7.70134	rejected
f:7.67029	rejected
d:7.5652	rejected
od:7.52474	rejected
y:7.51082	rejected
)(:7.49688	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <int_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "int_"))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  int_
Nature of error: Variable int_ is not bound  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_)
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_)
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_)))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_)))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: int_
LSP: Generating Completions for prefix: int_
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "of_float" | "of_string"
root ::= completions

Top 20 Logits:
of:17.1733
to:13.4696	rejected
os:11.0222	rejected
o:10.758
Of:10.2634	rejected
 of:10.2538	rejected
f:10.2393	rejected
str:10.2167	rejected
t:10.0216	rejected
0:9.94776	rejected
if:9.79031	rejected
from:9.71759	rejected
parse:9.66121	rejected
or:9.61777	rejected
od:9.5473	rejected
on:9.53424	rejected
ot:9.37459	rejected
val:9.30707	rejected
list:9.21492	rejected
string:9.14625	rejected
6:9.00669	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <int_of>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "int_of"))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of)
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  int_of
Nature of error: Variable int_of is not bound  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of)
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of)))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of)))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: int_of
LSP: Generating Completions for prefix: int_of
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_float" | "_string"
root ::= completions

Top 20 Logits:
_:17.0845
 string:11.4372	rejected
string:10.8579	rejected
(:10.4541	rejected
 _:10.2764	rejected
-:10.1561	rejected
s:10.1346	rejected
.:9.84332	rejected
String:9.67549	rejected
st:9.4542	rejected
__:9.17224	rejected
_(:8.62756	prefix accepted:_
):8.40392	rejected
 s:8.17174	rejected
<:7.94164	rejected
S:7.93866	rejected
(_:7.73367	rejected

:7.57166	rejected
b:7.56276	rejected
str:7.50732	rejected
,:7.48019	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <int_of_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "int_of_"))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_)
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_)
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_)))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  int_of_
Nature of error: Variable int_of_ is not bound  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_)))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: int_of_
LSP: Generating Completions for prefix: int_of_
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "float" | "string"
root ::= completions

Top 20 Logits:
string:17.3261
st:14.4167
str:13.7607
String:13.1267	rejected
s:12.5113
strings:11.6585	rejected
tring:11.6167	rejected
buffer:11.131	rejected
sr:10.799	rejected
sto:10.7511	rejected
char:10.5725	rejected
to:10.4136	rejected
t:10.2295	rejected
stream:10.0993	rejected
index:9.98431	rejected
as:9.96072	rejected
float:9.66275
state:9.48717	rejected
 string:9.47408	rejected
stre:9.41663	rejected
int:9.40409	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <int_of_string>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: (String -> Int)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = Int; syn = (Arrow (String, Int))})))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string)
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string)
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string)))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  int_of_string
Nature of error: Expecting type Int but got inconsistent type (String -> Int)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string)))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: int_of_string
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: int_of_string
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
(:16.0894
()):10.7361	rejected
_:10.4773	rejected
):10.3685
 buffer:10.3672	rejected
)):10.2094	rejected
():10.1212	rejected
 (:9.99595
((:9.97579	rejected
(":9.83601	rejected
,:9.75193

:9.47535
(_:9.45744	rejected
buffer:9.40302	rejected
())):8.83525	rejected
(@:8.64988	rejected
.:8.60416	rejected
($:8.36622	rejected
(),:8.3109	rejected
(&:8.15408	rejected
))):8.14207	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(?))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(?))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(?))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(?))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(?))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(?))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(?))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(?))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: String
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(?))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(?))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(?))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(?))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todos" | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
buffer:15.9716
tod:11.9693
index:11.3576	rejected
b:11.1303
int:11.0815
i:11.0404
to:10.7108
t:10.4734
buff:9.78393
string:9.77532
s:9.66316
str:9.62385
buf:9.56313
input:9.492	rejected
button:9.37485	rejected
0:9.33295
 buffer:9.26844
new:9.21456	rejected

:9.2
bu:8.99554
a:8.99371

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <buffer>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: String
  LSP: Info: Seft type: (String, [(String, Bool)])
  LSP: Info: Error Status: (Exp (Common (Inconsistent Expectation {ana = String; syn = (Var "Model")})))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: buffer
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: buffer
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:16.3252
)):14.1263	rejected
),:13.6647	rejected
))):12.0112	rejected
):11.805
.:10.4752	rejected
)),:10.2558	rejected
)))):10.1401	rejected
_:9.78599	rejected
 ,:9.59421

:9.4733
 todo:9.03064	rejected
tod:8.99076	rejected
)));:8.95987	rejected
,,:8.75955	rejected
 +:8.70996
)(:8.57514	rejected
 int:8.50047	rejected
 todos:8.46813	rejected
)::8.3894	rejected
(:8.36268

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer,

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: String
  LSP: Info: Seft type: ((String, [(String, Bool)]), ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = String;
           syn = (Prod [(Var "Model"); (Unknown Internal)])})))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, ?))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, ?))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, ?
Nature of error: Expecting type String but got inconsistent type (Model, ?)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, ?))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, ?))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: String
  LSP: Info: Seft type: ((String, [(String, Bool)]), ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = String;
           syn = (Prod [(Var "Model"); (Unknown Internal)])})))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, ?))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, ?))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, ?
Nature of error: Expecting type String but got inconsistent type (Model, ?)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, ?))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, ?))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, ?))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, ?))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, ?
Nature of error: Expecting type String but got inconsistent type (Model, ?)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, ?))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, ?))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todos" | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 int:13.9815
 todos:13.0728
 i:11.5588
 toggle:11.5491
 todo:10.9544
 :10.5772
 remove:10.313
 tod:9.98338
 to:9.85392
 index:9.27011	rejected
tod:9.14592
 (:9.11635
 t:8.861
 in:8.60296
 togg:8.59337

:8.52091
 tokens:8.45959	rejected
 [:8.39594
 list:8.30179	rejected
 add:8.2601
 Tod:8.17922

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <int>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "int"))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  int
Nature of error: Variable int is not bound  
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int
Nature of error: Expecting type String but got inconsistent type (Model, ?)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: int
LSP: Generating Completions for prefix: int
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_of_float" | "_of_string"
root ::= completions

Top 20 Logits:
_:15.7835
s:10.2315	rejected
 of:9.88902	rejected
os:9.72614	rejected
)):9.65181	rejected
6:8.90744	rejected
3:8.70328	rejected
):8.66902	rejected
(:8.61745	rejected
-:8.58297	rejected
.:8.37549	rejected
Of:8.302	rejected
__:8.27631	rejected
,:8.26091	rejected
od:8.21252	rejected
p:8.08164	rejected
0:8.07576	rejected
of:8.07206	rejected
list:7.77176	rejected
f:7.68878	rejected
 _:7.64627	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <int_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "int_"))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int_))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_
Nature of error: Expecting type String but got inconsistent type (Model, ?)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  int_
Nature of error: Variable int_ is not bound  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: int_
LSP: Generating Completions for prefix: int_
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "of_float" | "of_string"
root ::= completions

Top 20 Logits:
of:18.13
to:13.4539	rejected
os:11.7204	rejected
or:11.2889	rejected
o:11.2834
list:10.7028	rejected
off:10.6939	rejected
t:10.6636	rejected
0:10.6393	rejected
f:10.5008	rejected
if:10.3283	rejected
tod:10.2481	rejected
for:10.2011	rejected
fo:10.1136	rejected
 of:10.1091	rejected
from:10.1051	rejected
string:10.0355	rejected
so:9.9718	rejected
Of:9.927	rejected
od:9.91863	rejected
str:9.754	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <int_of>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "int_of"))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  int_of
Nature of error: Variable int_of is not bound  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int_of))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of
Nature of error: Expecting type String but got inconsistent type (Model, ?)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: int_of
LSP: Generating Completions for prefix: int_of
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_float" | "_string"
root ::= completions

Top 20 Logits:
_:17.4201
__:9.29839	rejected
-:9.28672	rejected
(:8.48521	rejected
 _:8.47895	rejected
o:8.40969	rejected
.:8.30213	rejected
s:7.6115	rejected
 Tod:7.50585	rejected
_(:7.48442	prefix accepted:_

:7.44354	rejected
 todo:7.4226	rejected
,:7.32621	rejected
):7.27543	rejected
 TODO:7.24584	rejected
)):7.21704	rejected
 string:7.20525	rejected
T:7.06088	rejected
 of:7.05812	rejected
 todos:6.98235	rejected
string:6.87098	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <int_of_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "int_of_"))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int_of_))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_
Nature of error: Expecting type String but got inconsistent type (Model, ?)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  int_of_
Nature of error: Variable int_of_ is not bound  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: int_of_
LSP: Generating Completions for prefix: int_of_
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "float" | "string"
root ::= completions

Top 20 Logits:
string:17.7322
st:14.5203
str:12.8821
String:12.1912	rejected
tring:12.1901	rejected
s:12.0401
list:11.9031	rejected
strings:11.8551	rejected
sr:11.147	rejected
to:11.0645	rejected
t:10.8148	rejected
int:10.6233	rejected
 string:10.5354	rejected
stream:10.2522	rejected
tod:10.0874	rejected
ts:9.91201	rejected
sing:9.80513	rejected
ster:9.76086	rejected
sto:9.60211	rejected
f:9.27157
float:9.17482

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <int_of_string>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (String -> Int)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int_of_string))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string
Nature of error: Expecting type String but got inconsistent type (Model, (String -> Int))  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: int_of_string
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: int_of_string
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
(:16.2665
)):11.0434	rejected
_:10.5362	rejected
((:10.0044	rejected
))):9.55391	rejected
():9.54522	rejected
):9.522
 (:9.37922
tod:9.36852	rejected
)))):9.21428	rejected

:9.18129
())):9.00462	rejected
()):8.93036	rejected
(":8.91591	rejected
,:8.88554
[:8.85853	rejected
(_:8.36019	rejected
buffer:8.3351	rejected
 todos:8.32042	rejected
.:8.27316	rejected
 :8.18819

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(?)))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int_of_string(?)))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(?)
Nature of error: Expecting type String but got inconsistent type (Model, Int)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(?)))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(?)))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(?)))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int_of_string(?)))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(?)
Nature of error: Expecting type String but got inconsistent type (Model, Int)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(?)))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(?)))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: String
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(?)))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int_of_string(?)))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(?)
Nature of error: Expecting type String but got inconsistent type (Model, Int)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(?)))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(?)))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todos" | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
buffer:16.3829
tod:13.4896
int:11.2526
b:11.091
buff:10.7099
to:10.6315

:10.4192
t:10.4071
bu:10.0924
i:10.0521
button:9.85284	rejected
buf:9.80799
 buffer:9.54796
s:9.48229
string:9.40624
0:9.35851
str:9.23495
1:9.02215
remove:8.81948
update:8.739
add:8.7268

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <buffer>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: String
  LSP: Info: Seft type: (String, [(String, Bool)])
  LSP: Info: Error Status: (Exp (Common (Inconsistent Expectation {ana = String; syn = (Var "Model")})))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer)))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int_of_string(buffer)))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer)
Nature of error: Expecting type String but got inconsistent type (Model, Int)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer)))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer)))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: buffer
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: buffer
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:16.8105
)):11.1315	rejected
.:10.7741	rejected
),:10.6114	rejected
))):10.0566	rejected
):9.927
 ,:9.91157
 todos:9.83309	rejected
,,:9.36207	rejected
)))):9.31693	rejected

:9.23699
(:8.72395
tod:8.71426	rejected
 todo:8.6532	rejected
)),:8.60212	rejected
_:8.57286	rejected
 to:8.46525	rejected
 :8.42776
 int:7.97763	rejected
 (:7.88916
,(:7.84972	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer,

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: String
  LSP: Info: Seft type: ((String, [(String, Bool)]), ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = String;
           syn = (Prod [(Var "Model"); (Unknown Internal)])})))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, ?
Nature of error: Expecting type String but got inconsistent type (Model, ?)  
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, ?)))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int_of_string(buffer, ?)))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, ?)
Nature of error: Expecting type String but got inconsistent type (Model, Int)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, ?)))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, ?)))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: String
  LSP: Info: Seft type: ((String, [(String, Bool)]), ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = String;
           syn = (Prod [(Var "Model"); (Unknown Internal)])})))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, ?
Nature of error: Expecting type String but got inconsistent type (Model, ?)  
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, ?)))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int_of_string(buffer, ?)))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, ?)
Nature of error: Expecting type String but got inconsistent type (Model, Int)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, ?)))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, ?)))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, ?
Nature of error: Expecting type String but got inconsistent type (Model, ?)  
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, ?)))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int_of_string(buffer, ?)))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, ?)
Nature of error: Expecting type String but got inconsistent type (Model, Int)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, ?)))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, ?)))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todos" | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 todos:14.7875
 int:10.777
 todo:10.6949
 tod:10.494
 :10.2304
 buffer:10.0776
 toggle:9.98053
tod:9.78993
 i:9.54986
 to:9.44136

:9.40271
 tokens:9.25003	rejected
 string:8.84609
 t:8.7605
 remove:8.73326
 index:8.70007	rejected
 (:8.64433
 Tod:8.55626
 list:8.46617	rejected
 add:8.4183
 update:8.27246

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <todos>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos)
Nature of error: Expecting type String but got inconsistent type (Model, Int)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: todos
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: todos
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
)):15.6896	rejected
):15.6078
))):14.4669	rejected
)))):13.7426	rejected

:11.2551
)),:10.3523	rejected
));:10.2077	rejected
),:10.2014	rejected
);:10.1924	rejected
)]:10.0334	rejected
)));:9.90776	rejected
).:9.20615	rejected
 :9.14001
)).:8.92201	rejected
))]:8.80257	rejected
)}:8.76713	rejected
 ):8.6311
)|:8.27512	rejected
,:8.25876
))::8.20406	rejected
)(:8.14909	rejected
Rejected the highest logit candidate )) with logit -inf

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos)
Nature of error: Expecting type String but got inconsistent type (Model, Int)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:

:15.9913
 :13.8162
 in:13.7569	rejected
 end:12.2489	rejected
 #:11.8318	rejected
#:11.7531	rejected
  :11.6651
    :11.2838
 ):10.8521
     :9.8777
 |:9.84948	rejected
in:9.76441	rejected
end:9.76015	rejected
      :9.71769
   :9.5673
                :9.3658
 <:9.35544
        :9.19829
<:9.18896
 ?:9.04334	rejected
       :8.88806

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)


LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos)
Nature of error: Expecting type String but got inconsistent type (Model, Int)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
   :17.2772
 :14.3459
end:13.7736	rejected
    :13.1948
  :13.1144
#:12.9149	rejected
     :12.8574

:12.7784
       :11.6766
                :11.6408
      :10.8977
	:10.7451	rejected
|:10.7039	rejected
        :10.6589
}:10.5792	rejected
 end:10.4484	rejected
<:10.1491
         :10.0038
 |:9.85157	rejected
...:9.72383	rejected
):9.64966

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
   

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
   
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos)
Nature of error: Expecting type String but got inconsistent type (Model, Int)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
 <:16.4758
 |:14.8663	rejected
 end:12.9027	rejected
 >:12.5913
 #:12.1888	rejected
 in:11.6988	rejected
 ):11.4797
 \:10.8402
 </:10.7024	rejected
 ?:10.2092	rejected
 ~:10.1915	rejected
 ...:10.112	rejected
 _:10.0971	rejected
 $:10.0628
 @:10.0587
 !:9.8414
 =>:9.7925	rejected
 ]:9.67789	rejected
 }:9.61812	rejected
 <>:9.51804	rejected
 else:9.47907	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    <

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    <
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: ><<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Integer Less Than
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < ?))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < ?))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < ?
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < ?))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < ?))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Integer Less Than
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < ?))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < ?))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < ?
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < ?))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < ?))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < ?))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < ?))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < ?
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < ?))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < ?))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: <
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: <
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "." | "=" | "=."
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todos" | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
 Update:16.615
 _:11.0407	rejected
 Up:10.359
 :10.2479
 Set:9.95346	rejected
 Buffer:9.60631	rejected
 update:9.41995
 U:9.38628
Update:9.24031
 (:9.20183
 Change:8.67038	rejected
 Action:8.63053	rejected
 Updated:8.59525	rejected
>:8.58921	rejected
 Input:8.43437	rejected
 T:8.42948
 Add:8.36489
 Write:8.23501	rejected
 |:8.19679	rejected
 #:8.05627	rejected
 u:8.04843

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < Update

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < Update
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Update>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "Update"))))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  Update
Nature of error: Constructor is not defined  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < Update))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < Update))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < Update
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < Update))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < Update))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Update
LSP: Generating Completions for prefix: Update
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Buffer"
root ::= completions

Top 20 Logits:
Buffer:18.0881
B:14.1527
Bu:11.7971
T:11.6423	rejected
(:11.3953	rejected
Description:10.7142	rejected
buffer:10.7117	rejected
_:10.5523	rejected
BU:10.3272	rejected
Model:10.3143	rejected
Input:10.0779	rejected
Button:9.77238	rejected
Desc:9.62201	rejected
Action:9.61415	rejected
 buffer:9.56273	rejected
Text:9.24842	rejected
Update:9.14518	rejected
 Buffer:9.12727	rejected
Des:9.10684	rejected
To:9.10542	rejected
String:8.88408	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < UpdateBuffer

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < UpdateBuffer
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <UpdateBuffer>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: (String -> (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)))
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = Int; syn = (Arrow (String, (Var "Action")))})))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < UpdateBuffer
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  UpdateBuffer
Nature of error: Expecting type Int but got inconsistent type (String -> Action)  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: UpdateBuffer
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: UpdateBuffer
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
(:15.2812
(_:11.3862	rejected
 =>:10.8	rejected
 buffer:10.6821	rejected
 s:10.3119	rejected
 (:10.2778
():9.92334	rejected
(":9.64086	rejected

:9.57561
((:9.12765	rejected
 ->:9.07307	rejected
 b:8.88878	rejected
($:8.77584	rejected
 str:8.6021	rejected
 in:8.46779	rejected
 buf:8.16696	rejected
 string:8.12294	rejected
::8.0977
(?:8.024	rejected
 _:8.00246	rejected
 :7.88607

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < UpdateBuffer(

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < UpdateBuffer(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String))
  LSP: Info: Error Status: (Exp (Common (Inconsistent Expectation {ana = Int; syn = (Var "Action")})))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  UpdateBuffer(?)
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(?)))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(?)))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < UpdateBuffer(?)
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(?)))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(?)))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String))
  LSP: Info: Error Status: (Exp (Common (Inconsistent Expectation {ana = Int; syn = (Var "Action")})))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  UpdateBuffer(?)
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(?)))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(?)))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < UpdateBuffer(?)
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(?)))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(?)))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: String
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  UpdateBuffer(?)
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(?)))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(?)))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < UpdateBuffer(?)
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(?)))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(?)))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todos" | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
buffer:14.0866
s:13.7726
str:12.5444
b:12.1749
string:11.9848
update:11.5089
String:11.4311	rejected
new:11.2571	rejected
x:11.1295	rejected
buf:11.1094
description:11.0768	rejected
tod:10.6485
t:10.5554
char:9.88605	rejected
action:9.85319	rejected
input:9.79307	rejected
desc:9.69278	rejected
des:9.67737	rejected
up:9.64223
a:9.56769
int:9.48603

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < UpdateBuffer(str

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < UpdateBuffer(str
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <str>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: String
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "str"))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  UpdateBuffer(str)
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(str)))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(str)))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < UpdateBuffer(str)
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(str)))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  str
Nature of error: Variable str is not bound  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(str)))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: str
LSP: Generating Completions for prefix: str
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ing_compare" | "ing_concat" | "ing_contains" | "ing_length" | "ing_of_bool" | "ing_of_float" | "ing_of_int" | "ing_sub" | "ing_trim"
root ::= completions

Top 20 Logits:
):13.2092	rejected
_:12.3339	rejected
)):12.0613	rejected
ng:11.3266	rejected
in:10.7461
1:10.22	rejected
g:9.66135	rejected
int:9.53447	rejected
:::9.45032	rejected
,:9.41161	rejected
ig:9.29721	rejected
 ->:9.14174	rejected
(:9.09459	rejected
::9.05456	rejected
))):9.00986	rejected
ign:8.93116	rejected
2:8.7946	rejected
),:8.64307	rejected
n:8.49461	rejected
s:8.45481	rejected
 =>:8.39913	rejected
Rejected the highest logit candidate ) with logit -inf

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < UpdateBuffer(strin

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < UpdateBuffer(strin
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <strin>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: String
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "strin"))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  UpdateBuffer(strin)
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(strin)))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(strin)))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < UpdateBuffer(strin)
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(strin)))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  strin
Nature of error: Variable strin is not bound  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(strin)))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: strin
LSP: Generating Completions for prefix: strin
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "g_compare" | "g_concat" | "g_contains" | "g_length" | "g_of_bool" | "g_of_float" | "g_of_int" | "g_sub" | "g_trim"
root ::= completions

Top 20 Logits:
_:10.3947	rejected
)):10.2926	rejected
):10.2075	rejected
ng:9.44635	rejected
b:9.1568	rejected
buffer:9.13731	rejected
h:9.11501	rejected
ig:9.01626	rejected

:9.00658	rejected
(:8.96436	rejected
 buffer:8.59324	rejected
bg:8.46099	rejected
p:8.36588	rejected
 in:8.20371	rejected
,:8.10966	rejected
str:7.95095	rejected
eg:7.9038	rejected
))):7.87188	rejected
$:7.58545	rejected
 :7.57959	rejected
 str:7.56319	rejected
Rejected the highest logit candidate _ with logit -inf

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < UpdateBuffer(string

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < UpdateBuffer(string
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <string>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: String
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "string"))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  string
Nature of error: Variable string is not bound  
Error in term:
  UpdateBuffer(string)
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string)))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string)))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < UpdateBuffer(string)
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string)))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string)))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: string
LSP: Generating Completions for prefix: string
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_compare" | "_concat" | "_contains" | "_length" | "_of_bool" | "_of_float" | "_of_int" | "_sub" | "_trim"
root ::= completions

Top 20 Logits:
):12.5129	rejected
)):12.2255	rejected
,:11.3224	rejected
_:11.1516
))):10.263	rejected
),:9.74419	rejected
(:9.51373	rejected
 =>:9.49916	rejected

:9.41324	rejected
 in:9.38081	rejected
 of:8.46655	rejected
 ->:8.45999	rejected
tod:8.29675	rejected
 buffer:8.18416	rejected
);:8.08335	rejected
::7.99805	rejected
)),:7.99141	rejected
 string:7.96885	rejected
)))):7.87271	rejected
.:7.87045	rejected
 =:7.81888	rejected
Rejected the highest logit candidate ) with logit -inf

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < UpdateBuffer(string_

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < UpdateBuffer(string_
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <string_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: String
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "string_"))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  UpdateBuffer(string_)
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_)))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  string_
Nature of error: Variable string_ is not bound  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_)))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < UpdateBuffer(string_)
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_)))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_)))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: string_
LSP: Generating Completions for prefix: string_
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "compare" | "concat" | "contains" | "length" | "of_bool" | "of_float" | "of_int" | "sub" | "trim"
root ::= completions

Top 20 Logits:
of:15.2348
to:12.1546	rejected
concat:11.3206
buffer:11.1784	rejected
append:10.9666	rejected
add:10.8013	rejected
buf:10.7865	rejected
update:10.3343	rejected
o:10.0097
replace:10.0064	rejected
t:9.74156
con:9.69236
str:9.68085	rejected
input:9.65605	rejected
int:9.32088	rejected
length:9.2189
string:9.16644	rejected
f:8.91825	rejected
in:8.9163	rejected
substring:8.85468	rejected
b:8.80479	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < UpdateBuffer(string_of

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < UpdateBuffer(string_of
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <string_of>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: String
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "string_of"))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  UpdateBuffer(string_of)
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of)))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of)))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of)
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of)))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  string_of
Nature of error: Variable string_of is not bound  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of)))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: string_of
LSP: Generating Completions for prefix: string_of
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_bool" | "_float" | "_int"
root ::= completions

Top 20 Logits:
_:16.4559
 string:10.2813	rejected
(:10.1935	rejected
 _:9.86613	rejected
s:9.62048	rejected
 buffer:9.46341	rejected
):9.37204	rejected
string:9.35419	rejected

:8.70021	rejected
st:8.61678	rejected
_(:8.60409	prefix accepted:_
buffer:8.56178	rejected
.:8.4523	rejected
<:8.40179	rejected
)):8.33805	rejected
g:8.28871	rejected
-:8.15708	rejected
b:8.02778	rejected
String:7.94097	rejected
__:7.92542	rejected
int:7.77279	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < UpdateBuffer(string_of_

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < UpdateBuffer(string_of_
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <string_of_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: String
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "string_of_"))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  UpdateBuffer(string_of_)
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_)))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_)))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_)
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_)))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  string_of_
Nature of error: Variable string_of_ is not bound  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_)))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: string_of_
LSP: Generating Completions for prefix: string_of_
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "bool" | "float" | "int"
root ::= completions

Top 20 Logits:
string:14.6917	rejected
int:13.1578
buffer:13.0049	rejected
st:12.5867	rejected
s:12.0942	rejected
str:11.8923	rejected
ints:10.7792	rejected
strings:10.6471	rejected
char:10.5202	rejected
float:10.4665
integer:10.2027	rejected
stream:10.0399	rejected
to:9.86902	rejected
inte:9.82281	rejected
input:9.48439	rejected
b:9.42268
substring:9.36378	rejected
t:9.33969	rejected
list:9.31745	rejected
bytes:9.26765	rejected
buf:9.26632	rejected
Rejected the highest logit candidate string with logit -inf

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < UpdateBuffer(string_of_int

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < UpdateBuffer(string_of_int
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <string_of_int>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: String
  LSP: Info: Seft type: (Int -> String)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = String; syn = (Arrow (Int, String))})))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  string_of_int
Nature of error: Expecting type String but got inconsistent type (Int -> String)  
Error in term:
  UpdateBuffer(string_of_int)
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int)))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int)))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int)
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int)))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int)))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: string_of_int
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: string_of_int
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
(:14.6245
_:11.3297	rejected
g:10.0495	rejected
):9.68331
)):9.63958	rejected
t:9.54271	rejected
()):9.42951	rejected
((:9.40722	rejected
,:9.38376
 (:9.28116
 buffer:9.16408	rejected
buffer:9.10044	rejected
ng:8.94892	rejected

:8.82966
():8.68752	rejected
st:8.67633	rejected
(_:8.54853	rejected
(":8.4402	rejected
to:8.4348	rejected
int:8.27262	rejected
tring:8.2352	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < UpdateBuffer(string_of_int(

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < UpdateBuffer(string_of_int(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: String
  LSP: Info: Seft type: String
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  UpdateBuffer(string_of_int(?))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(?))))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(?))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(?))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(?))))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(?))))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: String
  LSP: Info: Seft type: String
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  UpdateBuffer(string_of_int(?))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(?))))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(?))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(?))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(?))))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(?))))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  UpdateBuffer(string_of_int(?))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(?))))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(?))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(?))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(?))))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(?))))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todos" | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
buffer:15.3335
int:12.4243
string:11.6655
str:11.5945
b:11.3503
tod:11.0395
update:10.7059
to:10.4153
buf:10.3268
s:10.2606
t:10.1543
buff:10.0793
i:10.0317
up:9.97374
index:9.4139	rejected
Update:9.38921
bu:9.34242
st:9.26517
0:9.15967
new:8.9915	rejected
integer:8.97516	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < UpdateBuffer(string_of_int(buffer

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < UpdateBuffer(string_of_int(buffer
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <buffer>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: (String, [(String, Bool)])
  LSP: Info: Error Status: (Exp (Common (Inconsistent Expectation {ana = Int; syn = (Var "Model")})))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  UpdateBuffer(string_of_int(buffer))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer))))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer))))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  buffer
Nature of error: Expecting type Int but got inconsistent type Model  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer))))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: buffer
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: buffer
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:15.448
)):12.4795	rejected
):10.9388
))):10.9235	rejected
),:10.9073	rejected
g:10.8167	rejected
_:10.4335	rejected
.:9.79988	rejected
 string:9.20028	rejected
)))):9.13451	rejected
t:9.02865	rejected
ing:9.01617	rejected

:8.98454
 of:8.80659	rejected
 +:8.17966
)),:8.05913	rejected
 int:8.04725	rejected
(:7.89668
,,:7.82505	rejected
_,:7.77504	rejected
m:7.66423	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < UpdateBuffer(string_of_int(buffer,

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < UpdateBuffer(string_of_int(buffer,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ((String, [(String, Bool)]), ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = Int;
           syn = (Prod [(Var "Model"); (Unknown Internal)])})))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  UpdateBuffer(string_of_int(buffer, ?))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, ?))))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, ?))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, ?))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, ?))))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  buffer, ?
Nature of error: Expecting type Int but got inconsistent type (Model, ?)  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, ?))))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ((String, [(String, Bool)]), ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = Int;
           syn = (Prod [(Var "Model"); (Unknown Internal)])})))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  UpdateBuffer(string_of_int(buffer, ?))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, ?))))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, ?))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, ?))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, ?))))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  buffer, ?
Nature of error: Expecting type Int but got inconsistent type (Model, ?)  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, ?))))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  UpdateBuffer(string_of_int(buffer, ?))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, ?))))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, ?))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, ?))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, ?))))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  buffer, ?
Nature of error: Expecting type Int but got inconsistent type (Model, ?)  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, ?))))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todos" | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 string:13.1786
 int:12.9288
 str:12.1514
 todos:10.6566
 update:10.352
 in:10.3331
 buffer:10.0201
 (:9.39216
 :9.14129
 i:9.12313
 s:9.06208
 to:8.99978
 todo:8.90306
tod:8.87293
 toggle:8.64684
 add:8.34056
 model:8.32283	rejected
int:8.19566
 ing:8.13785	rejected

:8.10585
 st:8.00124

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < UpdateBuffer(string_of_int(buffer, string

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < UpdateBuffer(string_of_int(buffer, string
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <string>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "string"))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  string
Nature of error: Variable string is not bound  
Error in term:
  UpdateBuffer(string_of_int(buffer, string))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string))))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string))))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  buffer, string
Nature of error: Expecting type Int but got inconsistent type (Model, ?)  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string))))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: string
LSP: Generating Completions for prefix: string
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_compare" | "_concat" | "_contains" | "_length" | "_of_bool" | "_of_float" | "_of_int" | "_sub" | "_trim"
root ::= completions

Top 20 Logits:
_:14.5657
ing:10.8958	rejected
ng:10.2699	rejected
g:10.0925	rejected
n:9.90393	rejected
of:9.71598	rejected
in:9.61134	rejected
o:9.42989	rejected
)):9.40455	rejected
f:9.35461	rejected
 of:9.20709	rejected
int:8.82057	rejected
t:8.63325	rejected
.:8.4762	rejected
):8.41428	rejected
i:8.28104	rejected
(:8.20171	rejected
ig:8.10336	rejected
ong:8.06342	rejected
og:8.04832	rejected
,:8.0439	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < UpdateBuffer(string_of_int(buffer, string_

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < UpdateBuffer(string_of_int(buffer, string_
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <string_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "string_"))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  UpdateBuffer(string_of_int(buffer, string_))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  string_
Nature of error: Variable string_ is not bound  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_))))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_))))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  buffer, string_
Nature of error: Expecting type Int but got inconsistent type (Model, ?)  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_))))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: string_
LSP: Generating Completions for prefix: string_
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "compare" | "concat" | "contains" | "length" | "of_bool" | "of_float" | "of_int" | "sub" | "trim"
root ::= completions

Top 20 Logits:
of:17.0005
to:12.8209	rejected
o:11.6879
int:10.6314	rejected
f:10.5863	rejected
on:10.41	rejected
off:10.3842	rejected
if:10.2637	rejected
or:9.99791	rejected
fo:9.95354	rejected
0:9.83381	rejected
 of:9.71164	rejected
add:9.69927	rejected
length:9.67955
od:9.50389	rejected
concat:9.48184
buffer:9.42505	rejected
og:9.34217	rejected
for:9.31256	rejected
ot:9.25156	rejected
list:9.19762	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < UpdateBuffer(string_of_int(buffer, string_of

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < UpdateBuffer(string_of_int(buffer, string_of
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <string_of>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "string_of"))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  UpdateBuffer(string_of_int(buffer, string_of))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of))))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of))))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  string_of
Nature of error: Variable string_of is not bound  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  buffer, string_of
Nature of error: Expecting type Int but got inconsistent type (Model, ?)  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of))))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: string_of
LSP: Generating Completions for prefix: string_of
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_bool" | "_float" | "_int"
root ::= completions

Top 20 Logits:
_:17.2217
int:10.8387	rejected
(:10.38	rejected
 int:9.83131	rejected
_(:9.59044	prefix accepted:_
-:9.35529	rejected
i:9.29002	rejected
__:9.08336	rejected
Int:8.75949	rejected
 _:8.71843	rejected
ing:8.57868	rejected
.:8.35899	rejected
s:8.35055	rejected
):8.2265	rejected
)):8.08938	rejected
l:8.00231	rejected
n:7.95439	rejected

:7.86372	rejected
string:7.827	rejected
 string:7.80137	rejected
g:7.7792	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < UpdateBuffer(string_of_int(buffer, string_of_

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < UpdateBuffer(string_of_int(buffer, string_of_
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <string_of_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "string_of_"))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  UpdateBuffer(string_of_int(buffer, string_of_))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_))))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  string_of_
Nature of error: Variable string_of_ is not bound  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_))))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  buffer, string_of_
Nature of error: Expecting type Int but got inconsistent type (Model, ?)  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_))))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: string_of_
LSP: Generating Completions for prefix: string_of_
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "bool" | "float" | "int"
root ::= completions

Top 20 Logits:
int:16.4451
ints:12.5054	rejected
string:12.2178	rejected
ing:11.8075	rejected
t:11.5503	rejected
in:11.4515
it:11.2686	rejected
float:11.2617
bool:11.1324
into:10.9325	rejected
i:10.8816
list:10.3409	rejected
buffer:10.1929	rejected
str:10.1138	rejected
ingt:9.87208	rejected
tod:9.66984	rejected
integer:9.58582	rejected
inte:9.54825	rejected
model:9.49336	rejected
char:9.31136	rejected
to:9.15463	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < UpdateBuffer(string_of_int(buffer, string_of_int

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < UpdateBuffer(string_of_int(buffer, string_of_int
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <string_of_int>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (Int -> String)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  UpdateBuffer(string_of_int(buffer, string_of_int))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int))))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int))))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  buffer, string_of_int
Nature of error: Expecting type Int but got inconsistent type (Model, (Int -> String))  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int))))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: string_of_int
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: string_of_int
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
(:16.6188
)):11.197	rejected
_:10.9827	rejected
 (:10.3131
g:10.1047	rejected
t:9.91542	rejected
((:9.75926	rejected
b:9.67515	rejected
 buffer:9.61016	rejected
():9.40274	rejected
buffer:9.38314	rejected
ng:9.32441	rejected
())):9.29056	rejected
):9.05478
s:9.01826	rejected
()):8.97566	rejected
))):8.91076	rejected
tod:8.81405	rejected

:8.621
ing:8.61676	rejected
,:8.51944

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < UpdateBuffer(string_of_int(buffer, string_of_int(

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < UpdateBuffer(string_of_int(buffer, string_of_int(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: String
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  UpdateBuffer(string_of_int(buffer, string_of_int(?)))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(?)))))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(?)))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(?)))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(?)))))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  buffer, string_of_int(?)
Nature of error: Expecting type Int but got inconsistent type (Model, String)  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(?)))))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: String
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  UpdateBuffer(string_of_int(buffer, string_of_int(?)))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(?)))))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(?)))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(?)))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(?)))))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  buffer, string_of_int(?)
Nature of error: Expecting type Int but got inconsistent type (Model, String)  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(?)))))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  UpdateBuffer(string_of_int(buffer, string_of_int(?)))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(?)))))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(?)))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(?)))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(?)))))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  buffer, string_of_int(?)
Nature of error: Expecting type Int but got inconsistent type (Model, String)  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(?)))))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todos" | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
buffer:16.955
b:12.6981
tod:11.8922
bu:11.483
string:11.4506
buff:11.3789
int:11.3077
str:11.1495
buf:11.0775
i:10.1873
s:10.0586
t:10.0522
to:9.94227
button:9.84101	rejected
 buffer:9.76594

:9.56426
update:9.20651
br:9.04258	rejected
bucket:9.02432	rejected
model:8.99816	rejected
new:8.95399	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < UpdateBuffer(string_of_int(buffer, string_of_int(buffer

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < UpdateBuffer(string_of_int(buffer, string_of_int(buffer
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <buffer>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: (String, [(String, Bool)])
  LSP: Info: Error Status: (Exp (Common (Inconsistent Expectation {ana = Int; syn = (Var "Model")})))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  UpdateBuffer(string_of_int(buffer, string_of_int(buffer)))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer)))))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type Int but got inconsistent type Model  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer)))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer)))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer)))))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  buffer, string_of_int(buffer)
Nature of error: Expecting type Int but got inconsistent type (Model, String)  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer)))))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: buffer
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: buffer
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:16.2975
)):11.3737	rejected
g:11.0885	rejected
))):10.7116	rejected
):10.251
),:10.2126	rejected
.:9.87554	rejected
)))):9.43071	rejected
tod:8.96432	rejected
_:8.89171	rejected

:8.84516
 ,:8.66068
 to:8.60579	rejected
 todos:8.56919	rejected
)),:8.55392	rejected
t:8.28553	rejected
m:8.27199	rejected
,,:8.21574	rejected
 string:8.00949	rejected
 :7.98067
 of:7.89723	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < UpdateBuffer(string_of_int(buffer, string_of_int(buffer,

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < UpdateBuffer(string_of_int(buffer, string_of_int(buffer,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ((String, [(String, Bool)]), ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = Int;
           syn = (Prod [(Var "Model"); (Unknown Internal)])})))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, ?
Nature of error: Expecting type Int but got inconsistent type (Model, ?)  
Error in term:
  UpdateBuffer(string_of_int(buffer, string_of_int(buffer, ?)))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, ?)))))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, ?)))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, ?)))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, ?)))))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  buffer, string_of_int(buffer, ?)
Nature of error: Expecting type Int but got inconsistent type (Model, String)  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, ?)))))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ((String, [(String, Bool)]), ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = Int;
           syn = (Prod [(Var "Model"); (Unknown Internal)])})))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, ?
Nature of error: Expecting type Int but got inconsistent type (Model, ?)  
Error in term:
  UpdateBuffer(string_of_int(buffer, string_of_int(buffer, ?)))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, ?)))))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, ?)))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, ?)))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, ?)))))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  buffer, string_of_int(buffer, ?)
Nature of error: Expecting type Int but got inconsistent type (Model, String)  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, ?)))))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, ?
Nature of error: Expecting type Int but got inconsistent type (Model, ?)  
Error in term:
  UpdateBuffer(string_of_int(buffer, string_of_int(buffer, ?)))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, ?)))))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, ?)))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, ?)))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, ?)))))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  buffer, string_of_int(buffer, ?)
Nature of error: Expecting type Int but got inconsistent type (Model, String)  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, ?)))))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todos" | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 todos:13.4244
 string:11.8396
 str:11.2376
 int:10.7782
 tod:10.1295
 buffer:9.83407
 update:9.70343
 to:9.60549
 todo:9.57719
tod:9.57335
 :9.26165
 st:8.93032
 toggle:8.88646
 (:8.75714
 t:8.70768

:8.55742
 s:8.4278
 list:8.26451	rejected
 model:8.14321	rejected
 action:8.09237	rejected
 strings:8.00344	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <todos>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type Int but got inconsistent type (Model, Action)  
Error in term:
  UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos)))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos)))))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos)))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos)))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos)))))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  buffer, string_of_int(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type (Model, String)  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos)))))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: todos
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: todos
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
):14.3912
)):14.1959	rejected
))):12.9117	rejected
)))):12.2859	rejected
 end:10.4347	rejected

:10.2292
 in:10.0666	rejected
),:9.31245	rejected
g:8.97843	rejected
)),:8.78725	rejected
);:8.69743	rejected
 :8.60549
).:8.44934	rejected
));:8.34797	rejected
)::8.19093	rejected
end:8.10848	rejected
 ):7.97005
)));:7.92105	rejected
)]:7.81503	rejected
)).:7.64798	rejected
))::7.5416	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos)

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: String
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type Int but got inconsistent type (Model, Action)  
Error in term:
  UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos)))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos)))))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos)))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos)))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos)))))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  buffer, string_of_int(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type (Model, String)  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos)))))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
 in:14.0376	rejected
 end:13.7913	rejected

:13.5907
 :12.0913
 ):10.5573
end:10.2902	rejected
  :9.82306
#:9.53809	rejected
 #:9.36981	rejected
    :8.94643
 else:8.38573	rejected
in:8.31037	rejected
 =>:8.22763	rejected
     :8.20597
 |:8.02097	rejected
      :7.96817
g:7.88739	rejected
t:7.85681	rejected
                :7.83315
   :7.8016
 ?:7.58317	rejected
Rejected the highest logit candidate  in with logit -inf

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) 

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) 
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: String
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type Int but got inconsistent type (Model, Action)  
Error in term:
  UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos)))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos)))))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos)))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos)))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos)))))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  buffer, string_of_int(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type (Model, String)  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos)))))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:

:17.1167
 end:16.4496	rejected
 in:16.2771	rejected
)):15.0077	rejected
 #:13.9056	rejected
 ):13.5391
))):13.3879	rejected
)))):12.5691	rejected
 |:12.0202	rejected
 else:11.9275	rejected
 ?:11.1629	rejected
 with:11.1162	rejected
 *):11.0102	rejected
 =>:10.9675	rejected
 where:10.9269	rejected
	:10.9194	rejected
 =:10.8791
]):10.8389	rejected
 ::10.7603
 @:10.7189
nd:10.6452	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) 


LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) 

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: String
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type Int but got inconsistent type (Model, Action)  
Error in term:
  UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos)))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos)))))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos)))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos)))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos)))))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  buffer, string_of_int(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type (Model, String)  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos)))))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
   :15.4247
end:14.9632	rejected

:14.5291
  :13.6447
 :13.6295
    :13.577
#:13.4766	rejected
     :12.9242
                :12.2986
}:12.0925	rejected
       :11.8615
|:11.7148	rejected
```:11.7132	rejected
      :11.5714
 end:11.4445	rejected
        :11.3911
in:11.3298	rejected
let:10.9159	rejected
         :10.7219
where:10.7098	rejected
else:10.4351	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) 
   

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) 
   
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: String
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type Int but got inconsistent type (Model, Action)  
Error in term:
  UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos)))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos)))))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos)))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos)))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos)))))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  buffer, string_of_int(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type (Model, String)  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos)))))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
 end:13.1696	rejected
 |:12.9292	rejected
 <:11.4434
 in:10.7761	rejected
 else:10.4566	rejected
 ):10.1153
 >:10.0733
 #:9.91308	rejected
 =>:9.12635	rejected
 =:9.02406
 </:9.01626	rejected
 _:8.95427	rejected
 return:8.48598	rejected
 ]:8.20483	rejected
 }:8.19267	rejected
 <>:8.0801	rejected
 with:8.06015	rejected
 ?:8.0067	rejected
 !:7.90676
 ~:7.86449	rejected
 -:7.79707
Rejected the highest logit candidate  end with logit -inf

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) 
    <

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) 
    <
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: ><<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Integer Less Than
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type Int but got inconsistent type (Model, Action)  
Error in term:
  UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) < ?))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) < ?))))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) < ?))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) < ?))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) < ?))))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  string_of_int(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type String  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  buffer, string_of_int(buffer, todos) < ?
Nature of error: Expecting type Int but got inconsistent type (Model, Bool)  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) < ?))))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Integer Less Than
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type Int but got inconsistent type (Model, Action)  
Error in term:
  UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) < ?))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) < ?))))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) < ?))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) < ?))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) < ?))))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  string_of_int(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type String  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  buffer, string_of_int(buffer, todos) < ?
Nature of error: Expecting type Int but got inconsistent type (Model, Bool)  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) < ?))))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type Int but got inconsistent type (Model, Action)  
Error in term:
  UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) < ?))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) < ?))))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) < ?))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) < ?))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) < ?))))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  string_of_int(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type String  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  buffer, string_of_int(buffer, todos) < ?
Nature of error: Expecting type Int but got inconsistent type (Model, Bool)  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) < ?))))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: <
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: <
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "." | "=" | "=."
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todos" | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
 _:12.329	rejected
 ?:11.047	rejected
 Update:9.64645
 Model:9.06465
 a:9.04958
 :8.90489
>:8.90189	rejected
 _):8.88912	rejected
 end:8.74097	rejected
 (:8.60164
 ...:8.43638	rejected
 Tod:8.39138
 No:8.34185	rejected
 Un:8.17632	rejected
 >:8.1734	rejected
 Add:7.91538

:7.87275
 in:7.7666
 Action:7.73644	rejected
 _,:7.6716	rejected
 Done:7.6103	rejected
Rejected the highest logit candidate  _ with logit -inf

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) 
    < a

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) 
    < a
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <a>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "a"))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type Int but got inconsistent type (Model, Action)  
Error in term:
  UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) < a))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) < a))))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) < a))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) < a))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) < a))))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  string_of_int(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type String  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  buffer, string_of_int(buffer, todos) < a
Nature of error: Expecting type Int but got inconsistent type (Model, Bool)  
Error in term:
  a
Nature of error: Variable a is not bound  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) < a))))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: a
LSP: Generating Completions for prefix: a
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "bs" | "bs_float" | "cos" | "dd" | "sin" | "tan"
root ::= completions

Top 20 Logits:
co:11.0509
 in:9.66406	rejected
 end:9.65318	rejected

:9.06713	rejected
 =>:9.01806	rejected
 ->:7.86488	rejected
):7.84341	rejected
 :7.75541	rejected
ac:7.4595	rejected
oc:7.43184	rejected
_:7.4089	rejected
action:7.26447	rejected
ca:7.21999	rejected
end:7.19575	rejected
 else:7.02835	rejected
e:6.88426	rejected
.:6.8201	rejected
 action:6.77684	rejected
ck:6.74098	rejected
cos:6.73808
ction:6.69719	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) 
    < aco

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) 
    < aco
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <aco>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "aco"))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type Int but got inconsistent type (Model, Action)  
Error in term:
  UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) < aco))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) < aco))))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) < aco))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) < aco))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  aco
Nature of error: Variable aco is not bound  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) < aco))))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  string_of_int(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type String  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  buffer, string_of_int(buffer, todos) < aco
Nature of error: Expecting type Int but got inconsistent type (Model, Bool)  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) < aco))))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: aco
LSP: Generating Completions for prefix: aco
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "s"
root ::= completions

Top 20 Logits:
 in:10.8625	rejected
 end:10.7593	rejected
es:9.9203	rejected
a:9.63404	rejected

:9.4476	rejected
e:8.77874	rejected
 :8.55865	rejected
os:8.55132	rejected
):8.49767	rejected
 else:8.06394	rejected
end:7.94557	rejected
_:7.93636	rejected
)):7.75729	rejected
.:7.70659	rejected
s:7.67661
                :7.38049	rejected
z:7.37324	rejected
  :7.35302	rejected
o:7.21977	rejected
 with:7.18428	rejected
as:7.13371	rejected
Rejected the highest logit candidate  in with logit -inf

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) 
    < acos

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) 
    < acos
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <acos>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: (Float -> Float)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = Int; syn = (Arrow (Float, Float))})))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type Int but got inconsistent type (Model, Action)  
Error in term:
  UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) < acos))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  acos
Nature of error: Expecting type Int but got inconsistent type (Float -> Float)  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) < acos))))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) < acos))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) < acos))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) < acos))))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  string_of_int(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type String  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  buffer, string_of_int(buffer, todos) < acos
Nature of error: Expecting type Int but got inconsistent type (Model, Bool)  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) < acos))))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: acos
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: acos
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
 end:12.5107	rejected
 in:11.5555	rejected

:10.2689
 =>:9.89613	rejected
):9.81219
 :9.28077
                :8.64323
 ->:8.62581	rejected
.:8.21059	rejected
)):7.96772	rejected
_:7.86131	rejected
 ):7.79402
 =:7.78971
  :7.67909
 else:7.67742	rejected
,:7.39036
::7.37334
end:7.37282	rejected
 #:6.95807	rejected
 when:6.78251	rejected
 |:6.78114	rejected
Rejected the highest logit candidate  end with logit -inf

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) 
    < acos                

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) 
    < acos                
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <acos>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: (Float -> Float)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = Int; syn = (Arrow (Float, Float))})))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type Int but got inconsistent type (Model, Action)  
Error in term:
  UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) < acos))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  acos
Nature of error: Expecting type Int but got inconsistent type (Float -> Float)  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) < acos))))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) < acos))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) < acos))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) < acos))))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  string_of_int(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type String  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  buffer, string_of_int(buffer, todos) < acos
Nature of error: Expecting type Int but got inconsistent type (Model, Bool)  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) < acos))))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
                :16.2915
  :14.5508
       :14.2583
     :14.2016
         :14.1952
    :14.1865
      :14.1492
        :14.1466
             :13.9404
               :13.9326
            :13.8695
          :13.8411
              :13.7531
           :13.6759
 :13.0869
   :13.0336

:12.7462
 end:12.4855	rejected
 in:12.2363	rejected
 #:11.8409	rejected
 ):9.34206

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) 
    < acos                                

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos) ->
    case acos
    | AddTodo => (buffer, add(buffer, todos)
    < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos)
    < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) 
    < acos                                
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <acos>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: (Float -> Float)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = Int; syn = (Arrow (Float, Float))})))
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type String but got inconsistent type (Model, Action)  
Error in term:
  buffer, todos
Nature of error: Expecting type Int but got inconsistent type (Model, Action)  
Error in term:
  UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) < acos))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  acos
Nature of error: Expecting type Int but got inconsistent type (Float -> Float)  
Error in term:
  buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) < acos))))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) < acos))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) < acos))
Nature of error: Expecting type String but got inconsistent type (Model, Bool)  
Error in term:
  add(buffer, todos) < RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) < acos))))))
Nature of error: Expecting type [Todo] but got inconsistent type Bool  
Error in term:
  todos
Nature of error: Expecting type [Todo] but got inconsistent type Action  
Error in term:
  add(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type [Todo]  
Error in term:
  string_of_int(buffer, todos)
Nature of error: Expecting type Int but got inconsistent type String  
Error in term:
  buffer
Nature of error: Expecting type String but got inconsistent type Model  
Error in term:
  buffer, string_of_int(buffer, todos) < acos
Nature of error: Expecting type Int but got inconsistent type (Model, Bool)  
Error in term:
  RemoveTodo(int_of_string(buffer, int_of_string(buffer, todos) < ToggleTodo(int_of_string(buffer, int_of_string(buffer, todos) < UpdateBuffer(string_of_int(buffer, string_of_int(buffer, todos) < acos))))))
Nature of error: Expecting type Int but got inconsistent type Action  
Error in term:
  AddTodo
Nature of error: Expecting type (Float -> Float) but got inconsistent type Action
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
                :16.0369
               :14.1236
             :14.1028
  :14.0548
         :13.901
              :13.8857
            :13.8445
       :13.7845
     :13.7733
        :13.7173
          :13.6914
    :13.6806
           :13.6408
      :13.5054
   :12.6471
 :12.6342

:12.081
 #:11.8857	rejected
 end:11.6984	rejected
 in:11.3488	rejected
 |:9.08023	rejected
