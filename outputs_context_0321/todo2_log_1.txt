

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
LSP: Process zipper: Recieved string
LSP: Process Zipper: No serialized zipper, processing string
LSP: Process zipper: Recieved string
LSP: Process Zipper: No serialized zipper, processing string
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((Model, Action) -> Model)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((Model, Action) -> Model)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "add" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "toggle" | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:17.4781
 :16.3724
 fun:15.1736
  :13.4225
    :12.4937
                :12.2859
   :12.1469
 (:11.6577
 function:11.5135	rejected
      :11.1549
 #:10.9569	rejected
        :10.9271
     :10.677
fun:10.4572
            :10.4231
 switch:10.4071	rejected
         :10.3866
 match:10.3339	rejected
 \:10.2221	rejected
 action:10.2066	rejected
	:10.1913	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "RemoveTodo" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 (:17.1599
 model:16.3263
 m:15.8801
 ((:15.1968	rejected
 state:14.7536
(:13.0109
 s:12.7225
 todo:12.3703
 x:12.1888
 :12.1778
 current:12.013
 ({:11.8132	rejected

:11.7562
 _:11.6583
 init:11.6203
((:11.5462	rejected
 old:11.5066
 acc:11.3525
 args:11.3405
 data:11.2873
 {:11.255	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <m>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {m: (Model, Action), update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: m
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: m
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | "->"
root ::= completions | new-tokens

Top 20 Logits:
,:16.2622
dl:13.5269
 ->:11.968
1:11.3226
 ,:10.8421
@:10.6553	rejected
 a:10.3666	rejected
0:10.2539
x:10.2205
_:10.1552
_,:9.84075	prefix accepted:_
 s:9.6717	rejected
state:9.5298
 x:9.29953	rejected
w:9.11437
vs:8.92839
do:8.8069
 _,:8.69413	rejected
model:8.62435
::8.52545	rejected
old:8.38681

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m,

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: ((String, [(String, Bool)]), (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: ((String, [(String, Bool)]), (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "RemoveTodo" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 a:17.5504
 action:16.5106
 act:14.0465
 x:13.5475
 msg:13.4755
a:13.102
 message:11.6811
action:11.2735
 _:11.2726
 e:11.1395
 v:11.0904
 c:11.0463
 o:11.0356
 cmd:10.8765
 s:10.6223
 :10.5324
 u:10.5238
 t:10.443
 n:10.3865
 todo:10.3323
 p:10.205

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <action>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: action
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: action
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | "->"
root ::= completions | new-tokens

Top 20 Logits:
 ->:18.5495
->:14.6274
 :14.3941
 =>:14.1243	rejected
_:12.298
::11.9234	rejected
 =:11.2834	rejected
':11.16	rejected
 ::11.1199	rejected

:11.1078
?:10.7521	rejected
 →:10.5142	rejected
,:10.22
0:10.1805
$:10.1376	rejected
 {:10.036	rejected
 ?:10.0066	rejected
 -:9.9569
  :9.95156
 -->:9.69373	rejected
=:9.59089	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Model, Action) -> Model)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "add" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:17.9108
 :17.1172
  :14.6046
   :13.688
 match:13.6079	rejected
    :13.5955
                :12.9169
      :12.9082
 case:12.8388
 ?:12.7755	rejected
        :12.6748
 {:12.5557	rejected
         :12.2708
 #:11.8597	rejected
     :11.7967
 m:11.5927
 switch:11.504	rejected
          :11.4953
       :11.4081
            :11.302
 begin:11.3002	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->


LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Model, Action) -> Model)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "add" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 :20.2837
   :17.6249
  :15.9447
match:15.3484	rejected
case:14.8986
switch:14.6628	rejected
 match:14.079	rejected

:13.7187
	:13.6726	rejected
 switch:13.6726	rejected
 case:13.6414
    :13.5292
     :12.7558
 let:12.5789
let:12.3499
       :12.036
      :11.8529
#:11.6638	rejected
if:11.5668
                :11.3468
        :11.0967

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
 

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
 
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Model, Action) -> Model)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "add" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 case:18.6089
 match:16.582	rejected
 let:16.1268
 switch:14.6966	rejected
 (:12.5735
 m:11.3139
 #:11.0879	rejected
 print:11.0411	rejected
 Model:10.6954
 if:10.5056
 model:10.3706	rejected
 (*:10.3075	rejected
 todo:10.1923	rejected
 {:10.1019	rejected
 var:10.0413	rejected
 un:10.0289	rejected
 ?:10.0142	rejected
 List:9.76259	rejected
 |:9.74626	rejected
 f:9.72785
 action:9.70905

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <case end<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "add" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 action:18.2585
 m:15.7724
 (:12.392
 :11.638
 model:11.5767	rejected
 todo:11.0885	rejected

:10.8534
(:10.6079
 Action:10.47	rejected
 s:10.464
_:10.4593	rejected
 add:10.2589
 f:10.2299
 Model:10.0573
 #:10.0168	rejected
 Tod:9.98693
 update:9.97976
 match:9.91826	rejected
action:9.84609
 show:9.84158	rejected
 [:9.75296

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <action>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: action
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Generating Completions for prefix: action
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:17.4852
 :15.7079
  :14.7848
 of:14.3997	rejected
    :13.9384
   :13.6368
      :13.5386
     :13.5032
,:13.2059
                :12.6068
 |:12.3821
 #:12.0279	rejected
         :12.0017
 in:11.8763	rejected
        :11.7653
 {:11.7406	rejected
::11.6136
          :11.425
             :11.3658
       :11.2803
            :11.221

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action


LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <action>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 :19.8726
   :18.4376
  :17.135

:15.6412
     :15.2228
    :15.1191
#:15.0697	rejected
|:14.8384
 |:14.2158
      :13.3046
	:13.2182	rejected
                :12.2817
        :12.2035
       :12.082
         :11.8662
          :11.4813
 #:11.2227	rejected
           :11.2156
(*:11.092	rejected
            :10.9399
##:10.7856	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
 

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
 
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <action>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:21.8061
 #:15.7176	rejected
 +:13.5322
 (*:12.8764	rejected
 ##:11.9355	rejected
 ||:11.76	rejected
 {:11.6757	rejected
 /*:11.6645	rejected
 //:11.5213	rejected
 ~:11.3983	rejected

:11.2231
 #{:11.0302	rejected
 *:10.9292
 #[:10.8369	rejected
 /:10.6965
 ?:10.6064	rejected
 <:10.5793
 \:10.5333
 match:10.4664	rejected
 |\:10.4077	rejected
 ,:10.4036

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  |

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  |
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "RemoveTodo" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 Add:19.4692
 Update:16.146
 Remove:13.9249
 T:13.4157
 _:12.8764
 Tod:11.7748	rejected
Add:11.6912
 :11.5774
 Action:11.5278	rejected
 (:11.443
 #:10.9888	rejected
  :10.7606
 @:10.6924	rejected
 Clear:10.1963	rejected
 ?:10.1471	rejected
 +:10.1464	rejected
 Init:10.1197	rejected
 ~:9.95527	rejected
 add:9.83428
 {:9.82947	rejected
   :9.72769

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | Add

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | Add
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Add>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "Add"))))
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  Add
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Add
LSP: Generating Completions for prefix: Add
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Todo"
root ::= completions

Top 20 Logits:
T:21.3773
 =>:12.5338	rejected
t:11.9186	rejected
 ->:11.8106	rejected
_:11.6664	rejected
To:11.6255
 todo:11.5106	rejected
(:11.3956	rejected
():11.0268	rejected
Action:10.8505	rejected
New:10.6809	rejected
   :10.6425	rejected
TO:10.4314	rejected
    :10.4266	rejected
 Tod:10.212	rejected
      :10.1026	rejected
Text:10.0747	rejected
     :9.93222	rejected
  :9.83434	rejected
         :9.63727	rejected
Item:9.59402	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddT

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddT
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <AddT>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "AddT"))))
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  AddT
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: AddT
LSP: Generating Completions for prefix: AddT
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "odo"
root ::= completions

Top 20 Logits:
odo:25.1943
odos:14.8171	rejected
od:14.0371
oto:13.3451	rejected
ogo:10.9109	rejected
d:10.7857	rejected
odd:10.4503	rejected
udo:10.3504	rejected
do:10.1684	rejected
oda:9.9634	rejected
og:9.29857	rejected
 todo:9.03974	rejected
of:8.93005	rejected
oco:8.9261	rejected
dd:8.69927	rejected
odio:8.60628	rejected
odon:8.56499	rejected
ody:8.36785	rejected
omo:8.34474	rejected
oko:8.27206	rejected
os:8.0928	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <AddTodo>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: AddTodo
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: AddTodo
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:18.2125
 ->:13.7056	rejected
      :13.5952
     :13.5441
         :13.3954
    :13.2176
   :13.0046
        :12.9611
          :12.7358
       :12.4045
  :12.2814
           :12.1393
             :12.1056
                :12.0985
            :11.862
 :11.4494
 _:11.3611	rejected
 when:11.1968	rejected
():11.1116	rejected
(_:11.0547	rejected
(:10.9972

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo =>

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo =>
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "add" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 (:15.1388

:14.661
 {:14.661	rejected
 let:13.9024
 add:13.8043
 :13.531
 Model:13.3276
 ({:12.9815	rejected
 m:12.8591
 f:12.7829
  :12.1069
 ?:11.481	rejected
                :11.4214
 fun:11.3908
    :11.0843
 List:11.0654	rejected
 (\:10.941	rejected
     :10.9053
   :10.8922
 s:10.884
      :10.8662

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(String, Bool)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(String, Bool)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "add" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
m:14.2866
f:13.1895
(":13.1886	rejected
 "",:13.0749	rejected
Model:12.5898
?,:12.1427	rejected
List:12.1224	rejected

:11.89
s:11.6039
model:11.4942	rejected
action:11.4051
String:11.2321	rejected
_,:11.229	rejected
add:11.0828
[":10.7545	rejected
update:10.352
T:9.97404
(),:9.83781	rejected
let:9.82626
if:9.74443
fun:9.56694

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <m>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(String, Bool)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: m
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: m
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ax_int" | "in_int" | "od"
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= completions | new-tokens

Top 20 Logits:
.:13.8989	rejected
 $:12.0626
[:11.8288	rejected
,:10.9693
 |:10.368	rejected
 f:10.2806	rejected
$:10.256
 @:10.1911
@:10.1679
(:9.77816
 with:9.61152	rejected
 +:9.47129
 #:9.45946	rejected
.$:9.37823	rejected
 =:9.31774
.(:9.14924	rejected
::9.06371
 \:9.01595
1:8.96694	rejected
 ^:8.89912	rejected
 ::8.82659
Rejected the highest logit candidate . with logit -inf

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model"); syn = (List (Unknown Internal))})))
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ ?
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model"); syn = (List (Unknown Internal))})))
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ ?
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ ?
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "add" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
>:12.3058	rejected
 [:12.2026
@:11.9104	rejected
s:10.9027
 (":10.8873	rejected
 Model:10.8008
 [":10.6504	rejected
 (:10.3716
 add:10.2952
.:9.9166	rejected
 ([:9.75571	rejected
 s:9.53887
 [(:9.33019	rejected
->:9.30311	rejected
 [],:9.00438	rejected
 m:8.97832
 ":8.90605
+:8.82365	rejected
[:8.7364
 :8.60367
<:8.44191	rejected
Rejected the highest logit candidate > with logit -inf

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Model>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "Model"))))
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Model
LSP: Generating Completions for prefix: Model
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ".eq" | ".init"
root ::= completions

Top 20 Logits:
.:17.7245
(":14.438	rejected
(:14.0196	rejected
{:11.581	rejected
([:11.4531	rejected
.(:11.1591	prefix accepted:.
 init:10.9563	rejected
):10.8748	rejected
 (":10.8052	rejected
_:10.6627	rejected
()):10.635	rejected
[:10.3308	rejected
!:10.1723	rejected
 {:10.1516	rejected
.[:10.0261	prefix accepted:.
({:9.96681	rejected
@:9.8977	rejected
(!:9.87575	rejected
(),:9.8469	rejected
._:9.84028	rejected
.@:9.82646	prefix accepted:.

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Model.>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Invalid expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (BadToken "Model."))))
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.
Nature of error: "Model." isn't a valid token
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Bad token; only completion
  LSP: Syntax: Must complete: Model.
LSP: Generating Completions for prefix: Model.
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "eq" | "init"
root ::= completions

Top 20 Logits:
init:19.1518
(":13.7226	rejected
add:13.607	rejected
update:13.4465	rejected
empty:12.9175	rejected
model:12.0246	rejected
Init:11.5356	rejected
eq:11.1271
({:11.0158	rejected
[":10.8236	rejected
t:10.7059	rejected
([:10.669	rejected
set:10.6085	rejected
Update:10.313	rejected
new:10.1984	rejected
{:10.1783	rejected
0:10.1298	rejected
Add:10.1291	rejected
insert:10.1057	rejected
id:9.97921	rejected
f:9.86441	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Model.init>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: (String, [(String, Bool)])
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (List (Unknown Internal)); syn = (Var "Model")})))
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: Model.init
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Model.init
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
):14.2379
,:14.065
).:12.6405	rejected
 |:11.7753	rejected
()):11.6379	rejected
(),:11.5638	rejected
():10.9171	rejected
 @:10.7831
(:10.7481
 $:10.5108
 ,:10.2772
),:10.1659	rejected
;:10.1168	rejected
 ):9.9611
 +:9.88481
 with:9.84173	rejected
)(:9.7398	rejected
.:9.57088	rejected
)::9.52922	rejected
 ||:9.45119	rejected
)[:9.19417	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(String, Bool)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:15.7913
 @:13.6438
 :12.9346
 {:12.6442	rejected
  :12.3924
 |:12.3256
 $:12.2898
                :12.0112
 in:11.7934	rejected
 #:11.7901	rejected
 with:11.6626	rejected
@:11.6553
 //:11.6398	rejected
    :11.6152
     :11.3001
      :11.2959
   :11.2783
 where:11.2211	rejected
 %:10.9913	rejected
 f:10.9767	rejected
 +:10.8014

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)


LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(String, Bool)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 :19.8678
   :15.5151
  :15.4676

:15.1231
                :15.0877
     :14.2898
#:14.0856	rejected
    :13.7504
end:13.2729
      :13.1703
             :13.0105
              :13.0099
               :12.9743
	:12.8677	rejected
            :12.7339
        :12.7042
|:12.3949
(*:12.3358	rejected
          :12.249
       :12.1684
           :12.033

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
 

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
 
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(String, Bool)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:20.3563
 #:15.3312	rejected
 end:14.1528
 (*:13.6634	rejected
 //:12.8651	rejected
 <:12.5617
 ~:12.2363	rejected
 ...:12.1019	rejected
 {:11.9833	rejected
 ?:11.8628	rejected
 /*:11.8247	rejected
 \:11.7367
 +:11.6431
 else:11.5274	rejected
 (\:11.5108	rejected
 ##:11.4228	rejected
 _:11.3595	rejected
 $:11.3274
 /:11.2254
 case:11.1112	rejected
 ||:11.0605	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  |

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  |
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "RemoveTodo" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 Remove:19.3396
 Update:17.5642
 T:16.0286
 _:13.9118
 (:12.4876
 Rem:12.4741
 Add:10.8211
 Delete:10.5147	rejected
 remove:10.5068
 :10.1876
 (_:10.0333	rejected
Remove:9.94499
 {:9.84121	rejected
 ~:9.69881	rejected
 ?:9.60563	rejected
 #:9.60403	rejected
 Action:9.44483	rejected
 Clear:9.41851	rejected
 Tod:9.33528	rejected
 @:9.07981	rejected
 t:9.07207

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | Remove

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | Remove
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Remove>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "Remove"))))
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Remove
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Remove
LSP: Generating Completions for prefix: Remove
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Todo"
root ::= completions

Top 20 Logits:
T:20.3618
(:13.7375	rejected
 todo:12.4023	rejected
To:11.3375
TO:11.3231	rejected
 Tod:11.0777	rejected
_:10.59	rejected
Action:10.2287	rejected
Item:10.0631	rejected
 (:9.57495	rejected
 i:9.22277	rejected
 index:9.11416	rejected
Token:9.06308	rejected
Index:8.94387	rejected
 x:8.86	rejected
(_:8.85018	rejected
((:8.78054	rejected
 t:8.58631	rejected
 _:8.58119	rejected
All:8.45686	rejected
 :8.39485	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveT

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveT
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <RemoveT>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "RemoveT"))))
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  RemoveT
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: RemoveT
LSP: Generating Completions for prefix: RemoveT
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "odo"
root ::= completions

Top 20 Logits:
odo:26.5458
oto:17.8248	rejected
odos:17.7895	rejected
udo:16.5959	rejected
od:15.4572
oda:15.3221	rejected
odox:15.3114	rejected
odon:15.1015	rejected
ode:14.8041	rejected
do:14.4004	rejected
ody:14.3511	rejected
ogo:14.2235	rejected
oco:14.0636	rejected
oso:13.5166	rejected
ono:13.4892	rejected
ado:13.1316	rejected
olo:13.1124	rejected
oko:13.0933	rejected
edo:12.9883	rejected
ovo:12.7716	rejected
oid:12.5678	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <RemoveTodo>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (Int -> (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)))
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Var "Action");
           syn = (Arrow (Int, (Var "Action")))})))
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  RemoveTodo
Nature of error: Expecting type Action but got inconsistent type (Int -> Action)
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: RemoveTodo
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: RemoveTodo
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
(:18.5851
 index:16.4727	rejected
 i:15.4262	rejected
 idx:14.5684	rejected
 n:13.9872	rejected
 id:12.7786	rejected
 x:12.3602	rejected
 (:12.3324
 todo:11.9238	rejected
(_:11.4591	rejected
 k:11.3493	rejected
 at:10.9588	rejected
 a:10.5265	rejected
 key:10.4153	rejected
 p:10.3759	rejected
 pos:10.3512	rejected
 t:10.3418	rejected
 remove:10.1442	rejected
 _:10.1357	rejected
 :10.131
 action:9.96956	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "RemoveTodo" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= completions | new-tokens

Top 20 Logits:
index:19.1043
i:17.7143
idx:17.3082
n:15.4369
id:14.8832
x:14.4488
t:13.7972
ix:12.9715
k:12.3798
key:12.2987
pos:11.9689
a:11.6371
0:11.5713
ind:11.3482
action:11.2523
int:11.24
at:11.1791
 index:11.1671
j:11.0118
position:10.9307
v:10.868

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <index>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: index
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: index
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
):19.3622
)=:14.0155	rejected
),:13.3278	rejected
 as:12.9637	rejected
,:12.873
)->:12.7574	rejected
)::12.589	rejected
::12.5665	rejected
 ):12.3007
_:11.8381
_):11.6494	prefix accepted:_
'):11.4783	rejected
1:11.3971
 ::10.8292	rejected
=:10.7649	rejected
To:10.5422
 =>:10.3021	rejected
 =:10.2584	rejected
)):10.1569	rejected
0:10.1048
)|:9.85068	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index)

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:19.0604
  :13.8737
 :13.371
   :13.2273
 ->:12.9894	rejected
    :12.5254
     :11.9643
 when:11.9536	rejected
      :11.6707

:11.5928
 m:10.9412	rejected
        :10.7189
=>:10.5873
 =:10.5782
         :10.4567
 :=:10.3516	rejected
       :10.1681
 :::9.89812	rejected
          :9.81145
 ::9.54914	rejected
 _:9.48623	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) =>

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) =>
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "add" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "index" | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 (:15.9679
 (":14.4229	rejected

:13.8168
 {:13.4058	rejected
 m:13.1682
 :13.0982
 Model:13.0436
 let:12.9874
 remove:12.8806
 add:12.7525
 ({:12.6525	rejected
 ((:12.4262	rejected
 List:12.3401	rejected
 f:12.1459
 ?:11.9856	rejected
 (!:11.1086	rejected
 update:11.0921
 todo:10.9851	rejected
 Tod:10.8111
 (_:10.7896	rejected
 ([:10.7543	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(String, Bool)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(String, Bool)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "add" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "index" | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
m:14.9021
f:13.6963
List:12.6865	rejected
add:12.4507
Model:12.3731
(":12.219	rejected
?,:11.6797	rejected
model:11.47	rejected
String:11.3068	rejected
update:10.8749
remove:10.6083
s:10.3927
(),:10.3637	rejected

:10.3503
 "",:9.7908	rejected
_,:9.72534	rejected
?":9.59466	rejected
action:9.34886
null:9.15577	rejected
let:9.07208
 ?:8.82475	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <m>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(String, Bool)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: m
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: m
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ax_int" | "in_int" | "od"
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= completions | new-tokens

Top 20 Logits:
 @:13.8746
[:12.4583	rejected
.:12.0527	rejected
@:11.1113
 -:10.367
 $:10.2041
 &:10.0311
 |:9.88484	rejected
,:9.74146
 %:9.4072	rejected
 +:9.13997
(:9.10619
 with:8.9956	rejected
._:8.98756	rejected
 \:8.86226
 ^:8.73784	rejected
 ?:8.73552	rejected
.(:8.52106	rejected
.$:8.4451	rejected
 $$:8.37412	rejected
 f:8.32358	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model"); syn = (List (Unknown Internal))})))
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ ?
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model"); syn = (List (Unknown Internal))})))
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ ?
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ ?
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "add" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "index" | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 Model:14.4412
 (":13.5318	rejected
 (:13.5004
 remove:12.7318
 add:12.1199
 [:11.7663
 ([:11.4142	rejected
 f:10.9861
 m:10.7593
 Update:10.7438
 s:10.4193
 {:10.3781	rejected
 [":10.2712	rejected
 update:10.2394
 Remove:10.1721
 ":9.98096
 ((:9.97868	rejected
 List:9.57123	rejected
 ?:9.33363	rejected
 :9.28108
@:9.2776	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (?)
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (?)
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (?)
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: [?]
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "add" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "index" | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
m:13.9966
Model:13.6594
s:13.4199
f:13.3783
add:12.4162
_,:12.2184	rejected
List:12.0502	rejected
?,:11.8544	rejected
(":11.6469	rejected
String:11.2833	rejected
model:10.6177	rejected
0:10.4686
(),:10.4358	rejected
update:10.1472
fun:10.041
[":9.7885	rejected
 "",:9.65066	rejected
remove:9.62007
false:9.5769
second:9.55067	rejected
~:9.48623	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Model>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "Model"))))
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model)
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: [?]
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Model
LSP: Generating Completions for prefix: Model
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ".eq" | ".init"
root ::= completions

Top 20 Logits:
.:18.4377
._:12.5484	rejected
.@:12.1445	prefix accepted:.
(:11.9583	rejected
(":11.9325	rejected
@:11.8484	rejected
_:11.7962	rejected
.__:11.2246	rejected
.(:11.1925	prefix accepted:.
 init:11.097	rejected
,:10.9431	rejected
 @:10.9134	rejected
$:10.3199	rejected
:::10.3032	rejected
.$:10.0384	prefix accepted:.
[:9.96661	rejected
':9.74059	rejected
.":9.5939	prefix accepted:.
 f:9.48227	rejected
::9.47271	rejected
():9.40915	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Model.>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Invalid expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (BadToken "Model."))))
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.)
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.
Nature of error: "Model." isn't a valid token  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model
  LSP: Info: BidiCtx: Cls: Invalid expression
  LSP: Info: BidiCtx: Expected type: [?]
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Bad token; only completion
  LSP: Syntax: Must complete: Model.
LSP: Generating Completions for prefix: Model.
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "eq" | "init"
root ::= completions

Top 20 Logits:
init:17.7272
f:13.4947	rejected
model:13.3465	rejected
update:13.0255	rejected
empty:12.6956	rejected
s:12.3327	rejected
eq:11.8405
t:11.2272	rejected
get:11.1888	rejected
add:11.1274	rejected
length:11.0415	rejected
map:10.7054	rejected
buffer:10.648	rejected
Init:10.6031	rejected
un:10.4223	rejected
mk:10.367	rejected
input:10.3049	rejected
(":10.2986	rejected
id:10.1506	rejected
set:10.0131	rejected
remove:9.92084	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Model.init>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: (String, [(String, Bool)])
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (List (Unknown Internal)); syn = (Var "Model")})))
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init)
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: [?]
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: Model.init
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Model.init
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:15.1017
 @:13.7363
)):11.2898	rejected
.:10.9148	rejected
@:10.6601
 |:10.5579	rejected
 with:10.4979	rejected
 ,:10.409
 +:10.357
 \:10.2854
 $:10.2736
(:10.2032
[:9.98293	rejected
(),:9.8588	rejected
 -:9.77996
 &:9.757
():9.4182	rejected
;:9.27736	rejected
 *:9.22694
 <:9.21009
(@:9.06071	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init,

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ((String, [(String, Bool)]), ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (List (Unknown Internal));
           syn = (Prod [(Var "Model"); (Unknown Internal)])})))
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, ?)
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, ?
Nature of error: Expecting type [?] but got inconsistent type (Model, ?)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: [?]
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ((String, [(String, Bool)]), ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (List (Unknown Internal));
           syn = (Prod [(Var "Model"); (Unknown Internal)])})))
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, ?)
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, ?
Nature of error: Expecting type [?] but got inconsistent type (Model, ?)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: [?]
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, ?)
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, ?
Nature of error: Expecting type [?] but got inconsistent type (Model, ?)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: [?]
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "add" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "index" | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 remove:16.9937
 index:12.6297
 [:12.5051
 List:12.4893	rejected
 m:11.9487
 (:11.6077
 Remove:11.2424
 Model:10.9419
 Tod:10.8068
 s:10.6547
remove:10.5562
 toggle:10.5266
 f:10.3537
 add:10.3408
 :10.2855
 _:10.1507	rejected
 todo:10.0329	rejected
 ":9.95201
 fun:9.77714

:9.76776
 {:9.58677	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <remove>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ((Int, [(String, Bool)]) -> [(String, Bool)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, remove)
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove
Nature of error: Expecting type [?] but got inconsistent type (Model, ((Int, [Todo]) -> [Todo]))  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: [?]
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: remove
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: remove
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
(:17.7448
)):15.9771	rejected
((:13.6611	rejected
 (:13.1584
 index:12.8557	rejected
,:12.4253
(@:11.7387	rejected
):11.5375
([:11.4182	rejected
)(:11.1143	rejected
($:10.8029	rejected
::10.7584
(?:10.6965	rejected
_:10.5509	rejected
(_:10.471	rejected
:(:10.3293	rejected
())):10.2527	rejected
 m:10.2406	rejected
_(:10.1379	rejected
(...:10.1355	rejected
),:10.0317	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [(String, Bool)]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, remove(?))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(?)
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: [?]
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [(String, Bool)]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, remove(?))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(?)
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: [?]
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, [Todo])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, remove(?))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(?)
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "add" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "index" | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
index:18.9657
m:13.6359
action:13.4516
i:13.178
List:12.3738	rejected
 index:12.2813
Model:12.1038
model:12.0369	rejected
int:11.9091
t:11.6295
~:11.113	rejected
s:10.8093
x:10.7212	rejected
f:10.6387
0:10.4753
_,:10.4741	rejected
Tu:10.4583	rejected
T:10.458
tod:10.4105	rejected
n:10.2488
a:10.1955

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <index>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, [Todo])
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Prod [Int; (List (Var "Todo"))]); syn = Int})))
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, remove(index))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index)
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  index
Nature of error: Expecting type (Int, [Todo]) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: index
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: index
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:16.7483
))):15.0552	rejected
 -:11.6163
)):11.3871	rejected
 ,:11.0227
),:10.4605	rejected
 +:10.2247
,(:10.1444	rejected
-:10.1122
 m:9.90231	rejected
):9.72626
 @:9.47405
)),:9.4553	rejected
(:9.30446
 *:9.21181
 (:9.10321
,$:9.09334	rejected
)(:8.70893	rejected
,.:8.57161	rejected
 &:8.39344
@:8.36724

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index,

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, [Todo])
  LSP: Info: Seft type: (Int, [(String, Bool)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, remove(index, ?))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, ?)
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, [Todo])
  LSP: Info: Seft type: (Int, [(String, Bool)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, remove(index, ?))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, ?)
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, remove(index, ?))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, ?)
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "add" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "index" | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 s:15.2869
 m:14.0553
 Model:12.4174
 f:12.095
 ?:11.8109	rejected
 List:11.6167	rejected
 (:11.309
 _:11.1979	rejected
 add:10.8519
 t:10.8278
 todo:10.5563	rejected
 Tod:10.1377
 model:10.0909	rejected
 :9.86026
 [:9.73459
 !:9.70751
 get:9.64789	rejected
 .:9.55686	rejected
 @:9.41759	rejected
 todos:9.21316	rejected
s:9.20204

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, s

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, s
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <s>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "s"))
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  s
Nature of error: Variable s is not bound  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, remove(index, s))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, s)
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: s
LSP: Generating Completions for prefix: s
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "in" | "qrt" | "tring_compare" | "tring_concat" | "tring_contains" | "tring_length" | "tring_of_bool" | "tring_of_float" | "tring_of_int" | "tring_sub" | "tring_trim"
root ::= completions

Top 20 Logits:
nd:18.0894	rejected
))):11.8109	rejected
2:11.5821	rejected
1:10.5617	rejected
)):9.14543	rejected
.:8.9602	rejected
^:8.48115	rejected
)),:8.35094	rejected
ns:8.25221	rejected
_:8.22246	rejected
)));:8.10454	rejected
dl:7.85545	rejected
):7.64134	rejected
(:7.63929	rejected
3:7.54526	rejected
ND:7.41771	rejected
#:7.198	rejected
ond:7.19719	rejected
[:7.15283	rejected
@:7.09641	rejected
dn:7.0169	rejected
Rejected the highest logit candidate nd with logit -inf

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, st

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, st
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <st>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "st"))
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, remove(index, st))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  st
Nature of error: Variable st is not bound  
Error in term:
  Model.init, remove(index, st)
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: st
LSP: Generating Completions for prefix: st
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ring_compare" | "ring_concat" | "ring_contains" | "ring_length" | "ring_of_bool" | "ring_of_float" | "ring_of_int" | "ring_sub" | "ring_trim"
root ::= completions

Top 20 Logits:
nd:12.5418	rejected
))):12.5263	rejected
.:11.7765	rejected
odo:10.6575	rejected
ate:10.2818	rejected
_:10.2025	rejected
os:10.1712	rejected
:::9.793	rejected
(:9.72301	rejected
 m:9.19342	rejected
)):8.64513	rejected
@:8.54864	rejected
 @:8.49123	rejected
):8.43127	rejected
 ^:8.10705	rejected
1:7.95885	rejected
^:7.95804	rejected
2:7.8269	rejected
 $:7.75338	rejected
do:7.72034	rejected
():7.69434	rejected
Rejected the highest logit candidate nd with logit -inf

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <string>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "string"))
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, remove(index, string))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string)
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string
Nature of error: Variable string is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: string
LSP: Generating Completions for prefix: string
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_compare" | "_concat" | "_contains" | "_length" | "_of_bool" | "_of_float" | "_of_int" | "_sub" | "_trim"
root ::= completions

Top 20 Logits:
))):12.4163	rejected
_:11.5198
,:9.68519	rejected
(:9.0353	rejected
)):9.00619	rejected
.:8.99618	rejected
tod:8.69737	rejected
List:8.49011	rejected
of:8.46798	rejected
),:8.44467	rejected
):8.36511	rejected
Of:8.12723	rejected
2:8.09824	rejected
-:8.04368	rejected
Buffer:7.90307	rejected
 $:7.84641	rejected
 of:7.83367	rejected
 m:7.79433	rejected
To:7.46102	rejected
 @:7.39471	rejected
 s:7.37215	rejected
Rejected the highest logit candidate ))) with logit -inf

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <string_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "string_"))
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, remove(index, string_))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_)
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  string_
Nature of error: Variable string_ is not bound  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: string_
LSP: Generating Completions for prefix: string_
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "compare" | "concat" | "contains" | "length" | "of_bool" | "of_float" | "of_int" | "sub" | "trim"
root ::= completions

Top 20 Logits:
of:14.7101
to:13.4105	rejected
list:12.5367	rejected
length:12.0686
eq:12.0194	rejected
tod:11.6074	rejected
buffer:11.5553	rejected
append:11.545	rejected
split:11.5425	rejected
t:11.2319
model:11.2138	rejected
equal:10.8338	rejected
input:10.7053	rejected
concat:10.7035
s:10.1784
map:10.156	rejected
buf:9.96326	rejected
value:9.93991	rejected
len:9.86818
slice:9.63669	rejected
view:9.62856	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <string_of>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "string_of"))
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, remove(index, string_of))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  string_of
Nature of error: Variable string_of is not bound  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of)
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: string_of
LSP: Generating Completions for prefix: string_of
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_bool" | "_float" | "_int"
root ::= completions

Top 20 Logits:
_:15.2635
(:10.8311	rejected
))):10.4341	rejected
():9.34617	rejected
int:9.10145	rejected
 int:8.97825	rejected
(":8.94182	rejected
 m:8.82517	rejected
,:8.63002	rejected
):8.5173	rejected
Int:8.15094	rejected
)):8.0912	rejected
(_:7.91951	rejected
($:7.73386	rejected
-:7.67818	rejected
 ":7.58845	rejected
((:7.56677	rejected
(@:7.53868	rejected
":7.53248	rejected
$:7.48691	rejected
<:7.40246	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <string_of_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "string_of_"))
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, remove(index, string_of_))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_)
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  string_of_
Nature of error: Variable string_of_ is not bound  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: string_of_
LSP: Generating Completions for prefix: string_of_
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "bool" | "float" | "int"
root ::= completions

Top 20 Logits:
int:16.809
char:12.9097	rejected
float:12.5408
action:11.8906	rejected
bool:11.6811
Int:10.9198	rejected
t:10.8235	rejected
model:10.637	rejected
index:10.579	rejected
list:10.497	rejected
html:10.3967	rejected
json:10.1643	rejected
i:10.1202
var:10.0357	rejected
value:10.0184	rejected
num:9.84164	rejected
msg:9.82582	rejected
integer:9.81137	rejected
ints:9.66862	rejected
number:9.59469	rejected
string:9.56978	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <string_of_int>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: (Int -> String)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (List (Var "Todo")); syn = (Arrow (Int, String))})))
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, remove(index, string_of_int))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  string_of_int
Nature of error: Expecting type [Todo] but got inconsistent type (Int -> String)  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int)
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: string_of_int
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: string_of_int
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
(:13.7789
))):12.6563	rejected
 index:11.728	rejected
($:9.82144	rejected
():9.80624	rejected
,:9.5848
(":9.54351	rejected
(_:9.50797	rejected
)):9.16965	rejected
(@:8.84192	rejected
 i:8.83812	rejected
(__:8.81934	rejected
):8.76273
((:8.70311	rejected
 m:8.43869	rejected
 :8.38337
 (:8.14828
),:7.97152	rejected
 x:7.66061	rejected

:7.64495
(.:7.57354	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: String
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = (List (Var "Todo")); syn = String})))
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(?)
Nature of error: Expecting type [Todo] but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(?)))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(?))
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: String
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = (List (Var "Todo")); syn = String})))
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(?)
Nature of error: Expecting type [Todo] but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(?)))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(?))
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(?)
Nature of error: Expecting type [Todo] but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(?)))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(?))
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "add" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "index" | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
index:13.6276
i:11.363
m:10.9016
s:10.5994
List:10.5418	rejected
Model:10.5244
1:10.4084
action:10.1462
n:9.81199
x:9.75023	rejected
len:9.59519	rejected
idx:9.52653	rejected
model:9.47533	rejected
0:9.47426
tod:9.41064	rejected
int:9.35149
2:9.23484
length:9.1015	rejected
t:9.06375
3:8.91847
a:8.90995

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <index>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type [Todo] but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index)))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index))
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: index
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: index
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
)))):15.6548	rejected
)):12.8434	rejected
),:12.3027	rejected
):11.6606
))):11.5241	rejected
)),:10.9291	rejected
 +:9.60654
));:9.10602	rejected
)+:8.80899	rejected
,:8.49049
))::8.34825	rejected
)));:8.3118	rejected
);:8.17083	rejected
+:8.14764
).:8.06067	rejected
 :7.66187
1:7.65691	rejected
)).:7.4382	rejected
)::7.33173	rejected
 -:7.31173
)(:7.25292	rejected
Rejected the highest logit candidate )))) with logit -inf

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: String
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = (List (Var "Todo")); syn = String})))
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type [Todo] but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index)))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index))
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
 +:12.0086
:::11.5224
 :::11.3699
 :10.8565
 $:10.7834

:10.6467
 in:10.5191	rejected
 @:10.5148
 ):10.2566
 ++:9.89185
 m:9.47447	rejected
 ^:9.45717	rejected
  :9.17704
 ,:9.07618
 *:8.74421
 ::8.7329
@:8.66857
s:8.61682	rejected
))):8.58873	rejected
 ":8.41655	rejected
 |:8.38065	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >::<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Cons
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: ?))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: ?)
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Cons
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: ?))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: ?)
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: ?))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: ?)
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ::
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ::
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "add" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "index" | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
[]:11.654
s:11.3538
tod:10.9128	rejected
m:10.7358
Model:10.591
[:10.4357
xs:10.3726	rejected
List:10.0119	rejected
":9.90379
ts:9.47546	rejected
f:9.23083
))):9.04164	rejected
 m:8.9955
(:8.85126
[]):8.83346	rejected
model:8.8098	rejected
[":8.75291	rejected
acc:8.35707	rejected
td:8.26625	rejected
 Model:8.24793
)):8.05914	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::s

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::s
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <s>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "s"))
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: s))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: s)
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  s
Nature of error: Variable s is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: s
LSP: Generating Completions for prefix: s
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "in" | "qrt" | "tring_compare" | "tring_concat" | "tring_contains" | "tring_length" | "tring_of_bool" | "tring_of_float" | "tring_of_int" | "tring_sub" | "tring_trim"
root ::= completions

Top 20 Logits:
nd:14.9951	rejected
))):12.632	rejected
)):9.83876	rejected
list:9.4156	rejected
.:9.19739	rejected
st:9.14399	rejected
2:8.86206	rejected
1:8.83051	rejected
):8.36148	rejected
string:8.21418	rejected
":8.00383	rejected
[:7.79686	rejected
model:7.77982	rejected
)),:7.73887	rejected
(:7.55379	rejected
,:7.53543	rejected
),:7.52979	rejected
printf:7.37804	rejected
_:7.37576	rejected
:::7.23359	rejected
)));:7.19891	rejected
Rejected the highest logit candidate nd with logit -inf

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::str

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::str
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <str>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "str"))
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: str))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: str)
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  str
Nature of error: Variable str is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: str
LSP: Generating Completions for prefix: str
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ing_compare" | "ing_concat" | "ing_contains" | "ing_length" | "ing_of_bool" | "ing_of_float" | "ing_of_int" | "ing_sub" | "ing_trim"
root ::= completions

Top 20 Logits:
))):12.5868	rejected
in:11.5271
ng:10.0766	rejected
ig:9.89123	rejected
ign:9.88798	rejected
)):9.75215	rejected
ings:9.73	rejected
ung:8.99399	rejected
(:8.8894	rejected
2:8.67614	rejected
int:8.61845	rejected
ins:8.22082	rejected
len:8.17624	rejected
:::8.13122	rejected
):8.12137	rejected
n:8.06034	rejected
igs:7.99609	rejected
1:7.98517	rejected
():7.84536	rejected
tod:7.84476	rejected
g:7.83384	rejected
Rejected the highest logit candidate ))) with logit -inf

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::strin

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::strin
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <strin>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "strin"))
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: strin))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: strin)
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  strin
Nature of error: Variable strin is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: strin
LSP: Generating Completions for prefix: strin
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "g_compare" | "g_concat" | "g_contains" | "g_length" | "g_of_bool" | "g_of_float" | "g_of_int" | "g_sub" | "g_trim"
root ::= completions

Top 20 Logits:
))):11.8463	rejected
)):10.8133	rejected
ng:9.14766	rejected
):8.95137	rejected

:8.86453	rejected
m:8.64513	rejected
h:8.57334	rejected
ig:8.27974	rejected
$:8.27142	rejected
[:8.18562	rejected
#:8.16133	rejected
 g:7.98767	rejected
(:7.97135	rejected
 :7.49757	rejected
():7.32044	rejected
 m:7.25288	rejected
),:7.24799	rejected
bg:7.18141	rejected
":7.11903	rejected
@:7.0758	rejected
b:6.96789	rejected
Rejected the highest logit candidate ))) with logit -inf

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <string>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "string"))
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  string
Nature of error: Variable string is not bound  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string)
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: string
LSP: Generating Completions for prefix: string
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_compare" | "_concat" | "_contains" | "_length" | "_of_bool" | "_of_float" | "_of_int" | "_sub" | "_trim"
root ::= completions

Top 20 Logits:
))):12.8516	rejected
_:12.8377
)):10.5192	rejected
):9.28191	rejected
():9.24593	rejected
.:9.24391	rejected
:::9.1949	rejected
(":9.19225	rejected
__:8.67511	rejected
(:8.54532	rejected
 ":8.40114	rejected
 of:8.18741	rejected
Of:8.17069	rejected
f:8.07303	rejected
":8.02584	rejected

:7.91859	rejected
List:7.81499	rejected
[]:7.74818	rejected
[:7.71489	rejected
of:7.71104	rejected
list:7.6611	rejected
Rejected the highest logit candidate ))) with logit -inf

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <string_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "string_"))
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_)
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  string_
Nature of error: Variable string_ is not bound  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: string_
LSP: Generating Completions for prefix: string_
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "compare" | "concat" | "contains" | "length" | "of_bool" | "of_float" | "of_int" | "sub" | "trim"
root ::= completions

Top 20 Logits:
of:15.6876
to:12.1293	rejected
list:10.4527	rejected
o:10.2111
)):9.44361	rejected
concat:9.09292
))):8.97293	rejected
f:8.89164	rejected
if:8.84265	rejected
array:8.6046	rejected
 of:8.57195	rejected
eq:8.43492	rejected
print:8.42414	rejected
add:8.39252	rejected
off:8.35292	rejected
length:8.33573
type:8.33276	rejected
string:8.16023	rejected
s:8.15287

:8.15144	rejected
empty:8.08204	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <string_of>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "string_of"))
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of)
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of
Nature of error: Variable string_of is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: string_of
LSP: Generating Completions for prefix: string_of
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_bool" | "_float" | "_int"
root ::= completions

Top 20 Logits:
_:14.7555
(":10.8354	rejected
(:10.6326	rejected
__:10.4001	rejected
":10.014	rejected
))):9.95251	rejected
g:9.83708	rejected
)):9.67467	rejected
_":9.42849	prefix accepted:_
):9.42763	rejected
f:9.3151	rejected
():9.00433	rejected
 ":8.66378	rejected
@:8.58651	rejected
_(:8.57751	prefix accepted:_
()):8.52635	rejected

:8.51137	rejected
)":8.49922	rejected
#:8.46705	rejected
(_:8.45978	rejected
(!:8.44075	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <string_of_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "string_of_"))
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  string_of_
Nature of error: Variable string_of_ is not bound  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_)
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: string_of_
LSP: Generating Completions for prefix: string_of_
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "bool" | "float" | "int"
root ::= completions

Top 20 Logits:
int:15.1545
bool:12.7528
float:11.5603
char:10.4505	rejected
ints:10.3622	rejected
string:9.95954	rejected
in:9.89714
i:9.80281
list:9.57948	rejected
Int:8.94198	rejected
Bool:8.6067	rejected
 int:8.51618	rejected
model:8.50419	rejected
t:8.41974	rejected
it:8.37297	rejected
action:8.27622	rejected
unit:8.2205	rejected
inter:8.17794	rejected
n:8.16381	rejected
f:8.15189
num:8.08509	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <string_of_int>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: (Int -> String)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (List (Var "Todo")); syn = (Arrow (Int, String))})))
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  string_of_int
Nature of error: Expecting type [Todo] but got inconsistent type (Int -> String)  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int)
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: string_of_int
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: string_of_int
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
(:14.1179
))):12.1687	rejected
(":12.0745	rejected
():11.0877	rejected
((:10.913	rejected
(-:10.4831	rejected
(!:10.0322	rejected
)):9.49746	rejected
(@:9.4007	rejected
(.:9.25885	rejected
(_:9.03735	rejected
(*:9.00033	rejected
($:8.79704	rejected
 index:8.76928	rejected
([:8.68539	rejected
 (:8.68354
())):8.62674	rejected
_:8.57083	rejected
2:8.53025	rejected
()):8.50269	rejected
(':8.46892	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: String
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = (List (Var "Todo")); syn = String})))
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(?)))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(?))
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(?)
Nature of error: Expecting type [Todo] but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: String
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = (List (Var "Todo")); syn = String})))
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(?)))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(?))
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(?)
Nature of error: Expecting type [Todo] but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(?)))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(?))
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(?)
Nature of error: Expecting type [Todo] but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "add" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "index" | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
index:13.98
1:11.9747
i:11.4782
2:11.4026
3:10.7707
0:10.7296
m:10.4453
action:10.4057
List:10.2391	rejected
4:10.1918
remove:10.1154
5:10.0795
s:10.0597
Model:9.96291
length:9.81143	rejected
model:9.68644	rejected
9:9.66018
int:9.48783
tod:9.44828	rejected
n:9.26284
ind:9.14791

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <index>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index)))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index))
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type [Todo] but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: index
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: index
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
)))):14.7649	rejected
 +:12.7324
+:12.6263
):12.3819
)):12.1604	rejected
))):11.3714	rejected
)+:10.93	rejected
 -:10.5319
-:10.4649
),:9.90863	rejected
2:9.85571	rejected
 *:9.82216
)),:9.77653	rejected
)*:9.49798	rejected
*:9.32537
)^:9.26618	rejected
).:9.06559	rejected
)));:8.83588	rejected
/:8.81046
1:8.73319	rejected
 /:8.6357
Rejected the highest logit candidate )))) with logit -inf

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index +

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index +
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >+<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Integer Addition
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + ?)))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + ?))
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + ?)
Nature of error: Expecting type [Todo] but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Integer Addition
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Integer Addition
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + ?)))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + ?))
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + ?)
Nature of error: Expecting type [Todo] but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Integer Addition
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + ?)))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + ?))
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + ?)
Nature of error: Expecting type [Todo] but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Integer Addition
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: +
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: +
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "+" | "."
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "add" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "index" | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
 :14.3721
1:13.2287
 index:11.1819
2:9.88761
 i:9.85306
 m:9.75635
 ":9.73284
 string:9.08253
 int:8.89289
 n:8.87061
 s:8.8542
 (:8.59872
 str:8.56555
 List:8.49975	rejected
 length:8.26649	rejected
3:8.07106
 to:8.03918
  :7.9746
 t:7.8281
5:7.80109
 l:7.73833

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >+<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + ?)))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + ?))
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + ?)
Nature of error: Expecting type [Todo] but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Integer Addition
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "add" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "index" | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
1:23.2367
2:19.2563
5:18.2033
3:17.9259
0:17.3154
4:17.2435
7:15.7965
9:15.7752
6:15.7615
8:15.4775

:13.2491
)):12.1199	rejected
 m:11.9125
 todo:11.7082	rejected
 TODO:11.5648	rejected
 ":11.4246
 #:11.225	rejected
 todos:10.9448	rejected
 to:10.5495
]):10.5053	rejected
nd:10.4543	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <1>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Integer literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1)))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1))
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type [Todo] but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Integer Addition
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: 1
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: 1
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-floatlit | extend-intlit
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= completions | new-tokens

Top 20 Logits:
)))):15.072	rejected
):13.8226
)):13.613	rejected
))):11.7608	rejected
),:10.9115	rejected
0:10.9101
)::10.8657	rejected
:::10.6415
)),:10.4611	rejected
))::9.98468	rejected
)));:9.77114	rejected
 ):9.71388
).:9.48439	rejected
)(:9.24713	rejected
 :::9.21012
2:9.02801
 :8.85264
)+:8.83394	rejected
)]:8.7901	rejected
));:8.78259	rejected
)":8.67603	rejected
Rejected the highest logit candidate )))) with logit -inf

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: String
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = (List (Var "Todo")); syn = String})))
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1)))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1))
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type [Todo] but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
:::14.9028
 :::12.0368
 ):10.2472
 :10.1734

:10.1676
@:10.072
 @:9.90853
 ::9.3054
 =:9.08578
[]:9.063	rejected
 m:9.05412	rejected
 in:8.96863	rejected
g:8.92821	rejected
 +:8.87864
 $:8.82853
s:8.49753	rejected
))):8.38699	rejected
 *:8.03973
m:8.02344	rejected
 ~:8.00635	rejected
  :7.97376

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >::<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Cons
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ?))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ?)
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Cons
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ?))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ?)
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ?))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ?)
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ::
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ::
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "add" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "index" | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
[]:13.723
[:12.1224
[]):12.0987	rejected
s:10.8087
xs:10.7396	rejected
[":10.6992	rejected
":10.6962
List:10.6576	rejected
string:10.2705
m:10.0072
Model:10.0026
"":9.89556
nil:9.30712	rejected
st:9.19682
str:9.05227
model:8.84405	rejected
ts:8.7339	rejected
 []:8.65089
(:8.64338
))):8.61668	rejected
lst:8.37951	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: []
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: []
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
))):16.0124	rejected
)):13.5711	rejected
)))):11.0547	rejected
),:10.9727	rejected
 :10.7848
)));:10.1984	rejected
)::9.85297	rejected
 ):9.76964
);:9.30926	rejected

:8.79689
:::8.77983
])):8.34476	rejected
))::8.21591	rejected
  :8.20349
))]:8.19839	rejected
::8.00826
@:7.95095
})):7.9495	rejected
)$:7.92651	rejected
).:7.91934	rejected
():7.61391	rejected
Rejected the highest logit candidate ))) with logit -inf

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]


LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
 :14.4077
  :13.5319
   :12.6601

:12.3722
                :11.9449
))):11.859	rejected
    :11.7865
#:11.5733	rejected
	:11.5672	rejected
     :11.4498
)):11.3406	rejected
      :10.3561
end:10.2891	rejected
       :10.1881
):9.91376
|:9.85487	rejected
})):9.73025	rejected
        :9.55666
```:9.38309	rejected
}:9.34893	rejected
m:9.15383	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
 

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
 
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
 |:15.4015	rejected
 ):12.2121
 #:11.8499	rejected
 m:11.2271	rejected
 case:10.8292	rejected
 [:10.4136	rejected
 []:10.1338	rejected
 end:10.0888	rejected
 s:10.0288	rejected
 ":9.95952	rejected
 =:9.81563
 if:9.79525	rejected
 Update:9.71032	rejected
 List:9.6953	rejected

:9.69488
 (:9.69405
 ,:9.609
 let:9.55024	rejected
 //:9.45986	rejected
 }:9.4389	rejected
 @:9.39599
Rejected the highest logit candidate  | with logit -inf

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [(String, Bool)]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: [?]
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:

:12.7744
 :10.4031
 in:10.0842	rejected
),:9.99141	rejected
 ):9.45919
@:9.42405
 |:9.21177	rejected
);:9.0984	rejected
 end:9.08845	rejected
#:9.06158	rejected
|:9.01377	rejected
end:8.97752	rejected
).:8.85241	rejected
 @:8.73045
:::8.68623
 =>:8.54642	rejected
 #:8.53639	rejected
in:8.50855	rejected
  :8.48943
                :8.38331
 =:8.24142

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )


LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [(String, Bool)]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: [?]
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
 :16.352
  :14.4857

:13.5303
#:13.4946	rejected
end:12.6665	rejected
   :12.6126
|:12.2934	rejected
):11.857
)):11.8384	rejected
}:11.7921	rejected
    :11.4988
                :11.1871
 |:11.0991	rejected
     :10.9618
let:10.5461	rejected
	:10.5048	rejected
 ):9.98818
else:9.96422	rejected
);:9.952	rejected
)|:9.88337	rejected
      :9.8651

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
 

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
 
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [(String, Bool)]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: [?]
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
 |:14.8554	rejected
 ):13.315
 case:11.9548	rejected
 #:11.8392	rejected
 end:10.9425	rejected
 else:10.2234	rejected
 m:10.1558	rejected
 T:10.0266	rejected
 if:9.85683	rejected
 Update:9.65246	rejected

:9.63277
 let:9.62536	rejected
 }:9.5795	rejected
 Add:9.40996	rejected
 s:9.40679	rejected
 return:9.35832	rejected
 @:9.03057
)):8.9634	rejected
 }):8.9133	rejected
 ():8.90248	rejected
 <:8.89142
Rejected the highest logit candidate  | with logit -inf

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:

:15.7079
 :12.2047
#:11.832	rejected
@:11.4342
  :11.3585
 |:11.2733	rejected
|:10.9429	rejected
 in:10.7458	rejected
 ):10.365
 @:10.243
 #:10.2275	rejected
 else:9.94334	rejected
                :9.84957
   :9.75534
 =>:9.74152	rejected
 end:9.73577	rejected
),:9.63619	rejected
    :9.38623
).:9.25497	rejected
end:9.14671	rejected
]:9.13591	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )


LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
 :17.2642
  :14.4032
#:14.0838	rejected

:13.9022
end:13.0075	rejected
   :12.9821
|:12.8768	rejected
}:12.3302	rejected
):12.2872
    :11.451
 |:11.389	rejected
     :11.3017
                :11.2154
 ):10.8077
	:10.7371	rejected
let:10.4967	rejected
]:10.4052	rejected
 end:10.405	rejected
 #:10.3656	rejected
else:10.176	rejected
);:10.0951	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
 

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
 
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
 |:15.4475	rejected
 ):14.6782
 #:12.5807	rejected
 case:12.5557	rejected
 end:11.1778	rejected
 }:10.6055	rejected
 Update:10.4421	rejected
 T:10.1907	rejected

:10.023
 m:9.84861	rejected
 else:9.83487	rejected
 (:9.71929
 ():9.59343	rejected
 _:9.50931	rejected
 ]:9.49759	rejected
 );:9.40533	rejected
 <:9.40096
 s:9.38153	rejected
 Add:9.32913	rejected
 if:9.31717	rejected
 ,:9.28976
Rejected the highest logit candidate  | with logit -inf

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:16.0241
#:13.224	rejected
 :12.479
 in:12.3465	rejected
@:11.928
  :11.7295
 end:11.5973
 |:11.3183
 #:11.1883	rejected
|:10.7648
end:10.6669
 else:10.4433	rejected
 @:10.1912
   :10.0239
                :9.97132
in:9.94952	rejected
    :9.76911
      :9.263
(*:9.00283	rejected
     :8.9819
(:8.9411

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )


LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 :17.2408
  :14.2274
#:14.2091	rejected

:13.6835
end:13.3161
|:12.6222
   :12.5799
 #:11.6287	rejected
 |:11.5917
let:11.3638	rejected
    :11.2219
}:11.1356	rejected
 end:10.8482
):10.7825	rejected
     :10.6952
 in:10.4352	rejected
                :10.3992
in:10.3203	rejected
	:10.1359	rejected
else:9.93663	rejected
;:9.91722	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
 

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
 
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:16.2999
 #:13.0853	rejected
 case:12.4718	rejected
 end:12.4187
 ):12.2262	rejected
 Update:10.4979	rejected
 T:10.2868	rejected
 m:10.1077	rejected
 }:10.0611	rejected
 _:10.0076	rejected
 (:9.93617

:9.82341
 else:9.78191	rejected
 Add:9.66514	rejected
 ]:9.57102	rejected
 update:9.55188	rejected
 action:9.46097	rejected
 <:9.43716
 (*:9.38435	rejected
 //:9.33503	rejected
 ?:9.30213	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  |

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  |
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "RemoveTodo" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 T:18.2732
 Update:14.5254
Toggle:12.3129
 _:12.0814
 Add:11.2313
 Remove:11.1399
 Tod:10.6844	rejected
 :10.2586
 toggle:10.0224
 (:9.82244
 To:9.78572
 TODO:9.63767	rejected

:9.36409
 #:9.28184	rejected
 Clear:9.26083	rejected
 Action:9.16026	rejected
 Show:9.14741	rejected
T:9.01908
 ?:8.8011	rejected
 Set:8.79297	rejected
 TO:8.68006	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | T

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | T
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <T>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "T"))))
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  T
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: T
LSP: Generating Completions for prefix: T
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "oggleTodo"
root ::= completions

Top 20 Logits:
oggle:21.084
og:13.3939
ogle:12.607	rejected
gl:9.59401	rejected
ogo:9.52341	rejected
Toggle:9.37302	rejected
toggle:9.02916	rejected
oga:8.94764	rejected
oto:8.73954	rejected
oge:8.48397	rejected

:7.96269	rejected
d:7.92464	rejected
gg:7.83336	rejected
ou:7.725	rejected
oc:7.64457	rejected
g:7.62106	rejected
os:7.34992	rejected
one:7.31746	rejected
n:7.2879	rejected
gle:7.27321	rejected
(:7.2261	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | Toggle

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | Toggle
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Toggle>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "Toggle"))))
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  Toggle
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Toggle
LSP: Generating Completions for prefix: Toggle
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Todo"
root ::= completions

Top 20 Logits:
T:18.1671
To:13.1511
TO:13.0914	rejected
(:11.9911	rejected
 todo:11.3264	rejected
Done:10.739	rejected
 Tod:10.5179	rejected
Toggle:9.86164	rejected
Index:9.47915	rejected
_:8.97168	rejected
Item:8.88309	rejected
Add:8.73109	rejected
 TODO:8.64367	rejected
 (:8.45635	rejected
((:8.42312	rejected
Do:8.19143	rejected
D:8.17924	rejected
TD:8.03791	rejected
(_:8.01983	rejected

:7.9991	rejected
t:7.98975	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleT

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleT
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <ToggleT>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "ToggleT"))))
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  ToggleT
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: ToggleT
LSP: Generating Completions for prefix: ToggleT
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "odo"
root ::= completions

Top 20 Logits:
odo:17.8748
od:14.5469
odd:13.0731	rejected
odos:11.7516	rejected
oto:11.3247	rejected
d:10.6835	rejected
ou:10.5118	rejected
oo:10.4504	rejected
odu:10.4242	rejected
do:10.4035	rejected
oda:10.128	rejected
ol:9.89883	rejected
odot:9.75042	rejected
ode:9.62273	rejected
odon:9.51903	rejected
ood:9.41545	rejected
udo:9.32487	rejected
(:9.29292	rejected
omo:9.22602	rejected
og:9.2093	rejected
ok:9.20732	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <ToggleTodo>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (Int -> (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)))
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Var "Action");
           syn = (Arrow (Int, (Var "Action")))})))
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  ToggleTodo
Nature of error: Expecting type Action but got inconsistent type (Int -> Action)
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: ToggleTodo
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: ToggleTodo
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
(:18.1394
 index:14.0454	rejected
(_:12.6267	rejected
 (:12.4882
 =>:12.117
 ->:11.5122	rejected
 i:11.0352	rejected
():10.8568	rejected
((:10.7168	rejected

:10.6991
($:10.3127	rejected
 _:10.0379	rejected
=>:10.0133
 =:9.93096
 todo:9.84066	rejected
 idx:9.7043	rejected
i:9.61053	rejected
 :9.28226
::9.27761	rejected
Index:9.04147	rejected
(":9.01684	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "RemoveTodo" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= completions | new-tokens

Top 20 Logits:
index:17.8967
i:14.6332
idx:13.5021
id:12.2303
n:11.5965
int:11.2581
x:11.1852
 index:11.1585
ind:10.9447
inde:10.9011
t:10.8608
toggle:10.7918
0:10.6851
Index:10.6307	rejected
nd:10.3921
description:10.1325
ix:10.0973
key:10.0603
done:9.82662
tod:9.7515
Int:9.73007	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <index>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: index
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: index
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
):17.9602
)=:13.3652	rejected
)):12.7697	rejected
,:11.6079
 =>:11.4345	rejected
)->:11.3385	rejected
),:11.1589	rejected
 ):10.2907
)::10.2594	rejected
_):9.60704	prefix accepted:_

:9.50603
)>:9.32959	rejected
 as:9.30008	rejected
=>:9.20277	rejected
);:9.20031	rejected
1:9.14895
 =:9.13721	rejected
::9.10473	rejected
)(:9.01107	rejected
2:9.00903
0:8.93906

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index)

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:17.1828
 ->:13.0869	rejected

:11.6619
 :11.4135
 =:10.4703
  :10.255
 toggle:9.92137	rejected
 (:9.88888
   :9.56555
 todo:9.29832	rejected
 :=:9.10223	rejected
 to:8.99693	rejected
    :8.96814
 ==>:8.93003	rejected
 m:8.88372	rejected
 :::8.87061	rejected
=>:8.80796
 t:8.74763	rejected
 ():8.59859	rejected
 _:8.57964	rejected
 #:8.53353	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) =>

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) =>
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "add" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "index" | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 (:15.8758
 (":13.501	rejected

:12.8256
 :12.7964
 m:12.757
 Model:12.7304
 ((:12.6833	rejected
 ?:12.5431	rejected
 ():12.181
 update:11.919
 todo:11.8738	rejected
 toggle:11.5877
 {:11.4659	rejected
(:11.4335
 let:10.8419
 ":10.7108
 List:10.7088	rejected
 model:10.4113	rejected
  :10.3415
 Tod:10.1766
 s:10.1053

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(String, Bool)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(String, Bool)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "add" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "index" | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
m:15.2182
Model:11.9929
 m:11.3068

:11.1246
model:10.84	rejected
(":10.3835	rejected
string:10.3733
update:9.92536
s:9.63103
f:9.51569
t:9.18349
List:9.06	rejected
add:9.02962
((:8.99248	rejected
,:8.94755	rejected
tod:8.65557	rejected
st:8.6209
String:8.485	rejected
toggle:8.459
index:8.43714
 Model:8.34369

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <m>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(String, Bool)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: m
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: m
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ax_int" | "in_int" | "od"
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= completions | new-tokens

Top 20 Logits:
 @:14.8753
@:11.0939
,:10.9465
[:9.44184	rejected
 :9.21777
 ,:8.95137

:8.81901
 $:8.57047
 &:8.53591
 at:8.49231	rejected
.:8.31334	rejected
 +:8.2639
 -:8.06277
):8.04325
::7.96312
 (:7.6717
(:7.64336
 update:7.6124	rejected
 |:7.58894	rejected
 *:7.48474
 :::7.48389

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model"); syn = (List (Unknown Internal))})))
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ ?
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model"); syn = (List (Unknown Internal))})))
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ ?
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ ?
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "add" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "index" | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 (:15.4745
 Model:14.3912
 (":12.6191	rejected
 toggle:12.0524
 ((:11.3056	rejected
 :11.2475
(:11.1615
 update:11.1054
 string:10.8988
 todo:10.7765	rejected
 [:10.67

:10.4841
 add:10.2781
 ([:10.146	rejected
 ():10.0805
 Tod:10.0123
 ":10.0013
 remove:9.94349
 ?:9.71575	rejected
 TODO:9.53596	rejected
 Update:9.42667

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (?)
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (?)
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (?)
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: [?]
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "add" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "index" | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
Model:15.4552
string:11.8969
model:11.2328	rejected
m:10.9889
 Model:10.5945
toggle:10.493
Mod:10.3519

:10.2318
index:10.0755
Toggle:9.98538
String:9.89409	rejected
s:9.8685
(":9.84685	rejected
List:9.62164	rejected
update:9.46035
t:9.43217
Mode:9.38888
T:9.37858
M:9.37727
)):9.25799	rejected
st:9.20447

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Model>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "Model"))))
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model)
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: [?]
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Model
LSP: Generating Completions for prefix: Model
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ".eq" | ".init"
root ::= completions

Top 20 Logits:
.:16.6578
,:9.69303	rejected
(:9.36892	rejected
(":8.71215	rejected
_:8.65673	rejected
[:8.14738	rejected
Buffer:7.89423	rejected
.(:7.86486	prefix accepted:.
)):7.77156	rejected
::7.73241	rejected
._:7.57818	rejected
 buffer:7.57162	rejected
 .:7.56839	rejected
.[:7.4015	prefix accepted:.
):7.4005	rejected
 todos:7.30935	rejected
.@:7.28372	prefix accepted:.
buffer:7.26137	rejected
..:7.20856	rejected
.$:7.19488	prefix accepted:.
:::7.13535	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Model.>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Invalid expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (BadToken "Model."))))
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.
Nature of error: "Model." isn't a valid token  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.)
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Invalid expression
  LSP: Info: BidiCtx: Expected type: [?]
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Bad token; only completion
  LSP: Syntax: Must complete: Model.
LSP: Generating Completions for prefix: Model.
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "eq" | "init"
root ::= completions

Top 20 Logits:
init:17.6451
ini:12.0328
int:11.4252	rejected
in:11.1136
Init:10.8812	rejected
 init:10.8018	rejected
i:10.7843
it:10.6494	rejected
model:10.5544	rejected
insert:9.86408	rejected
update:9.81904	rejected
input:9.50007	rejected
into:9.30979	rejected

:9.20645	rejected
id:9.10627	rejected
inst:9.09988	rejected
t:9.05313	rejected
initial:9.05276	rejected
is:9.02538	rejected
inn:9.02172	rejected
string:8.99534	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Model.init>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: (String, [(String, Bool)])
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (List (Unknown Internal)); syn = (Var "Model")})))
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init)
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: [?]
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: Model.init
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Model.init
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:16.1137
),:11.2081	rejected
 toggle:11.0333	rejected
 ,:10.8464

:10.2689
)):9.91377	rejected
(),:9.7557	rejected
 @:9.65812
(:9.57231
.:9.44855	rejected
,(:9.2655	rejected
@:9.18272
,,:9.05101	rejected
):9.02692
 string:8.70114	rejected
 :8.52784
 (:8.52316
 update:8.44784	rejected
 add:8.40497	rejected
.,:8.09253	rejected
:::7.93397

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init,

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ((String, [(String, Bool)]), ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (List (Unknown Internal));
           syn = (Prod [(Var "Model"); (Unknown Internal)])})))
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, ?
Nature of error: Expecting type [?] but got inconsistent type (Model, ?)  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, ?)
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: [?]
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ((String, [(String, Bool)]), ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (List (Unknown Internal));
           syn = (Prod [(Var "Model"); (Unknown Internal)])})))
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, ?
Nature of error: Expecting type [?] but got inconsistent type (Model, ?)  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, ?)
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: [?]
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, ?
Nature of error: Expecting type [?] but got inconsistent type (Model, ?)  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, ?)
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: [?]
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "add" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "index" | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 toggle:16.1363
 todo:11.7003	rejected
 List:10.793	rejected
 to:10.5232
 remove:10.4144
 (:10.2895
toggle:10.2162
 togg:10.1854
 string:10.1284
 add:10.0917
 :10.0362
 [:9.97887
 Model:9.97278
 update:9.68232
 tog:9.6154
 Tod:9.40398

:9.29724
 todos:9.27998	rejected
 []:9.16917
 t:9.02949
 f:8.96054

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <toggle>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ((Int, [(String, Bool)]) -> [(String, Bool)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle
Nature of error: Expecting type [?] but got inconsistent type (Model, ((Int, [Todo]) -> [Todo]))  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle)
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: [?]
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: toggle
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: toggle
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
(:16.7481
)):12.1791	rejected
((:11.6146	rejected
 index:10.6843	rejected
_:10.505	rejected
 (:10.4071
T:10.1697	rejected
[:10.1539	rejected
):9.993
i:9.98478	rejected

:9.77508
():9.7636	rejected
([:9.7507	rejected
)(:9.56942	rejected
())):9.43228	rejected
(":9.11875	rejected
.(:9.0763	rejected
index:8.99677	rejected
()):8.92209	rejected
_(:8.81514	rejected
,:8.65169

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [(String, Bool)]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(?)
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(?))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: [?]
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [(String, Bool)]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(?)
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(?))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: [?]
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, [Todo])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(?)
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(?))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "add" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "index" | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
index:16.0648
string:11.3524
i:11.2844
Model:11.0954
int:10.6061
m:10.4962
 index:10.4439
s:10.4066
st:10.4058

:10.2099
0:10.0949
List:9.84079	rejected
inde:9.79563
model:9.61899	rejected
str:9.39734
String:9.33451	rejected
in:9.2984
list:9.27071	rejected
tod:9.07372	rejected
remove:8.88854
action:8.87387

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <index>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, [Todo])
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Prod [Int; (List (Var "Todo"))]); syn = Int})))
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index)
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  index
Nature of error: Expecting type (Int, [Todo]) but got inconsistent type Int  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: index
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: index
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:16.1822
)):11.94	rejected
))):11.9232	rejected
,(:10.6351	rejected
):10.4225
 -:10.3909

:10.3354
)(:10.2618	rejected
,[:10.1157	rejected
 ,:10.112
),:9.87159	rejected
s:9.24804	rejected
(:9.00834
 +:8.90681
-:8.7195
 m:8.61154	rejected
 :8.57167
,,:8.47185	rejected
)),:8.39581	rejected
 (:8.28427
[:8.19338	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index,

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, [Todo])
  LSP: Info: Seft type: (Int, [(String, Bool)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, ?)
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ?))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, [Todo])
  LSP: Info: Seft type: (Int, [(String, Bool)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, ?)
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ?))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, ?)
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ?))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "add" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "index" | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 [:12.3531
 s:12.3041
 []:11.9257
 string:11.6504
 m:10.9429
 [":10.421	rejected
 add:10.121
 str:10.0363
 index:10.0351
 Model:10.0155
 List:9.96667	rejected
 (:9.87322
 :9.60999
 ":9.37856
 int:9.35284
 xs:8.92187	rejected
 st:8.86433
 model:8.81824	rejected
 "":8.80065
 [(:8.78221	rejected

:8.59674

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: []
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: []
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: index action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
))):15.4627	rejected
)):15.0454	rejected

:12.9494
)))):11.6622	rejected
),:11.0538	rejected
@:10.6487
 :10.6014
:::10.2524
 ):9.885
)));:9.56462	rejected
 @:9.37997
).:9.14803	rejected
);:9.06596	rejected
  :9.00356
)::8.37798	rejected
 :::8.25706
))]:8.23844	rejected
::7.97233
 in:7.9002	rejected
])):7.84759	rejected
   :7.72087
Rejected the highest logit candidate ))) with logit -inf

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []


LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
  :16.8321
 :16.5356
   :14.3899
    :13.0921

:13.0801
                :13.0733
)):13.0159	rejected
     :12.296
))):12.134	rejected
):12.0835
      :11.8394
       :11.7178
 ):11.3155
	:11.116	rejected
#:11.0852	rejected
        :10.8758
)))):10.2229	rejected
            :10.1799
         :9.93144
          :9.85814
               :9.80119

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
  

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
  
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
)):20.3329	rejected
))):20.1663	rejected

:16.9921
)))):16.5463	rejected
 ):15.8395
)));:14.6191	rejected
))]:14.2264	rejected
]):14.1767	rejected
	:13.559	rejected
0:13.107	rejected
 @:12.9771
)::12.4613	rejected
)$:12.3768	rejected
 #:12.1785	rejected
 *:12.0447
 (:11.7704
 |:11.755	rejected
1:11.7109	rejected
2:11.5205	rejected
 }:11.4321	rejected
))$:11.4188	rejected
Rejected the highest logit candidate )) with logit -inf

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [(String, Bool)]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: [?]
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:

:16.1698
 :12.4616
 ):11.5098
   :10.9619
  :10.6876
                :10.508
     :9.9945
      :9.70599
    :9.67475
#:9.62746	rejected
@:9.56384
       :9.43107
 in:9.3796	rejected
),:9.36224	rejected
 #:9.33676	rejected
	:9.18472	rejected
 @:9.05692
             :8.51772
        :8.46966
         :8.42538
               :8.40605

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )


LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [(String, Bool)]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: [?]
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
  :16.7729
 :16.1738
   :15.3374
)):12.8331	rejected
 ):12.1207
    :11.9836

:11.9555
):11.7918
     :11.0202
                :10.6103
       :10.4968
	:10.4213	rejected
#:10.2092	rejected
      :9.88651
        :9.24123
 #:9.22854	rejected
           :9.21227
end:9.21098	rejected
))):8.9585	rejected
               :8.79431
));:8.71305	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
  

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
  
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [(String, Bool)]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: [?]
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
)):19.6367	rejected
 ):19.4878
))):15.6523	rejected

:14.7667
)))):13.8373	rejected
 ),:13.6312	rejected
 );:13.4869	rejected
 #:13.1105	rejected
))]:12.9546	rejected
)));:12.6538	rejected
 }):12.552	rejected
]):12.5065	rejected
	:12.1303	rejected
 .:11.7985	rejected
))`:11.7254	rejected
 |:11.3717	rejected
 ).:11.246	rejected
 }:11.2378	rejected
 ,:11.2034
 @:11.1058
 ():11.0379	rejected
Rejected the highest logit candidate )) with logit -inf

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:

:16.9174
 :12.3029
#:11.1678	rejected
 ):11.0994
  :10.8241
   :10.6847
 in:10.6311	rejected
                :10.3813
    :9.9685
 #:9.83784	rejected
      :9.64799
     :9.5899
       :9.02129
),:8.97796	rejected
	:8.94941	rejected
 end:8.92967	rejected
in:8.78524	rejected
        :8.42493
end:8.32745	rejected
@:8.217
               :8.21137

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )


LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
  :16.7431
 :15.4077
   :13.472
 ):12.2262
):11.9789

:11.8535
#:10.5937	rejected
    :10.5217
|:10.0813	rejected
                :9.82081
end:9.75666	rejected
 |:9.73079	rejected
 #:9.72435	rejected
     :9.62602
	:9.52076	rejected
      :9.05615
)):8.99144	rejected
       :8.9123
\:8.74426
 );:8.58999	rejected
        :8.3915

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
  

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
  
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
 ):20.2349
)):15.9086	rejected
 );:14.2073	rejected

:14.1571
 #:14.0587	rejected
 ),:13.6438	rejected
 |:13.1953	rejected
 ).:12.2291	rejected
))):12.1353	rejected
)))):11.8636	rejected
 }:11.8219	rejected
 .:11.6548	rejected
	:11.4461	rejected
 }):11.3917	rejected
 ():11.2685	rejected
 ]:11.0466	rejected
 ;:10.9174	rejected
 ,:10.8959
 *):10.8705	rejected
 @:10.7653
 end:10.4847	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:16.2748
#:13.0056	rejected
 :12.7533
 in:12.6126	rejected
 end:11.7562
 #:10.8453	rejected
  :10.7162
   :10.6314
end:10.511
in:10.4129	rejected
                :9.92158
    :9.72403
 where:9.6763	rejected
 else:9.63624	rejected
@:9.3927
 |:9.39137
|:9.17995
     :8.98614
      :8.95766
       :8.72833
	:8.62988	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )


LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 :17.0648
  :14.0126
   :13.1423
#:13.0993	rejected

:12.9678
end:12.5949
|:12.3066
 |:12.1843
 #:11.7176	rejected
    :11.4146
 end:11.2682
 in:10.5237	rejected
}:10.2594	rejected
     :9.89611
):9.87138	rejected
 ):9.82965	rejected
                :9.73795
let:9.70812	rejected
@:9.50746
in:9.50567	rejected
	:9.50508	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
 

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
 
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {index: Int, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:17.6232
 end:13.5223
 #:13.3628	rejected
 ):12.5718	rejected
 Update:12.0996	rejected
 in:11.4363	rejected
 }:11.2359	rejected
 action:11.1081	rejected
 case:11.0233	rejected
 update:10.8836	rejected
 _:10.8832	rejected

:10.8322
 );:10.7325	rejected
 Action:10.7231	rejected
 @:10.5171
 s:10.4041	rejected
 ]:10.3798	rejected
 (*:10.3554	rejected
 m:10.3079	rejected
 //:10.1803	rejected
 Add:10.1612	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  |

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  |
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "RemoveTodo" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 Update:18.7488
 _:13.2939
Update:11.1854
 Add:10.9829
 Action:10.6884	rejected
 :10.3325
 Remove:10.1024
 Up:9.93566
 Set:9.8725	rejected
 update:9.74024
 Input:9.55807	rejected
 Change:9.55234	rejected
 Clear:9.51904	rejected
 (:9.39747
 #:9.30453	rejected
 T:9.29272
 U:9.23866
 Edit:9.10148	rejected
 Buffer:8.88834	rejected
 u:8.76355
 Model:8.72984	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | Update

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | Update
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Update>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "Update"))))
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Update
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Update
LSP: Generating Completions for prefix: Update
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Buffer"
root ::= completions

Top 20 Logits:
Buffer:19.7857
B:14.2735
buffer:12.1216	rejected
Bu:12.0309
Description:11.7261	rejected
(:11.5349	rejected
T:11.1806	rejected
Input:10.9943	rejected
BU:10.5745	rejected
 buffer:10.2588	rejected
Desc:10.0158	rejected
Model:9.98202	rejected
Button:9.92993	rejected
_:9.91429	rejected
Text:9.80327	rejected
Action:9.78807	rejected
Des:9.62969	rejected
 Buffer:9.40772	rejected
To:8.84473	rejected
Add:8.81388	rejected
buf:8.7653	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <UpdateBuffer>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (String -> (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)))
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Var "Action");
           syn = (Arrow (String, (Var "Action")))})))
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  UpdateBuffer
Nature of error: Expecting type Action but got inconsistent type (String -> Action)
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: UpdateBuffer
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: UpdateBuffer
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
(:16.7832
 buffer:13.0297	rejected
(_:12.5947	rejected
(":12.1316	rejected
 desc:11.5166	rejected
 description:11.4984	rejected
 buf:11.1904	rejected
 str:10.9607	rejected
 s:10.7622	rejected
 b:10.6401	rejected
 text:10.6135	rejected
():10.5089	rejected
 (:10.4768
 value:10.0387	rejected
 new:9.91817	rejected
($:9.89132	rejected
 =>:9.71887
 ->:9.62123	rejected
 txt:9.55672	rejected
 string:9.50786	rejected
 _:9.44373	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: String
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "RemoveTodo" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= completions | new-tokens

Top 20 Logits:
buffer:17.4816
description:16.1925
text:14.9739
buf:14.9633
new:14.8406
input:14.6421
str:14.2242
string:13.8957
s:13.6979
desc:13.6451
b:13.5455
content:13.4225
value:13.357
x:13.1714
txt:12.9289
t:12.687
contents:12.5602
d:12.234
des:12.225
buff:12.0618
char:11.6939

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(buffer

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(buffer
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <buffer>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: String
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: buffer
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: buffer
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
):18.1782
)=:13.5166	rejected
'):13.2609	rejected
_:12.597
)):12.4935	rejected
Text:11.9035
)->:11.8894	rejected
_):11.6027	prefix accepted:_
,:11.2772
 ):11.1682
Value:11.0866
Str:10.8248
::10.7305	rejected
),:10.7148	rejected
String:10.7119
':10.6831	rejected
 ->:10.3835	rejected
1:10.1672
)':10.1025	rejected
)::9.98315	rejected
)`:9.92763	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(buffer)

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(buffer)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:17.4104
 ->:12.8513	rejected
 =:11.9598
 :11.6719

:11.4494
   :10.0651
  :9.6481
 m:9.44418	rejected
    :9.41544
 :=:9.17039	rejected
 #:9.12424	rejected
 ?:9.01921	rejected
 in:8.93472	rejected
 :::8.85654	rejected
 when:8.83265	rejected
 (:8.7638
     :8.6937
 ==:8.56546	rejected
=>:8.53593
 {:8.52651	rejected
 _:8.48917	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(buffer) =>

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(buffer) =>
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: buffer action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 (:16.3479
 (":15.1748	rejected
 m:14.6801
 Model:13.9106
 ((:12.8734	rejected

:12.6348
 ?:12.6178	rejected
 :12.6083
 buffer:12.3448
 ([:11.5256	rejected
(:11.4612
 [:11.3585
 update:11.2112
 ():11.1977
 {:10.9914	rejected
 model:10.931	rejected
 s:10.9182
 let:10.8697
 if:10.6931
 ":10.6089
 [":10.5619	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(buffer) => (

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(buffer) => (
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(String, Bool)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(String, Bool)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: buffer action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: buffer action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
m:15.1952
buffer:13.7406
Model:12.9406
model:11.651	rejected
(":11.1727	rejected
update:10.425
string:10.4237
b:10.385

:10.2731
 m:10.2716
s:10.2042
String:9.83673	rejected
[":9.6515	rejected
f:9.62261
Update:9.20473
 buffer:8.95929
str:8.9566
buf:8.8522
,:8.84801	rejected
(),:8.69494	rejected
t:8.64824

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(buffer) => (m

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(buffer) => (m
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <m>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(String, Bool)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: m
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: m
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: buffer action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ax_int" | "in_int" | "od"
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= completions | new-tokens

Top 20 Logits:
 @:15.6813
@:11.6482
[:11.2364	rejected
,:10.725
 &:9.6054
 :9.60403
 +:9.39322
 at:9.35005	rejected
 =:9.32222

:9.30321
 $:9.28312
.:9.25418	rejected
::9.02375
):8.70448
 ,:8.55226
 ::8.3061
 -:8.14777
 |:8.08957	rejected
 :::8.01212
 <:7.96526
 *:7.95873

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(buffer) => (m @

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(buffer) => (m @
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model"); syn = (List (Unknown Internal))})))
  LSP: Info: Typing Context: {buffer: String, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ ?
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model"); syn = (List (Unknown Internal))})))
  LSP: Info: Typing Context: {buffer: String, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ ?
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ ?
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: buffer action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: buffer action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 Model:16.1135
 (:16.0995
 (":14.7067	rejected
 buffer:12.8712
 ([:11.7249	rejected
 update:11.7138
 ((:11.6346	rejected
 [:11.3928
 string:11.2236
 :11.1881
(:11.1023
 [":11.0102	rejected
 Mod:10.7691
 Update:10.5811
 ":10.4501
 model:10.3335	rejected

:10.2587
 ?:10.1092	rejected
 String:10.1043	rejected
 add:10.0375
 Buffer:9.94639	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(buffer) => (m @ (

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(buffer) => (m @ (
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (?)
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (?)
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (?)
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: [?]
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: buffer action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: buffer action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
Model:15.1121
buffer:14.3461
string:11.9539
String:11.6308	rejected
model:11.3183	rejected
update:10.6848
s:10.3992
m:10.2326
b:10.0528
(":10.0417	rejected
Update:9.84982
buf:9.79241
[":9.67524	rejected
 Model:9.61273

:9.4349
str:9.27066
 buffer:9.18883
Mod:8.85345
_,:8.84184	rejected
M:8.76784
,:8.61677	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(buffer) => (m @ (Model

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(buffer) => (m @ (Model
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Model>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "Model"))))
  LSP: Info: Typing Context: {buffer: String, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model
Nature of error: Constructor is not defined  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model)
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: [?]
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Model
LSP: Generating Completions for prefix: Model
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: buffer action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ".eq" | ".init"
root ::= completions

Top 20 Logits:
.:17.7948
_:10.9086	rejected
(:10.6364	rejected
,:10.6314	rejected
.(:10.6124	prefix accepted:.
 init:9.78929	rejected
(":9.52986	rejected
.[:9.0741	prefix accepted:.
::9.049	rejected
)):8.7724	rejected
.,:8.68248	prefix accepted:.
[:8.68011	rejected
..:8.65962	rejected
._:8.32027	rejected
.@:8.31009	prefix accepted:.
.):8.16662	prefix accepted:.
@:8.14965	rejected
 .:8.10372	rejected

:7.92227	rejected
init:7.89821	rejected
):7.88102	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(buffer) => (m @ (Model.

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(buffer) => (m @ (Model.
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Model.>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Invalid expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (BadToken "Model."))))
  LSP: Info: Typing Context: {buffer: String, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  Model.
Nature of error: "Model." isn't a valid token  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.)
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Invalid expression
  LSP: Info: BidiCtx: Expected type: [?]
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Bad token; only completion
  LSP: Syntax: Must complete: Model.
LSP: Generating Completions for prefix: Model.
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: buffer action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "eq" | "init"
root ::= completions

Top 20 Logits:
init:18.2636
int:12.2911	rejected
in:12.2637
ini:12.0988
update:11.2608	rejected
model:11.1239	rejected
buffer:11.0106	rejected
Init:10.631	rejected
 init:10.4694	rejected
input:10.3276	rejected
i:10.2602
initial:10.2018	rejected
s:9.85205	rejected
string:9.82314	rejected
set:9.61287	rejected
f:9.50231	rejected
empty:9.4885	rejected
insert:9.37541	rejected
ins:9.28281	rejected
t:9.27439	rejected
length:9.13914	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(buffer) => (m @ (Model.init

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(buffer) => (m @ (Model.init
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Model.init>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: (String, [(String, Bool)])
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (List (Unknown Internal)); syn = (Var "Model")})))
  LSP: Info: Typing Context: {buffer: String, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init)
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: [?]
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: Model.init
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Model.init
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: buffer action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:16.152
 @:11.0454
)):10.9509	rejected
 ,:10.7563
 buffer:10.6754	rejected

:10.5309
(:9.95182
):9.82759
@:9.56169
),:9.4408	rejected
,[:9.36723	rejected
.:9.25016	rejected
,(:9.1977	rejected
 :8.91253
 +:8.90365
 update:8.71081	rejected
 string:8.69248	rejected
[:8.63577	rejected
(),:8.61238	rejected
,,:8.57909	rejected
 s:8.26025	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(buffer) => (m @ (Model.init,

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(buffer) => (m @ (Model.init,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ((String, [(String, Bool)]), ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (List (Unknown Internal));
           syn = (Prod [(Var "Model"); (Unknown Internal)])})))
  LSP: Info: Typing Context: {buffer: String, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, ?)
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  Model.init, ?
Nature of error: Expecting type [?] but got inconsistent type (Model, ?)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: [?]
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ((String, [(String, Bool)]), ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (List (Unknown Internal));
           syn = (Prod [(Var "Model"); (Unknown Internal)])})))
  LSP: Info: Typing Context: {buffer: String, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, ?)
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  Model.init, ?
Nature of error: Expecting type [?] but got inconsistent type (Model, ?)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: [?]
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, ?)
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  Model.init, ?
Nature of error: Expecting type [?] but got inconsistent type (Model, ?)  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: [?]
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: buffer action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: buffer action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 buffer:13.0115
 [:12.9476
 update:12.7148
 add:12.1572
 []:11.8931
 List:11.4696	rejected
 Model:10.9711
 string:10.7778
 s:10.3833
 toggle:10.3303
 (:10.1458
 remove:10.036
 "":9.87185
 model:9.84157	rejected
 [":9.68036	rejected
 String:9.48471	rejected
 f:9.46256
 ":9.41812
 :9.37353
 m:9.36953
 str:9.3483

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(buffer) => (m @ (Model.init, [

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(buffer) => (m @ (Model.init, [
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <[ ]<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, ?)
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  Model.init, ?
Nature of error: Expecting type [?] but got inconsistent type (Model, [?])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: [?]
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, ?)
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  Model.init, ?
Nature of error: Expecting type [?] but got inconsistent type (Model, [?])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: [?]
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, ?)
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  Model.init, ?
Nature of error: Expecting type [?] but got inconsistent type (Model, [?])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-convex or complete: [
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: buffer action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: [
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: buffer action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "]"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
]):13.2574	rejected
Update:11.7944
buffer:11.6765
(":10.8731	rejected
T:10.6465
string:10.3315

:10.2895
s:10.1833
Toggle:9.71806
List:9.71651	rejected
update:9.68144
Action:9.54227	rejected
String:9.46313	rejected
1:9.28539
model:9.15957	rejected
Add:9.08236
0:8.94054
index:8.91553	rejected
str:8.74301
():8.73841
t:8.732
Rejected the highest logit candidate ]) with logit -inf

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(buffer) => (m @ (Model.init, [Update

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(buffer) => (m @ (Model.init, [Update
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Update>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "Update"))))
  LSP: Info: Typing Context: {buffer: String, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  Update
Nature of error: Constructor is not defined  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, Update)
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  Model.init, Update
Nature of error: Expecting type [?] but got inconsistent type (Model, [?])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Update
LSP: Generating Completions for prefix: Update
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: buffer action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Buffer"
root ::= completions

Top 20 Logits:
Buffer:14.4675
B:11.0708
T:10.5532	rejected
(:10.2248	rejected
]:10.2229	rejected
Model:10.1094	rejected
_:9.64844	rejected
.:9.61496	rejected
buffer:9.36038	rejected
Bu:9.33179
Action:9.18092	rejected
 buffer:8.88788	rejected
 Buffer:8.79868	rejected
Input:8.67913	rejected
BU:8.42064	rejected
]):8.34801	rejected
Button:8.22629	rejected
,:8.125	rejected
(":8.09919	rejected
Text:8.08787	rejected
String:8.00644	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(buffer) => (m @ (Model.init, [UpdateBuffer

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(buffer) => (m @ (Model.init, [UpdateBuffer
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <UpdateBuffer>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (String -> (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, UpdateBuffer)
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  Model.init, UpdateBuffer
Nature of error: Expecting type [?] but got inconsistent type (Model, [(String -> Action)])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-concave or complete: UpdateBuffer
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: UpdateBuffer
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: buffer action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "]"
root ::= new-tokens

Top 20 Logits:
(:14.4746
]:12.6721
(":11.8001	rejected
([:11.0818	rejected
 buffer:11.0496	rejected
((:10.6807	rejected
,:10.4576
]):10.4476	rejected
])):10.3749	rejected
():10.0625	rejected
 (:9.40361
](:9.26376	rejected
.:9.14148	rejected

:9.08454
[:8.88998	rejected
],:8.82302	rejected
(),:8.27036	rejected
::8.19157
(|:8.08846	rejected
][:7.70965	rejected
|:7.65603	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(buffer) => (m @ (Model.init, [UpdateBuffer(

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(buffer) => (m @ (Model.init, [UpdateBuffer(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, UpdateBuffer(?))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  Model.init, UpdateBuffer(?)
Nature of error: Expecting type [?] but got inconsistent type (Model, [Action])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, UpdateBuffer(?))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  Model.init, UpdateBuffer(?)
Nature of error: Expecting type [?] but got inconsistent type (Model, [Action])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: String
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, UpdateBuffer(?))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  Model.init, UpdateBuffer(?)
Nature of error: Expecting type [?] but got inconsistent type (Model, [Action])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: buffer action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: buffer action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
buffer:14.0745
string:11.7252
String:11.7191	rejected
str:11.1369
b:10.9477
s:10.8713
0:10.6467
update:10.4784
index:10.0256	rejected
int:9.9619
List:9.9053	rejected
[]:9.75926
model:9.61655	rejected
1:9.58535
m:9.47877
buf:9.43625
st:9.25579
action:9.10485

:9.08442
x:8.88781	rejected
up:8.87296

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(buffer) => (m @ (Model.init, [UpdateBuffer(buffer

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(buffer) => (m @ (Model.init, [UpdateBuffer(buffer
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <buffer>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: String
  LSP: Info: Seft type: String
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, UpdateBuffer(buffer))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  Model.init, UpdateBuffer(buffer)
Nature of error: Expecting type [?] but got inconsistent type (Model, [Action])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: buffer
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: buffer
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: buffer action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
)]:15.0726	rejected
):13.055
),:12.2379	rejected

:11.3542
)):10.9662	rejected
,:9.94063
:::9.79473
);:9.64226	rejected
 +:9.59337
]:9.25513	rejected
]]:9.19723	rejected
]):9.00192	rejected
@:8.87621
)];:8.86388	rejected
 @:8.67927
))):8.53294	rejected
)|:8.36965	rejected
)[:8.33399	rejected
)))):8.18069	rejected
)](:8.15756	rejected
))]:8.09642	rejected
Rejected the highest logit candidate )] with logit -inf

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(buffer) => (m @ (Model.init, [UpdateBuffer(buffer)

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(buffer) => (m @ (Model.init, [UpdateBuffer(buffer)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, UpdateBuffer(buffer))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  Model.init, UpdateBuffer(buffer)
Nature of error: Expecting type [?] but got inconsistent type (Model, [Action])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "]"
root ::= new-tokens

Top 20 Logits:
]):15.2625	rejected
:::13.525

:13.3999
],:12.1371	rejected
 :::11.2421
 ]:10.9448
 |:10.5344	rejected
][:10.4428	rejected
@:10.2671
 in:10.0852	rejected
 @:10.081
 :9.81373
 ->:9.39221	rejected
 ::9.22711
():8.97704	rejected
].:8.89227	rejected
],[:8.85962	rejected
 +:8.75116
])):8.71701	rejected
 ,:8.71033
 &:8.68826
Rejected the highest logit candidate ]) with logit -inf

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(buffer) => (m @ (Model.init, [UpdateBuffer(buffer)::

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(buffer) => (m @ (Model.init, [UpdateBuffer(buffer)::
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >::<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Cons
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [(AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String))]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, UpdateBuffer(buffer) :: ?)
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  Model.init, UpdateBuffer(buffer) :: ?
Nature of error: Expecting type [?] but got inconsistent type (Model, [[Action]])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Cons
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Info: Cls: Cons
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [(AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String))]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, UpdateBuffer(buffer) :: ?)
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  Model.init, UpdateBuffer(buffer) :: ?
Nature of error: Expecting type [?] but got inconsistent type (Model, [[Action]])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Cons
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, UpdateBuffer(buffer) :: ?)
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  Model.init, UpdateBuffer(buffer) :: ?
Nature of error: Expecting type [?] but got inconsistent type (Model, [[Action]])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Cons
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-convex or complete: ::
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: buffer action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ::
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: buffer action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "m" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
[]:13.342
[]):10.8835	rejected
[:10.6607
]:10.4511	rejected
s:10.2611
Update:10.0341
Model:10.0049
m:9.90723
]):9.70193	rejected
update:9.61204
add:9.14958
string:9.01085
(:8.89718
List:8.73192	rejected
buffer:8.6541
t:8.61049
model:8.50877	rejected
xs:8.47912	rejected
ts:8.40453	rejected
 []:8.34813
action:8.31827

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(buffer) => (m @ (Model.init, [UpdateBuffer(buffer)::[]

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(buffer) => (m @ (Model.init, [UpdateBuffer(buffer)::[]
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, UpdateBuffer(buffer) :: )
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  Model.init, UpdateBuffer(buffer) :: 
Nature of error: Expecting type [?] but got inconsistent type (Model, [[Action]])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Cons
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-concave or complete: []
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: []
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: buffer action m update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "]"
root ::= new-tokens

Top 20 Logits:

:14.3316
]:14.2614
])):13.5906	rejected
]):13.5647	rejected
)):11.6144	rejected
))):11.4088	rejected
 ]:11.0262
 :10.934
):10.7865	rejected
 in:10.1728	rejected
],:10.1672	rejected
 |:9.83942	rejected
 ):9.69027	rejected
  :9.44029
|:9.41462	rejected
]]):9.29203	rejected
)]:9.24691	rejected
   :9.19057
),:9.09228	rejected
    :8.9053
](:8.61754	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(buffer) => (m @ (Model.init, [UpdateBuffer(buffer)::[]


LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(buffer) => (m @ (Model.init, [UpdateBuffer(buffer)::[]

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, UpdateBuffer(buffer) :: )
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  Model.init, UpdateBuffer(buffer) :: 
Nature of error: Expecting type [?] but got inconsistent type (Model, [[Action]])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Cons
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "]"
root ::= new-tokens

Top 20 Logits:
   :17.2993
  :17.0528
 :15.1258
    :14.0945
                :13.5419

:13.4941
     :12.5733
):12.3182	rejected
      :12.1781
       :12.0974
]):11.8287	rejected
]:11.7908
 ]:11.523
	:11.5079	rejected
])):11.4249	rejected
 ):11.4225	rejected
)):11.2876	rejected
           :11.0765
        :10.8851
#:10.4621	rejected
         :10.4017

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(buffer) => (m @ (Model.init, [UpdateBuffer(buffer)::[]
   

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(buffer) => (m @ (Model.init, [UpdateBuffer(buffer)::[]
   
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, UpdateBuffer(buffer) :: )
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  Model.init, UpdateBuffer(buffer) :: 
Nature of error: Expecting type [?] but got inconsistent type (Model, [[Action]])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Cons
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "]"
root ::= new-tokens

Top 20 Logits:
]):19.4659	rejected
 ):18.2817	rejected
 ]:18.0364
)):17.5867	rejected
))):16.4697	rejected

:15.3497
))]:13.6253	rejected
)));:13.2751	rejected
)))):12.9473	rejected
])):12.7953	rejected
 ,:12.7769
	:12.7693	rejected
](:12.7104	rejected
)::12.5788	rejected
 );:12.4727	rejected
 }:12.4668	rejected
 }):12.4599	rejected
 ),:12.372	rejected
 |:12.0945	rejected
 #:11.9761	rejected
 ;:11.6181	rejected
Rejected the highest logit candidate ]) with logit -inf

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(buffer) => (m @ (Model.init, [UpdateBuffer(buffer)::[]
    ]

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(buffer) => (m @ (Model.init, [UpdateBuffer(buffer)::[]
    ]
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [[(AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String))]]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, UpdateBuffer(buffer) :: )
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  Model.init, UpdateBuffer(buffer) :: 
Nature of error: Expecting type [?] but got inconsistent type (Model, [[Action]])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: [?]
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:

:16.8437
)):14.7898	rejected
 :12.1293
))):11.7269	rejected
 ):11.4715
  :10.2919
 @:10.2718
    :10.1871
@:9.95345
                :9.92633
)))):9.88857	rejected
   :9.85055
),:9.83656	rejected
     :9.61786
))]:9.56024	rejected
      :9.43862
 #:9.07052	rejected
       :9.02707
	:8.89835	rejected
#:8.86081	rejected
);:8.85483	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(buffer) => (m @ (Model.init, [UpdateBuffer(buffer)::[]
    ]


LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(buffer) => (m @ (Model.init, [UpdateBuffer(buffer)::[]
    ]

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [[(AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String))]]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, UpdateBuffer(buffer) :: )
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  Model.init, UpdateBuffer(buffer) :: 
Nature of error: Expecting type [?] but got inconsistent type (Model, [[Action]])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: [?]
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
   :17.635
    :17.0352
  :14.5541
 :12.9742
     :12.788
)):11.8266	rejected
       :11.6153

:11.5071
      :11.4867
	:11.4784	rejected
):11.0904
                :10.8733
        :10.6791
 ):10.0996
#:9.92515	rejected
));:9.1772	rejected
         :9.02582
            :8.95007
          :8.92695
           :8.813
))):8.5184	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(buffer) => (m @ (Model.init, [UpdateBuffer(buffer)::[]
    ]
    

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(buffer) => (m @ (Model.init, [UpdateBuffer(buffer)::[]
    ]
    
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [[(AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String))]]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, UpdateBuffer(buffer) :: )
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  Model.init, UpdateBuffer(buffer) :: 
Nature of error: Expecting type [?] but got inconsistent type (Model, [[Action]])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: [?]
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
)):22.735	rejected
 ):18.6032
))):18.2104	rejected

:16.9993
)))):16.9083	rejected
))]:16.4156	rejected
)));:16.0105	rejected
]):14.8331	rejected
))`:14.2917	rejected
)::13.3879	rejected
))$:13.2638	rejected
)){:13.2329	rejected
)$:13.1782	rejected
 );:12.9905	rejected
 #:12.9871	rejected
))::12.9144	rejected
))\:12.3787	rejected
	:12.3728	rejected
 }):12.1399	rejected
 ),:12.038	rejected
 *:11.9136
Rejected the highest logit candidate )) with logit -inf

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(buffer) => (m @ (Model.init, [UpdateBuffer(buffer)::[]
    ]
    


LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(buffer) => (m @ (Model.init, [UpdateBuffer(buffer)::[]
    ]
    

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [[(AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String))]]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, UpdateBuffer(buffer) :: )
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  Model.init, UpdateBuffer(buffer) :: 
Nature of error: Expecting type [?] but got inconsistent type (Model, [[Action]])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: [?]
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
   :15.5055
  :15.0351
    :14.8739
#:14.2102	rejected
 :14.1855

:13.3934
     :12.476
let:12.1891	rejected
)):12.029	rejected
      :11.5777
 #:11.4914	rejected
):11.4049
	:11.0233	rejected
end:10.9731	rejected
                :10.8261
       :10.7778
        :10.6634
}:10.2511	rejected
|:9.81309	rejected
 ):9.7816
            :9.56444

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(buffer) => (m @ (Model.init, [UpdateBuffer(buffer)::[]
    ]
    
    

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(buffer) => (m @ (Model.init, [UpdateBuffer(buffer)::[]
    ]
    
    
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [[(AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String))]]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, UpdateBuffer(buffer) :: )
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  Model.init, UpdateBuffer(buffer) :: 
Nature of error: Expecting type [?] but got inconsistent type (Model, [[Action]])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: [?]
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
)):20.3122	rejected

:18.0834
 ):16.3517
))):16.0862	rejected
)))):15.6868	rejected
))]:15.4794	rejected
)));:14.8866	rejected
 #:14.6721	rejected
]):13.8116	rejected
	:12.8732	rejected
0:12.5564	rejected
 end:12.4382	rejected
1:12.3056	rejected
 in:12.1708	rejected
 *:12.0198
))`:11.9527	rejected
2:11.7921	rejected
 );:11.6102	rejected
 }):11.4972	rejected
)){:11.4252	rejected
))$:11.3611	rejected
Rejected the highest logit candidate )) with logit -inf

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(buffer) => (m @ (Model.init, [UpdateBuffer(buffer)::[]
    ]
    
    


LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(buffer) => (m @ (Model.init, [UpdateBuffer(buffer)::[]
    ]
    
    

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [[(AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String))]]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, UpdateBuffer(buffer) :: )
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  Model.init, UpdateBuffer(buffer) :: 
Nature of error: Expecting type [?] but got inconsistent type (Model, [[Action]])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: [?]
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
    :15.8582
   :15.3287
#:14.2779	rejected
  :14.0988
 :13.8512
     :13.3471

:13.1597
let:12.3429	rejected
      :12.028
       :11.8124
 #:11.4367	rejected
                :11.3714
        :11.2589
)):10.8346	rejected
            :10.3749
):10.3555
	:10.343	rejected
         :9.88145
 let:9.88123	rejected
           :9.84176
|:9.82933	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(buffer) => (m @ (Model.init, [UpdateBuffer(buffer)::[]
    ]
    
    
    

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(buffer) => (m @ (Model.init, [UpdateBuffer(buffer)::[]
    ]
    
    
    
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [[(AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String))]]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, UpdateBuffer(buffer) :: )
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  Model.init, UpdateBuffer(buffer) :: 
Nature of error: Expecting type [?] but got inconsistent type (Model, [[Action]])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: [?]
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
)):19.017	rejected

:18.4458
))):15.3614	rejected
))]:15.1638	rejected
)))):15.0143	rejected
 ):14.7852
)));:14.17	rejected
 #:13.9827	rejected
 in:13.6657	rejected
]):13.2862	rejected
 *:12.6215
	:12.3185	rejected
 end:12.276	rejected
0:12.0841	rejected
1:11.846	rejected
))`:11.3571	rejected
2:11.2191	rejected
 let:11.1921	rejected
)){:11.0219	rejected
))$:10.9154	rejected
 *):10.7634	rejected
Rejected the highest logit candidate )) with logit -inf

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(buffer) => (m @ (Model.init, [UpdateBuffer(buffer)::[]
    ]
    
    
    


LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(buffer) => (m @ (Model.init, [UpdateBuffer(buffer)::[]
    ]
    
    
    

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [[(AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String))]]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, UpdateBuffer(buffer) :: )
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  Model.init, UpdateBuffer(buffer) :: 
Nature of error: Expecting type [?] but got inconsistent type (Model, [[Action]])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: [?]
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
    :16.8228
   :15.8127
#:14.5139	rejected
     :14.0383
 :13.9953
  :13.9164

:13.0804
       :12.6702
      :12.4407
        :12.1765
                :12.0235
            :11.3525
 #:11.2989	rejected
let:11.0363	rejected
           :10.9426
         :10.9342
)):10.928	rejected
          :10.6084
	:10.4076	rejected
             :10.3151
):10.3102

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(buffer) => (m @ (Model.init, [UpdateBuffer(buffer)::[]
    ]
    
    
    
    

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(buffer) => (m @ (Model.init, [UpdateBuffer(buffer)::[]
    ]
    
    
    
    
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [[(AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String))]]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, UpdateBuffer(buffer) :: )
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  Model.init, UpdateBuffer(buffer) :: 
Nature of error: Expecting type [?] but got inconsistent type (Model, [[Action]])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: [?]
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
)):18.7258	rejected

:18.6278
))):15.5626	rejected
))]:15.5575	rejected
)))):14.9114	rejected
 ):14.588
)));:14.2134	rejected
 in:13.7972	rejected
]):13.6279	rejected
 #:13.6127	rejected
 *:12.6238
 end:12.3444	rejected
0:12.117	rejected
1:11.7656	rejected
	:11.7423	rejected
))`:11.3651	rejected
2:11.0562	rejected
)){:11.0037	rejected
))$:10.861	rejected
 *):10.7648	rejected
3:10.6939	rejected
Rejected the highest logit candidate )) with logit -inf

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(buffer) => (m @ (Model.init, [UpdateBuffer(buffer)::[]
    ]
    
    
    
    


LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model = fun m, action ->
  case action
  | AddTodo => (m @ Model.init)
  | RemoveTodo(index) => (m @ (Model.init, remove(index, string_of_int(index)::string_of_int(index + 1)::[]
  )
  )
  )
  | ToggleTodo(index) => (m @ (Model.init, toggle(index, []
   )
   )
   )
  | UpdateBuffer(buffer) => (m @ (Model.init, [UpdateBuffer(buffer)::[]
    ]
    
    
    
    

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [[(AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String))]]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: String, action: Action, m: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  string_of_int(index)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  m @ (Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: ))
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  Model.init, toggle(index, )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  Model.init
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  Model.init, remove(index, string_of_int(index) :: string_of_int(index + 1) :: )
Nature of error: Expecting type [?] but got inconsistent type (Model, [Todo])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, UpdateBuffer(buffer) :: )
Nature of error: Expecting type Model but got inconsistent type [?]  
Error in term:
  string_of_int(index + 1)
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  Model.init, UpdateBuffer(buffer) :: 
Nature of error: Expecting type [?] but got inconsistent type (Model, [[Action]])  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m
Nature of error: Expecting type [?] but got inconsistent type Model  
Error in term:
  m @ (Model.init, toggle(index, ))
Nature of error: Expecting type Model but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: [?]
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
    :17.2635
   :15.9617
#:14.5776	rejected
     :14.2424
 :14.1268
  :14.0709

:13.1644
       :12.9618
      :12.6411
        :12.5453
                :12.3604
            :11.7199
           :11.3455
 #:11.3106	rejected
         :11.2979
          :11.127
)):11.0285	rejected
             :10.6933
	:10.4813	rejected
):10.412
let:10.2099	rejected
