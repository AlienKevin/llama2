type OptionInt =
  + Some(Int)
  + None
in

type Result =
  + Ok(?)
  + Err(?)
in

type Value =
  + Object([(String, Value)])
  + Array([Value])
  + Str(String)
  + Number(Float)
  + Boolean(Bool)
  + Null 
in

let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

let length: [Int] -> Int =
  fun xs ->
    case xs
      | [] => 0
      | _::xs => 1 + length(xs) end in

let hd: [Int] -> Int =
  fun l ->
    case l
      | [] => -1
      | x::xs => x end in

let tl: [Int] -> [Int] =
  fun l ->
    case l
      | [] => []
      | x::xs => xs end in

let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
      | [] => true
      | _::_ => false end in

let nth: ([Int], Int) -> Int =
  fun xs, n ->
    case xs, n
      | x::_, 0 => x
      | _::xs, n => nth(xs, n - 1)
      | [], _ => ? end in

let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
      | [] => acc 
      | x::xs => go(xs, x::acc) end in
go(l, []) in

let equal: ((Int, Int) -> Bool, [Int], [Int]) -> Bool =
fun p, xs, ys ->
case xs, ys
  | [], [] => true
  | x::xs, y::ys => p(x, y) && equal(p, xs, ys)
  | _ => false end in

let init: (Int, Int -> Int) -> [Int] =
fun len, f ->
let go: (Int, [Int]) -> [Int] =
fun idx, xs ->
  if idx < len 
    then go(idx + 1, xs @ [f(idx)])   
      else xs in
        go(0, []) in

let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
      | [] => acc
      | hd::tl => fold_left(f, f(acc, hd), tl) end in

let fold_right: ((Int, Int)-> Int, [Int], Int)-> Int =
  fun f, xs, acc ->
    case xs
      | [] => acc
      | hd::tl => f(hd, fold_right(f, tl, acc)) end in

let filter: (Int -> Bool, [Int]) -> [Int] =
  fun p, xs ->
