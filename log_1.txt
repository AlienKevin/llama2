# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward piece is Incomplete Polytile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Syntax: Can insert new right-convex
LSP: Gen: Generating New Token (Convex) Suggestions
  LSP: Info: cls: Empty expression hole
  LSP: Info: sort: Exp
  LSP: Info: ctx: {fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: (((? -> Bool), [?]) -> [?])
  LSP: Info: Error: None
  LSP: Info: Backpack stack: in
  LSP: Base: Backpack suggestion: in
  LSP: Base: Mono Convex Const: _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: cons fold_right( fold_left(
  LSP: Base: Mono Convex Lookahead Vars: 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: 
  LSP: Base: Poly Prefix: ( case  fun  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: Final: (1/1) New right-convex Suggestions: ( _ case  cons fold_left( fold_right( fun  if  let  type 
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "(" | "_" | "case " | "cons" | "fold_left(" | "fold_right(" | "fun " | "if " | "let " | "type "


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "(" | "_" | "case " | "cons" | "fold_left(" | "fold_right(" | "fun " | "if " | "let " | "type "

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward piece is Monotile: <fun>
  LSP: Syntax: No rightwards piece
  LSP: Syntax: Can insert new right-concave or complete left
LSP: Gen: Generating New Token ((Concave 0)) Suggestions
  LSP: Info: cls: Variable reference
  LSP: Info: sort: Exp
  LSP: Info: ctx: {fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: (((? -> Bool), [?]) -> [?])
  LSP: Info: Error: (Exp (FreeVariable "fun"))
  LSP: Info: Backpack stack: in
  LSP: Base: Backpack suggestion: in
  LSP: Base: Mono Convex Const: _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: cons fold_right( fold_left(
  LSP: Base: Mono Convex Lookahead Vars: 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: 
  LSP: Base: Poly Prefix: ( case  fun  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: Gen: Generating Completion Suggestions
  LSP: Info: cls: Variable reference
  LSP: Info: sort: Exp
  LSP: Info: ctx: {fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: (((? -> Bool), [?]) -> [?])
  LSP: Info: Error: (Exp (FreeVariable "fun"))
  LSP: Info: Backpack stack: in
  LSP: Base: Backpack suggestion: in
  LSP: Base: Mono Convex Const: _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: cons fold_right( fold_left(
  LSP: Base: Mono Convex Lookahead Vars: 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: 
  LSP: Base: Poly Prefix: ( case  fun  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: (1/2) New Token Suggestions: ( in |
LSP: (2/2) Completion Suggestions:  
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "(" | "in" | "|" | " "


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "(" | "in" | "|" | " "

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun 

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun 
LSP: Init: String parsed successfully
  LSP: Syntax Inspector: Leftward piece is Secondary; trimming
  LSP: Syntax: Leftward piece is Incomplete Polytile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Syntax: Can insert new right-convex
LSP: Gen: Generating New Token (Convex) Suggestions
  LSP: Info: cls: Empty pattern hole
  LSP: Info: sort: Pat
  LSP: Info: ctx: {filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: ((? -> Bool), [?])
  LSP: Info: Error: None
  LSP: Info: Backpack stack: -> in
  LSP: Base: Backpack suggestion: ->
  LSP: Base: Mono Convex Const: _
  LSP: Base: Mono Convex Abstract: ~PATVAR~
  LSP: Base: Mono Convex Vars: 
  LSP: Base: Mono Convex Lookahead Vars: _ ~PATVAR~ (
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: ,
  LSP: Base: Poly Prefix: (
  LSP: Base: Poly Postfix: (
LSP: Final: (1/1) New right-convex Suggestions: ( _ ~PATVAR~
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "(" | "_" | patvar


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "(" | "_" | patvar

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward piece is Monotile: <xt>
  LSP: Syntax: No rightwards piece
  LSP: Syntax: Can insert new right-concave or complete left
LSP: Gen: Generating New Token ((Concave 0)) Suggestions
  LSP: Info: cls: Variable binding
  LSP: Info: sort: Pat
  LSP: Info: ctx: {xt: ((? -> Bool), [?]), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: ((? -> Bool), [?])
  LSP: Info: Error: None
  LSP: Info: Backpack stack: -> in
  LSP: Base: Backpack suggestion: ->
  LSP: Base: Mono Convex Const: _
  LSP: Base: Mono Convex Abstract: ~PATVAR~
  LSP: Base: Mono Convex Vars: 
  LSP: Base: Mono Convex Lookahead Vars: _ ~PATVAR~ (
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: ,
  LSP: Base: Poly Prefix: (
  LSP: Base: Poly Postfix: (
LSP: Gen: Generating Completion Suggestions
  LSP: Info: cls: Variable binding
  LSP: Info: sort: Pat
  LSP: Info: ctx: {xt: ((? -> Bool), [?]), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: ((? -> Bool), [?])
  LSP: Info: Error: None
  LSP: Info: Backpack stack: -> in
  LSP: Base: Backpack suggestion: ->
  LSP: Base: Mono Convex Const: _
  LSP: Base: Mono Convex Abstract: ~PATVAR~
  LSP: Base: Mono Convex Vars: 
  LSP: Base: Mono Convex Lookahead Vars: _ ~PATVAR~ (
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: ,
  LSP: Base: Poly Prefix: (
  LSP: Base: Poly Postfix: (
LSP: (1/2) New Token Suggestions: ( , ->
LSP: (2/2) Completion Suggestions: 
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "(" | "," | "->"


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "(" | "," | "->"

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward piece is Monotile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Syntax: Can insert new right-convex or complete left
LSP: Gen: Generating New Token (Convex) Suggestions
  LSP: Info: cls: Empty pattern hole
  LSP: Info: sort: Pat
  LSP: Info: ctx: {xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: None
  LSP: Info: Backpack stack: -> in
  LSP: Base: Backpack suggestion: ->
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: ~PATVAR~
  LSP: Base: Mono Convex Vars: 
  LSP: Base: Mono Convex Lookahead Vars: () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: : ::
  LSP: Base: Poly Prefix: ( [
  LSP: Base: Poly Postfix: (
LSP: Gen: Generating Completion Suggestions
  LSP: Info: cls: Tuple
  LSP: Info: sort: Pat
  LSP: Info: ctx: {xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: ((? -> Bool), [?])
  LSP: Info: Error: None
  LSP: Info: Backpack stack: -> in
  LSP: Base: Backpack suggestion: ->
  LSP: Base: Mono Convex Const: _
  LSP: Base: Mono Convex Abstract: ~PATVAR~
  LSP: Base: Mono Convex Vars: 
  LSP: Base: Mono Convex Lookahead Vars: _ ~PATVAR~ (
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: ,
  LSP: Base: Poly Prefix: (
  LSP: Base: Poly Postfix: (
LSP: Final: (1/2) New Token Suggestions: ( () [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Final: (2/2) Completion Suggestions: 
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "(" | "()" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "(" | "()" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward piece is Monotile: <xs>
  LSP: Syntax: No rightwards piece
  LSP: Syntax: Can insert new right-concave or complete left
LSP: Gen: Generating New Token ((Concave 0)) Suggestions
  LSP: Info: cls: Variable binding
  LSP: Info: sort: Pat
  LSP: Info: ctx: {xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: None
  LSP: Info: Backpack stack: -> in
  LSP: Base: Backpack suggestion: ->
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: ~PATVAR~
  LSP: Base: Mono Convex Vars: 
  LSP: Base: Mono Convex Lookahead Vars: () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: : ::
  LSP: Base: Poly Prefix: ( [
  LSP: Base: Poly Postfix: (
LSP: Gen: Generating Completion Suggestions
  LSP: Info: cls: Variable binding
  LSP: Info: sort: Pat
  LSP: Info: ctx: {xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: None
  LSP: Info: Backpack stack: -> in
  LSP: Base: Backpack suggestion: ->
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: ~PATVAR~
  LSP: Base: Mono Convex Vars: 
  LSP: Base: Mono Convex Lookahead Vars: () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: : ::
  LSP: Base: Poly Prefix: ( [
  LSP: Base: Poly Postfix: (
LSP: (1/2) New Token Suggestions: ( -> : ::
LSP: (2/2) Completion Suggestions: 
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "(" | "->" | ":" | "::"


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "(" | "->" | ":" | "::"

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward piece is Complete Polytile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Syntax: Can insert new right-convex
LSP: Gen: Generating New Token (Convex) Suggestions
  LSP: Info: cls: Empty expression hole
  LSP: Info: sort: Exp
  LSP: Info: ctx: {xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: None
  LSP: Info: Backpack stack: in
  LSP: Base: Backpack suggestion: in
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: Final: (1/1) New right-convex Suggestions: ! ( () - [ [] _ case  cons( cons:: false filter( filter:: fold_left( fold_left:: fold_right( fold_right:: fun  if  length:: let  test  true type  xs xs:: xt:: ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "!" | "(" | "()" | "-" | "[" | "[]" | "_" | "case " | "cons(" | "cons::" | "false" | "filter(" | "filter::" | "fold_left(" | "fold_left::" | "fold_right(" | "fold_right::" | "fun " | "if " | "length::" | "let " | "test " | "true" | "type " | "xs" | "xs::" | "xt::" | floatlit | intlit | stringlit


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "!" | "(" | "()" | "-" | "[" | "[]" | "_" | "case " | "cons(" | "cons::" | "false" | "filter(" | "filter::" | "fold_left(" | "fold_left::" | "fold_right(" | "fold_right::" | "fun " | "if " | "length::" | "let " | "test " | "true" | "type " | "xs" | "xs::" | "xt::" | floatlit | intlit | stringlit

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward piece is Monotile: <fold>
  LSP: Syntax: No rightwards piece
  LSP: Syntax: Can insert new right-concave or complete left
LSP: Gen: Generating New Token ((Concave 0)) Suggestions
  LSP: Info: cls: Variable reference
  LSP: Info: sort: Exp
  LSP: Info: ctx: {xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: (Exp (FreeVariable "fold"))
  LSP: Info: Backpack stack: in
  LSP: Base: Backpack suggestion: in
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: Gen: Generating Completion Suggestions
  LSP: Info: cls: Variable reference
  LSP: Info: sort: Exp
  LSP: Info: ctx: {xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: (Exp (FreeVariable "fold"))
  LSP: Info: Backpack stack: in
  LSP: Base: Backpack suggestion: in
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: (1/2) New Token Suggestions: ( :: @ in |
LSP: (2/2) Completion Suggestions: _left( _left:: _right( _right::
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "(" | "::" | "@" | "in" | "|" | "_left(" | "_left::" | "_right(" | "_right::"


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "(" | "::" | "@" | "in" | "|" | "_left(" | "_left::" | "_right(" | "_right::"

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward piece is Monotile: <fold_>
  LSP: Syntax: No rightwards piece
  LSP: Syntax: Can insert new right-concave or complete left
LSP: Gen: Generating New Token ((Concave 0)) Suggestions
  LSP: Info: cls: Variable reference
  LSP: Info: sort: Exp
  LSP: Info: ctx: {xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: (Exp (FreeVariable "fold_"))
  LSP: Info: Backpack stack: in
  LSP: Base: Backpack suggestion: in
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: Gen: Generating Completion Suggestions
  LSP: Info: cls: Variable reference
  LSP: Info: sort: Exp
  LSP: Info: ctx: {xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: (Exp (FreeVariable "fold_"))
  LSP: Info: Backpack stack: in
  LSP: Base: Backpack suggestion: in
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: (1/2) New Token Suggestions: ( :: @ in |
LSP: (2/2) Completion Suggestions: left( left:: right( right::
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "(" | "::" | "@" | "in" | "|" | "left(" | "left::" | "right(" | "right::"


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "(" | "::" | "@" | "in" | "|" | "left(" | "left::" | "right(" | "right::"

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward piece is Monotile: <fold_right>
  LSP: Syntax: No rightwards piece
  LSP: Syntax: Can insert new right-concave or complete left
LSP: Gen: Generating New Token ((Concave 0)) Suggestions
  LSP: Info: cls: Variable reference
  LSP: Info: sort: Exp
  LSP: Info: ctx: {xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (List (Unknown Internal));
           syn =
           (Arrow (
              (Prod
                 [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
                     (Unknown Internal)));
                   (List (Unknown Internal)); (Unknown Internal)]),
              (Unknown Internal)))})))
  LSP: Info: Backpack stack: in
  LSP: Base: Backpack suggestion: in
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: Gen: Generating Completion Suggestions
  LSP: Info: cls: Variable reference
  LSP: Info: sort: Exp
  LSP: Info: ctx: {xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (List (Unknown Internal));
           syn =
           (Arrow (
              (Prod
                 [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
                     (Unknown Internal)));
                   (List (Unknown Internal)); (Unknown Internal)]),
              (Unknown Internal)))})))
  LSP: Info: Backpack stack: in
  LSP: Base: Backpack suggestion: in
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: (1/2) New Token Suggestions: ( :: @ in |
LSP: (2/2) Completion Suggestions: ( ::
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "(" | "::" | "@" | "in" | "|" | "(" | "::"


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "(" | "::" | "@" | "in" | "|" | "(" | "::"

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward piece is Incomplete Polytile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Syntax: Can insert new right-convex
LSP: Gen: Generating New Token (Convex) Suggestions
  LSP: Info: cls: Empty expression hole
  LSP: Info: sort: Exp
  LSP: Info: ctx: {xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: (((?, ?) -> ?), [?], ?)
  LSP: Info: Error: None
  LSP: Info: Backpack stack: ) in
  LSP: Base: Backpack suggestion: )
  LSP: Base: Mono Convex Const: _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: fold_right( fold_left(
  LSP: Base: Mono Convex Lookahead Vars: fold_right( fold_left( xt filter cons _ ( case  fun  if  let  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: 
  LSP: Base: Poly Prefix: ( case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: Final: (1/1) New right-convex Suggestions: ( _ case  cons filter fold_left( fold_right( fun  if  let  type  xt
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "(" | "_" | "case " | "cons" | "filter" | "fold_left(" | "fold_right(" | "fun " | "if " | "let " | "type " | "xt"


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "(" | "_" | "case " | "cons" | "filter" | "fold_left(" | "fold_right(" | "fun " | "if " | "let " | "type " | "xt"

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward piece is Monotile: <fun>
  LSP: Syntax: No rightwards piece
  LSP: Syntax: Can insert new right-concave or complete left
LSP: Gen: Generating New Token ((Concave 0)) Suggestions
  LSP: Info: cls: Variable reference
  LSP: Info: sort: Exp
  LSP: Info: ctx: {xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: (((?, ?) -> ?), [?], ?)
  LSP: Info: Error: (Exp (FreeVariable "fun"))
  LSP: Info: Backpack stack: ) in
  LSP: Base: Backpack suggestion: )
  LSP: Base: Mono Convex Const: _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: fold_right( fold_left(
  LSP: Base: Mono Convex Lookahead Vars: fold_right( fold_left( xt filter cons _ ( case  fun  if  let  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: 
  LSP: Base: Poly Prefix: ( case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: Gen: Generating Completion Suggestions
  LSP: Info: cls: Variable reference
  LSP: Info: sort: Exp
  LSP: Info: ctx: {xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: (((?, ?) -> ?), [?], ?)
  LSP: Info: Error: (Exp (FreeVariable "fun"))
  LSP: Info: Backpack stack: ) in
  LSP: Base: Backpack suggestion: )
  LSP: Base: Mono Convex Const: _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: fold_right( fold_left(
  LSP: Base: Mono Convex Lookahead Vars: fold_right( fold_left( xt filter cons _ ( case  fun  if  let  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: 
  LSP: Base: Poly Prefix: ( case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: (1/2) New Token Suggestions: ( ) |
LSP: (2/2) Completion Suggestions:  
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "(" | ")" | "|" | " "


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "(" | ")" | "|" | " "

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward piece is Incomplete Polytile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Syntax: Can insert new right-convex
LSP: Gen: Generating New Token (Convex) Suggestions
  LSP: Info: cls: Empty pattern hole
  LSP: Info: sort: Pat
  LSP: Info: ctx: {xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: ?
  LSP: Info: Error: None
  LSP: Info: Backpack stack: ) -> ) in
  LSP: Base: Backpack suggestion: )
  LSP: Base: Mono Convex Const: () [] _ false true
  LSP: Base: Mono Convex Abstract: ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~
  LSP: Base: Mono Convex Vars: 
  LSP: Base: Mono Convex Lookahead Vars: 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: , : ::
  LSP: Base: Poly Prefix: ( [
  LSP: Base: Poly Postfix: (
LSP: Final: (1/1) New right-convex Suggestions: ( () [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "(" | "()" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "(" | "()" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward piece is Monotile: <x>
  LSP: Syntax: No rightwards piece
  LSP: Syntax: Can insert new right-concave or complete left
LSP: Gen: Generating New Token ((Concave 0)) Suggestions
  LSP: Info: cls: Variable binding
  LSP: Info: sort: Pat
  LSP: Info: ctx: {x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: ?
  LSP: Info: Error: None
  LSP: Info: Backpack stack: ) -> ) in
  LSP: Base: Backpack suggestion: )
  LSP: Base: Mono Convex Const: () [] _ false true
  LSP: Base: Mono Convex Abstract: ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~
  LSP: Base: Mono Convex Vars: 
  LSP: Base: Mono Convex Lookahead Vars: 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: , : ::
  LSP: Base: Poly Prefix: ( [
  LSP: Base: Poly Postfix: (
LSP: Gen: Generating Completion Suggestions
  LSP: Info: cls: Variable binding
  LSP: Info: sort: Pat
  LSP: Info: ctx: {x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: ?
  LSP: Info: Error: None
  LSP: Info: Backpack stack: ) -> ) in
  LSP: Base: Backpack suggestion: )
  LSP: Base: Mono Convex Const: () [] _ false true
  LSP: Base: Mono Convex Abstract: ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~
  LSP: Base: Mono Convex Vars: 
  LSP: Base: Mono Convex Lookahead Vars: 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: , : ::
  LSP: Base: Poly Prefix: ( [
  LSP: Base: Poly Postfix: (
LSP: (1/2) New Token Suggestions: ( ) , : ::
LSP: (2/2) Completion Suggestions: 
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "(" | ")" | "," | ":" | "::"


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "(" | ")" | "," | ":" | "::"

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward piece is Monotile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Syntax: Can insert new right-convex or complete left
LSP: Gen: Generating New Token (Convex) Suggestions
  LSP: Info: cls: Empty pattern hole
  LSP: Info: sort: Pat
  LSP: Info: ctx: {x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: ?
  LSP: Info: Error: None
  LSP: Info: Backpack stack: ) -> ) in
  LSP: Base: Backpack suggestion: )
  LSP: Base: Mono Convex Const: () [] _ false true
  LSP: Base: Mono Convex Abstract: ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~
  LSP: Base: Mono Convex Vars: 
  LSP: Base: Mono Convex Lookahead Vars: 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: , : ::
  LSP: Base: Poly Prefix: ( [
  LSP: Base: Poly Postfix: (
LSP: Gen: Generating Completion Suggestions
  LSP: Info: cls: Tuple
  LSP: Info: sort: Pat
  LSP: Info: ctx: {x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: ?
  LSP: Info: Error: None
  LSP: Info: Backpack stack: ) -> ) in
  LSP: Base: Backpack suggestion: )
  LSP: Base: Mono Convex Const: () [] _ false true
  LSP: Base: Mono Convex Abstract: ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~
  LSP: Base: Mono Convex Vars: 
  LSP: Base: Mono Convex Lookahead Vars: 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: , : ::
  LSP: Base: Poly Prefix: ( [
  LSP: Base: Poly Postfix: (
LSP: Final: (1/2) New Token Suggestions: ( () [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Final: (2/2) Completion Suggestions: 
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "(" | "()" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "(" | "()" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward piece is Monotile: <y>
  LSP: Syntax: No rightwards piece
  LSP: Syntax: Can insert new right-concave or complete left
LSP: Gen: Generating New Token ((Concave 0)) Suggestions
  LSP: Info: cls: Variable binding
  LSP: Info: sort: Pat
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: ?
  LSP: Info: Error: None
  LSP: Info: Backpack stack: ) -> ) in
  LSP: Base: Backpack suggestion: )
  LSP: Base: Mono Convex Const: () [] _ false true
  LSP: Base: Mono Convex Abstract: ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~
  LSP: Base: Mono Convex Vars: 
  LSP: Base: Mono Convex Lookahead Vars: 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: , : ::
  LSP: Base: Poly Prefix: ( [
  LSP: Base: Poly Postfix: (
LSP: Gen: Generating Completion Suggestions
  LSP: Info: cls: Variable binding
  LSP: Info: sort: Pat
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: ?
  LSP: Info: Error: None
  LSP: Info: Backpack stack: ) -> ) in
  LSP: Base: Backpack suggestion: )
  LSP: Base: Mono Convex Const: () [] _ false true
  LSP: Base: Mono Convex Abstract: ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~
  LSP: Base: Mono Convex Vars: 
  LSP: Base: Mono Convex Lookahead Vars: 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: , : ::
  LSP: Base: Poly Prefix: ( [
  LSP: Base: Poly Postfix: (
LSP: (1/2) New Token Suggestions: ( ) , : ::
LSP: (2/2) Completion Suggestions: 
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "(" | ")" | "," | ":" | "::"


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "(" | ")" | "," | ":" | "::"

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward piece is Complete Polytile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Syntax: Can insert new right-concave
LSP: Gen: Generating New Token ((Concave 0)) Suggestions
  LSP: Info: cls: Parenthesized pattern
  LSP: Info: sort: Pat
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: ?
  LSP: Info: Error: None
  LSP: Info: Backpack stack: -> ) in
  LSP: Base: Backpack suggestion: ->
  LSP: Base: Mono Convex Const: () [] _ false true
  LSP: Base: Mono Convex Abstract: ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~
  LSP: Base: Mono Convex Vars: 
  LSP: Base: Mono Convex Lookahead Vars: 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: , : ::
  LSP: Base: Poly Prefix: ( [
  LSP: Base: Poly Postfix: (
LSP: Final: (1/1) New right-concave Suggestions: ( , -> : ::
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "(" | "," | "->" | ":" | "::"


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "(" | "," | "->" | ":" | "::"

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward piece is Complete Polytile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Syntax: Can insert new right-convex
LSP: Gen: Generating New Token (Convex) Suggestions
  LSP: Info: cls: Empty expression hole
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: ?
  LSP: Info: Error: None
  LSP: Info: Backpack stack: ) in
  LSP: Base: Backpack suggestion: )
  LSP: Base: Mono Convex Const: () [] _ false true
  LSP: Base: Mono Convex Abstract: ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~
  LSP: Base: Mono Convex Vars: y x xs xt filter fold_right fold_left length cons
  LSP: Base: Mono Convex Lookahead Vars: 
  LSP: Base: Mono Prefix: ! -
  LSP: Base: Mono Infix: != !=. $== && * ** **. *. + ++ +. , - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Base: Poly Prefix: ( [ case  fun  if  let  test  type 
  LSP: Base: Poly Postfix: ( |
LSP: Final: (1/1) New right-convex Suggestions: ! ( () - [ [] _ case  cons false filter fold_left fold_right fun  if  length let  test  true type  x xs xt y ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "!" | "(" | "()" | "-" | "[" | "[]" | "_" | "case " | "cons" | "false" | "filter" | "fold_left" | "fold_right" | "fun " | "if " | "length" | "let " | "test " | "true" | "type " | "x" | "xs" | "xt" | "y" | floatlit | intlit | stringlit


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "!" | "(" | "()" | "-" | "[" | "[]" | "_" | "case " | "cons" | "false" | "filter" | "fold_left" | "fold_right" | "fun " | "if " | "length" | "let " | "test " | "true" | "type " | "x" | "xs" | "xt" | "y" | floatlit | intlit | stringlit

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward piece is Monotile: <if>
  LSP: Syntax: No rightwards piece
  LSP: Syntax: Can insert new right-concave or complete left
LSP: Gen: Generating New Token ((Concave 0)) Suggestions
  LSP: Info: cls: Variable reference
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: ?
  LSP: Info: Error: (Exp (FreeVariable "if"))
  LSP: Info: Backpack stack: ) in
  LSP: Base: Backpack suggestion: )
  LSP: Base: Mono Convex Const: () [] _ false true
  LSP: Base: Mono Convex Abstract: ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~
  LSP: Base: Mono Convex Vars: y x xs xt filter fold_right fold_left length cons
  LSP: Base: Mono Convex Lookahead Vars: 
  LSP: Base: Mono Prefix: ! -
  LSP: Base: Mono Infix: != !=. $== && * ** **. *. + ++ +. , - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Base: Poly Prefix: ( [ case  fun  if  let  test  type 
  LSP: Base: Poly Postfix: ( |
LSP: Gen: Generating Completion Suggestions
  LSP: Info: cls: Variable reference
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: ?
  LSP: Info: Error: (Exp (FreeVariable "if"))
  LSP: Info: Backpack stack: ) in
  LSP: Base: Backpack suggestion: )
  LSP: Base: Mono Convex Const: () [] _ false true
  LSP: Base: Mono Convex Abstract: ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~
  LSP: Base: Mono Convex Vars: y x xs xt filter fold_right fold_left length cons
  LSP: Base: Mono Convex Lookahead Vars: 
  LSP: Base: Mono Prefix: ! -
  LSP: Base: Mono Infix: != !=. $== && * ** **. *. + ++ +. , - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Base: Poly Prefix: ( [ case  fun  if  let  test  type 
  LSP: Base: Poly Postfix: ( |
LSP: (1/2) New Token Suggestions: != !=. $== && ( ) * ** **. *. + ++ +. , - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/ |
LSP: (2/2) Completion Suggestions:  
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "|" | " "


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "|" | " "

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if 

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if 
LSP: Init: String parsed successfully
  LSP: Syntax Inspector: Leftward piece is Secondary; trimming
  LSP: Syntax: Leftward piece is Incomplete Polytile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Syntax: Can insert new right-convex
LSP: Gen: Generating New Token (Convex) Suggestions
  LSP: Info: cls: Empty expression hole
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: Bool
  LSP: Info: Error: None
  LSP: Info: Backpack stack: then else ) in
  LSP: Base: Backpack suggestion: then
  LSP: Base: Mono Convex Const: _ false true
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xt( fold_right( fold_left(
  LSP: Base: Mono Convex Lookahead Vars: y x y x y x fold_right( fold_left( length( fold_right( fold_left( fold_right( fold_left(
  LSP: Base: Mono Prefix: !
  LSP: Base: Mono Infix: != !=. $== && < <. <= <=. == ==. > >. >= >=. \/
  LSP: Base: Poly Prefix: ( case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: Final: (1/1) New right-convex Suggestions: ! ( _ case  false fold_left( fold_right( if  length( let  true type  x xt( y
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "!" | "(" | "_" | "case " | "false" | "fold_left(" | "fold_right(" | "if " | "length(" | "let " | "true" | "type " | "x" | "xt(" | "y"


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "!" | "(" | "_" | "case " | "false" | "fold_left(" | "fold_right(" | "if " | "length(" | "let " | "true" | "type " | "x" | "xt(" | "y"

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward piece is Monotile: <xt>
  LSP: Syntax: No rightwards piece
  LSP: Syntax: Can insert new right-concave or complete left
LSP: Gen: Generating New Token ((Concave 0)) Suggestions
  LSP: Info: cls: Variable reference
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: Bool
  LSP: Info: Error: (Exp
   (Common
      (Inconsistent
         Expectation {ana = Bool; syn = (Arrow ((Unknown Internal), Bool))})))
  LSP: Info: Backpack stack: then else ) in
  LSP: Base: Backpack suggestion: then
  LSP: Base: Mono Convex Const: _ false true
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xt( fold_right( fold_left(
  LSP: Base: Mono Convex Lookahead Vars: y x y x y x fold_right( fold_left( length( fold_right( fold_left( fold_right( fold_left(
  LSP: Base: Mono Prefix: !
  LSP: Base: Mono Infix: != !=. $== && < <. <= <=. == ==. > >. >= >=. \/
  LSP: Base: Poly Prefix: ( case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: Gen: Generating Completion Suggestions
  LSP: Info: cls: Variable reference
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: Bool
  LSP: Info: Error: (Exp
   (Common
      (Inconsistent
         Expectation {ana = Bool; syn = (Arrow ((Unknown Internal), Bool))})))
  LSP: Info: Backpack stack: then else ) in
  LSP: Base: Backpack suggestion: then
  LSP: Base: Mono Convex Const: _ false true
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xt( fold_right( fold_left(
  LSP: Base: Mono Convex Lookahead Vars: y x y x y x fold_right( fold_left( length( fold_right( fold_left( fold_right( fold_left(
  LSP: Base: Mono Prefix: !
  LSP: Base: Mono Infix: != !=. $== && < <. <= <=. == ==. > >. >= >=. \/
  LSP: Base: Poly Prefix: ( case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: (1/2) New Token Suggestions: != !=. $== && ( < <. <= <=. == ==. > >. >= >=. \/ then |
LSP: (2/2) Completion Suggestions: (
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "\\/" | "then" | "|" | "("


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "!=" | "!=." | "$==" | "&&" | "(" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "\\/" | "then" | "|" | "("

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward piece is Incomplete Polytile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Syntax: Can insert new right-convex
LSP: Gen: Generating New Token (Convex) Suggestions
  LSP: Info: cls: Empty expression hole
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: ?
  LSP: Info: Error: None
  LSP: Info: Backpack stack: ) then else ) in
  LSP: Base: Backpack suggestion: )
  LSP: Base: Mono Convex Const: () [] _ false true
  LSP: Base: Mono Convex Abstract: ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~
  LSP: Base: Mono Convex Vars: y x xs xt filter fold_right fold_left length cons
  LSP: Base: Mono Convex Lookahead Vars: 
  LSP: Base: Mono Prefix: ! -
  LSP: Base: Mono Infix: != !=. $== && * ** **. *. + ++ +. , - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Base: Poly Prefix: ( [ case  fun  if  let  test  type 
  LSP: Base: Poly Postfix: ( |
LSP: Final: (1/1) New right-convex Suggestions: ! ( () - [ [] _ case  cons false filter fold_left fold_right fun  if  length let  test  true type  x xs xt y ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "!" | "(" | "()" | "-" | "[" | "[]" | "_" | "case " | "cons" | "false" | "filter" | "fold_left" | "fold_right" | "fun " | "if " | "length" | "let " | "test " | "true" | "type " | "x" | "xs" | "xt" | "y" | floatlit | intlit | stringlit


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "!" | "(" | "()" | "-" | "[" | "[]" | "_" | "case " | "cons" | "false" | "filter" | "fold_left" | "fold_right" | "fun " | "if " | "length" | "let " | "test " | "true" | "type " | "x" | "xs" | "xt" | "y" | floatlit | intlit | stringlit

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward piece is Monotile: <x>
  LSP: Syntax: No rightwards piece
  LSP: Syntax: Can insert new right-concave or complete left
LSP: Gen: Generating New Token ((Concave 0)) Suggestions
  LSP: Info: cls: Variable reference
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: ?
  LSP: Info: Error: None
  LSP: Info: Backpack stack: ) then else ) in
  LSP: Base: Backpack suggestion: )
  LSP: Base: Mono Convex Const: () [] _ false true
  LSP: Base: Mono Convex Abstract: ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~
  LSP: Base: Mono Convex Vars: y x xs xt filter fold_right fold_left length cons
  LSP: Base: Mono Convex Lookahead Vars: 
  LSP: Base: Mono Prefix: ! -
  LSP: Base: Mono Infix: != !=. $== && * ** **. *. + ++ +. , - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Base: Poly Prefix: ( [ case  fun  if  let  test  type 
  LSP: Base: Poly Postfix: ( |
LSP: Gen: Generating Completion Suggestions
  LSP: Info: cls: Variable reference
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: ?
  LSP: Info: Error: None
  LSP: Info: Backpack stack: ) then else ) in
  LSP: Base: Backpack suggestion: )
  LSP: Base: Mono Convex Const: () [] _ false true
  LSP: Base: Mono Convex Abstract: ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~
  LSP: Base: Mono Convex Vars: y x xs xt filter fold_right fold_left length cons
  LSP: Base: Mono Convex Lookahead Vars: 
  LSP: Base: Mono Prefix: ! -
  LSP: Base: Mono Infix: != !=. $== && * ** **. *. + ++ +. , - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Base: Poly Prefix: ( [ case  fun  if  let  test  type 
  LSP: Base: Poly Postfix: ( |
LSP: (1/2) New Token Suggestions: != !=. $== && ( ) * ** **. *. + ++ +. , - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/ |
LSP: (2/2) Completion Suggestions: s t
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "|" | "s" | "t"


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "|" | "s" | "t"

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward piece is Complete Polytile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Syntax: Can insert new right-concave
LSP: Gen: Generating New Token ((Concave 0)) Suggestions
  LSP: Info: cls: Application
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: Bool
  LSP: Info: Error: None
  LSP: Info: Backpack stack: then else ) in
  LSP: Base: Backpack suggestion: then
  LSP: Base: Mono Convex Const: _ false true
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xt( fold_right( fold_left(
  LSP: Base: Mono Convex Lookahead Vars: y x y x y x fold_right( fold_left( length( fold_right( fold_left( fold_right( fold_left(
  LSP: Base: Mono Prefix: !
  LSP: Base: Mono Infix: != !=. $== && < <. <= <=. == ==. > >. >= >=. \/
  LSP: Base: Poly Prefix: ( case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: Final: (1/1) New right-concave Suggestions: != !=. $== && ( < <. <= <=. == ==. > >. >= >=. \/ then |
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "\\/" | "then" | "|"


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "!=" | "!=." | "$==" | "&&" | "(" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "\\/" | "then" | "|"

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward piece is Incomplete Polytile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Syntax: Can insert new right-convex
LSP: Gen: Generating New Token (Convex) Suggestions
  LSP: Info: cls: Empty expression hole
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: ?
  LSP: Info: Error: None
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: () [] _ false true
  LSP: Base: Mono Convex Abstract: ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~
  LSP: Base: Mono Convex Vars: y x xs xt filter fold_right fold_left length cons
  LSP: Base: Mono Convex Lookahead Vars: 
  LSP: Base: Mono Prefix: ! -
  LSP: Base: Mono Infix: != !=. $== && * ** **. *. + ++ +. , - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Base: Poly Prefix: ( [ case  fun  if  let  test  type 
  LSP: Base: Poly Postfix: ( |
LSP: Final: (1/1) New right-convex Suggestions: ! ( () - [ [] _ case  cons false filter fold_left fold_right fun  if  length let  test  true type  x xs xt y ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "!" | "(" | "()" | "-" | "[" | "[]" | "_" | "case " | "cons" | "false" | "filter" | "fold_left" | "fold_right" | "fun " | "if " | "length" | "let " | "test " | "true" | "type " | "x" | "xs" | "xt" | "y" | floatlit | intlit | stringlit


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "!" | "(" | "()" | "-" | "[" | "[]" | "_" | "case " | "cons" | "false" | "filter" | "fold_left" | "fold_right" | "fun " | "if " | "length" | "let " | "test " | "true" | "type " | "x" | "xs" | "xt" | "y" | floatlit | intlit | stringlit

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward piece is Incomplete Polytile: <[ ]<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Syntax: Can insert new right-convex
LSP: Gen: Generating New Token (Convex) Suggestions
  LSP: Info: cls: Empty expression hole
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: ?
  LSP: Info: Error: None
  LSP: Info: Backpack stack: ] else ) in
  LSP: Base: Backpack suggestion: ]
  LSP: Base: Mono Convex Const: () [] _ false true
  LSP: Base: Mono Convex Abstract: ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~
  LSP: Base: Mono Convex Vars: y x xs xt filter fold_right fold_left length cons
  LSP: Base: Mono Convex Lookahead Vars: 
  LSP: Base: Mono Prefix: ! -
  LSP: Base: Mono Infix: != !=. $== && * ** **. *. + ++ +. , - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Base: Poly Prefix: ( [ case  fun  if  let  test  type 
  LSP: Base: Poly Postfix: ( |
LSP: Final: (1/1) New right-convex Suggestions: ! ( () - [ [] _ case  cons false filter fold_left fold_right fun  if  length let  test  true type  x xs xt y ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "!" | "(" | "()" | "-" | "[" | "[]" | "_" | "case " | "cons" | "false" | "filter" | "fold_left" | "fold_right" | "fun " | "if " | "length" | "let " | "test " | "true" | "type " | "x" | "xs" | "xt" | "y" | floatlit | intlit | stringlit


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "!" | "(" | "()" | "-" | "[" | "[]" | "_" | "case " | "cons" | "false" | "filter" | "fold_left" | "fold_right" | "fun " | "if " | "length" | "let " | "test " | "true" | "type " | "x" | "xs" | "xt" | "y" | floatlit | intlit | stringlit

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward piece is Monotile: <x>
  LSP: Syntax: No rightwards piece
  LSP: Syntax: Can insert new right-concave or complete left
LSP: Gen: Generating New Token ((Concave 0)) Suggestions
  LSP: Info: cls: Variable reference
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: ?
  LSP: Info: Error: None
  LSP: Info: Backpack stack: ] else ) in
  LSP: Base: Backpack suggestion: ]
  LSP: Base: Mono Convex Const: () [] _ false true
  LSP: Base: Mono Convex Abstract: ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~
  LSP: Base: Mono Convex Vars: y x xs xt filter fold_right fold_left length cons
  LSP: Base: Mono Convex Lookahead Vars: 
  LSP: Base: Mono Prefix: ! -
  LSP: Base: Mono Infix: != !=. $== && * ** **. *. + ++ +. , - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Base: Poly Prefix: ( [ case  fun  if  let  test  type 
  LSP: Base: Poly Postfix: ( |
LSP: Gen: Generating Completion Suggestions
  LSP: Info: cls: Variable reference
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: ?
  LSP: Info: Error: None
  LSP: Info: Backpack stack: ] else ) in
  LSP: Base: Backpack suggestion: ]
  LSP: Base: Mono Convex Const: () [] _ false true
  LSP: Base: Mono Convex Abstract: ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~
  LSP: Base: Mono Convex Vars: y x xs xt filter fold_right fold_left length cons
  LSP: Base: Mono Convex Lookahead Vars: 
  LSP: Base: Mono Prefix: ! -
  LSP: Base: Mono Infix: != !=. $== && * ** **. *. + ++ +. , - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Base: Poly Prefix: ( [ case  fun  if  let  test  type 
  LSP: Base: Poly Postfix: ( |
LSP: (1/2) New Token Suggestions: != !=. $== && ( * ** **. *. + ++ +. , - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/ ] |
LSP: (2/2) Completion Suggestions: s t
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "]" | "|" | "s" | "t"


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "]" | "|" | "s" | "t"

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward piece is Complete Polytile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Syntax: Can insert new right-concave
LSP: Gen: Generating New Token ((Concave 0)) Suggestions
  LSP: Info: cls: List literal
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: ?
  LSP: Info: Error: None
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: () [] _ false true
  LSP: Base: Mono Convex Abstract: ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~
  LSP: Base: Mono Convex Vars: y x xs xt filter fold_right fold_left length cons
  LSP: Base: Mono Convex Lookahead Vars: 
  LSP: Base: Mono Prefix: ! -
  LSP: Base: Mono Infix: != !=. $== && * ** **. *. + ++ +. , - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Base: Poly Prefix: ( [ case  fun  if  let  test  type 
  LSP: Base: Poly Postfix: ( |
LSP: Final: (1/1) New right-concave Suggestions: != !=. $== && ( * ** **. *. + ++ +. , - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/ else |
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "else" | "|"


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "else" | "|"

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward piece is Monotile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Syntax: Can insert new right-convex or complete left
LSP: Gen: Generating New Token (Convex) Suggestions
  LSP: Info: cls: Empty expression hole
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: None
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: y:: x:: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: Gen: Generating Completion Suggestions
  LSP: Info: cls: List Concatenation
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: ?
  LSP: Info: Error: None
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: () [] _ false true
  LSP: Base: Mono Convex Abstract: ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~
  LSP: Base: Mono Convex Vars: y x xs xt filter fold_right fold_left length cons
  LSP: Base: Mono Convex Lookahead Vars: 
  LSP: Base: Mono Prefix: ! -
  LSP: Base: Mono Infix: != !=. $== && * ** **. *. + ++ +. , - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Base: Poly Prefix: ( [ case  fun  if  let  test  type 
  LSP: Base: Poly Postfix: ( |
LSP: Final: (1/2) New Token Suggestions: ! ( () - [ [] _ case  cons( cons:: false filter( filter:: fold_left( fold_left:: fold_right( fold_right:: fun  if  length:: let  test  true type  x x:: xs xs:: xt:: y y:: ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Final: (2/2) Completion Suggestions: 
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "!" | "(" | "()" | "-" | "[" | "[]" | "_" | "case " | "cons(" | "cons::" | "false" | "filter(" | "filter::" | "fold_left(" | "fold_left::" | "fold_right(" | "fold_right::" | "fun " | "if " | "length::" | "let " | "test " | "true" | "type " | "x" | "x::" | "xs" | "xs::" | "xt::" | "y" | "y::" | floatlit | intlit | stringlit


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "!" | "(" | "()" | "-" | "[" | "[]" | "_" | "case " | "cons(" | "cons::" | "false" | "filter(" | "filter::" | "fold_left(" | "fold_left::" | "fold_right(" | "fold_right::" | "fun " | "if " | "length::" | "let " | "test " | "true" | "type " | "x" | "x::" | "xs" | "xs::" | "xt::" | "y" | "y::" | floatlit | intlit | stringlit

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@y

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@y
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward piece is Monotile: <y>
  LSP: Syntax: No rightwards piece
  LSP: Syntax: Can insert new right-concave or complete left
LSP: Gen: Generating New Token ((Concave 0)) Suggestions
  LSP: Info: cls: Variable reference
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: None
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: y:: x:: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: Gen: Generating Completion Suggestions
  LSP: Info: cls: Variable reference
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: None
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: y:: x:: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: (1/2) New Token Suggestions: ( :: @ else |
LSP: (2/2) Completion Suggestions: ::
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "(" | "::" | "@" | "else" | "|" | "::"


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "(" | "::" | "@" | "else" | "|" | "::"

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward piece is Monotile: <yelse>
  LSP: Syntax: No rightwards piece
  LSP: Syntax: Can insert new right-concave or complete left
LSP: Gen: Generating New Token ((Concave 0)) Suggestions
  LSP: Info: cls: Variable reference
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: (Exp (FreeVariable "yelse"))
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: y:: x:: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: Gen: Generating Completion Suggestions
  LSP: Info: cls: Variable reference
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: (Exp (FreeVariable "yelse"))
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: y:: x:: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: (1/2) New Token Suggestions: ( :: @ else |
LSP: (2/2) Completion Suggestions: 
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "(" | "::" | "@" | "else" | "|"


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "(" | "::" | "@" | "else" | "|"

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward piece is Incomplete Polytile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Syntax: Can insert new right-convex
LSP: Gen: Generating New Token (Convex) Suggestions
  LSP: Info: cls: Empty expression hole
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: ?
  LSP: Info: Error: None
  LSP: Info: Backpack stack: ) else ) in
  LSP: Base: Backpack suggestion: )
  LSP: Base: Mono Convex Const: () [] _ false true
  LSP: Base: Mono Convex Abstract: ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~
  LSP: Base: Mono Convex Vars: y x xs xt filter fold_right fold_left length cons
  LSP: Base: Mono Convex Lookahead Vars: 
  LSP: Base: Mono Prefix: ! -
  LSP: Base: Mono Infix: != !=. $== && * ** **. *. + ++ +. , - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Base: Poly Prefix: ( [ case  fun  if  let  test  type 
  LSP: Base: Poly Postfix: ( |
LSP: Final: (1/1) New right-convex Suggestions: ! ( () - [ [] _ case  cons false filter fold_left fold_right fun  if  length let  test  true type  x xs xt y ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "!" | "(" | "()" | "-" | "[" | "[]" | "_" | "case " | "cons" | "false" | "filter" | "fold_left" | "fold_right" | "fun " | "if " | "length" | "let " | "test " | "true" | "type " | "x" | "xs" | "xt" | "y" | floatlit | intlit | stringlit


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "!" | "(" | "()" | "-" | "[" | "[]" | "_" | "case " | "cons" | "false" | "filter" | "fold_left" | "fold_right" | "fun " | "if " | "length" | "let " | "test " | "true" | "type " | "x" | "xs" | "xt" | "y" | floatlit | intlit | stringlit

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward piece is Monotile: <y>
  LSP: Syntax: No rightwards piece
  LSP: Syntax: Can insert new right-concave or complete left
LSP: Gen: Generating New Token ((Concave 0)) Suggestions
  LSP: Info: cls: Variable reference
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: ?
  LSP: Info: Error: None
  LSP: Info: Backpack stack: ) else ) in
  LSP: Base: Backpack suggestion: )
  LSP: Base: Mono Convex Const: () [] _ false true
  LSP: Base: Mono Convex Abstract: ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~
  LSP: Base: Mono Convex Vars: y x xs xt filter fold_right fold_left length cons
  LSP: Base: Mono Convex Lookahead Vars: 
  LSP: Base: Mono Prefix: ! -
  LSP: Base: Mono Infix: != !=. $== && * ** **. *. + ++ +. , - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Base: Poly Prefix: ( [ case  fun  if  let  test  type 
  LSP: Base: Poly Postfix: ( |
LSP: Gen: Generating Completion Suggestions
  LSP: Info: cls: Variable reference
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: ?
  LSP: Info: Error: None
  LSP: Info: Backpack stack: ) else ) in
  LSP: Base: Backpack suggestion: )
  LSP: Base: Mono Convex Const: () [] _ false true
  LSP: Base: Mono Convex Abstract: ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~
  LSP: Base: Mono Convex Vars: y x xs xt filter fold_right fold_left length cons
  LSP: Base: Mono Convex Lookahead Vars: 
  LSP: Base: Mono Prefix: ! -
  LSP: Base: Mono Infix: != !=. $== && * ** **. *. + ++ +. , - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Base: Poly Prefix: ( [ case  fun  if  let  test  type 
  LSP: Base: Poly Postfix: ( |
LSP: (1/2) New Token Suggestions: != !=. $== && ( ) * ** **. *. + ++ +. , - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/ |
LSP: (2/2) Completion Suggestions: 
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "|"


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "|"

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y)

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y)
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward piece is Complete Polytile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Syntax: Can insert new right-concave
LSP: Gen: Generating New Token ((Concave 0)) Suggestions
  LSP: Info: cls: Application
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: None
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: y:: x:: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: Final: (1/1) New right-concave Suggestions: ( :: @ else |
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "(" | "::" | "@" | "else" | "|"


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "(" | "::" | "@" | "else" | "|"

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y)::

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y)::
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward piece is Monotile: >::<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Syntax: Can insert new right-convex or complete left
LSP: Gen: Generating New Token (Convex) Suggestions
  LSP: Info: cls: Empty expression hole
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: None
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: y:: x:: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: Gen: Generating Completion Suggestions
  LSP: Info: cls: Cons
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: ?
  LSP: Info: Error: None
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: () [] _ false true
  LSP: Base: Mono Convex Abstract: ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~
  LSP: Base: Mono Convex Vars: y x xs xt filter fold_right fold_left length cons
  LSP: Base: Mono Convex Lookahead Vars: 
  LSP: Base: Mono Prefix: ! -
  LSP: Base: Mono Infix: != !=. $== && * ** **. *. + ++ +. , - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Base: Poly Prefix: ( [ case  fun  if  let  test  type 
  LSP: Base: Poly Postfix: ( |
LSP: Final: (1/2) New Token Suggestions: ! ( () - [ [] _ case  cons( cons:: false filter( filter:: fold_left( fold_left:: fold_right( fold_right:: fun  if  length:: let  test  true type  x x:: xs xs:: xt:: y y:: ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Final: (2/2) Completion Suggestions: 
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "!" | "(" | "()" | "-" | "[" | "[]" | "_" | "case " | "cons(" | "cons::" | "false" | "filter(" | "filter::" | "fold_left(" | "fold_left::" | "fold_right(" | "fold_right::" | "fun " | "if " | "length::" | "let " | "test " | "true" | "type " | "x" | "x::" | "xs" | "xs::" | "xt::" | "y" | "y::" | floatlit | intlit | stringlit


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "!" | "(" | "()" | "-" | "[" | "[]" | "_" | "case " | "cons(" | "cons::" | "false" | "filter(" | "filter::" | "fold_left(" | "fold_left::" | "fold_right(" | "fold_right::" | "fun " | "if " | "length::" | "let " | "test " | "true" | "type " | "x" | "x::" | "xs" | "xs::" | "xt::" | "y" | "y::" | floatlit | intlit | stringlit

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y)::[]

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y)::[]
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward piece is Monotile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Syntax: Can insert new right-concave or complete left
LSP: Gen: Generating New Token ((Concave 0)) Suggestions
  LSP: Info: cls: List literal
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: None
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: y:: x:: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: Gen: Generating Completion Suggestions
  LSP: Info: cls: List literal
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: None
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: y:: x:: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: (1/2) New Token Suggestions: ( :: @ else |
LSP: (2/2) Completion Suggestions: 
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "(" | "::" | "@" | "else" | "|"


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "(" | "::" | "@" | "else" | "|"

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y)::[]::

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y)::[]::
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward piece is Monotile: >::<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Syntax: Can insert new right-convex or complete left
LSP: Gen: Generating New Token (Convex) Suggestions
  LSP: Info: cls: Empty expression hole
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: None
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: y:: x:: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: Gen: Generating Completion Suggestions
  LSP: Info: cls: Cons
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: None
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: y:: x:: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: Final: (1/2) New Token Suggestions: ! ( () - [ [] _ case  cons( cons:: false filter( filter:: fold_left( fold_left:: fold_right( fold_right:: fun  if  length:: let  test  true type  x x:: xs xs:: xt:: y y:: ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Final: (2/2) Completion Suggestions: 
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "!" | "(" | "()" | "-" | "[" | "[]" | "_" | "case " | "cons(" | "cons::" | "false" | "filter(" | "filter::" | "fold_left(" | "fold_left::" | "fold_right(" | "fold_right::" | "fun " | "if " | "length::" | "let " | "test " | "true" | "type " | "x" | "x::" | "xs" | "xs::" | "xt::" | "y" | "y::" | floatlit | intlit | stringlit


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "!" | "(" | "()" | "-" | "[" | "[]" | "_" | "case " | "cons(" | "cons::" | "false" | "filter(" | "filter::" | "fold_left(" | "fold_left::" | "fold_right(" | "fold_right::" | "fun " | "if " | "length::" | "let " | "test " | "true" | "type " | "x" | "x::" | "xs" | "xs::" | "xt::" | "y" | "y::" | floatlit | intlit | stringlit

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y)::[]::y

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y)::[]::y
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward piece is Monotile: <y>
  LSP: Syntax: No rightwards piece
  LSP: Syntax: Can insert new right-concave or complete left
LSP: Gen: Generating New Token ((Concave 0)) Suggestions
  LSP: Info: cls: Variable reference
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: None
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: y:: x:: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: Gen: Generating Completion Suggestions
  LSP: Info: cls: Variable reference
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: None
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: y:: x:: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: (1/2) New Token Suggestions: ( :: @ else |
LSP: (2/2) Completion Suggestions: ::
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "(" | "::" | "@" | "else" | "|" | "::"


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "(" | "::" | "@" | "else" | "|" | "::"

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y)::[]::y::

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y)::[]::y::
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward piece is Monotile: >::<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Syntax: Can insert new right-convex or complete left
LSP: Gen: Generating New Token (Convex) Suggestions
  LSP: Info: cls: Empty expression hole
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: None
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: y:: x:: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: Gen: Generating Completion Suggestions
  LSP: Info: cls: Cons
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: None
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: y:: x:: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: Final: (1/2) New Token Suggestions: ! ( () - [ [] _ case  cons( cons:: false filter( filter:: fold_left( fold_left:: fold_right( fold_right:: fun  if  length:: let  test  true type  x x:: xs xs:: xt:: y y:: ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Final: (2/2) Completion Suggestions: 
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "!" | "(" | "()" | "-" | "[" | "[]" | "_" | "case " | "cons(" | "cons::" | "false" | "filter(" | "filter::" | "fold_left(" | "fold_left::" | "fold_right(" | "fold_right::" | "fun " | "if " | "length::" | "let " | "test " | "true" | "type " | "x" | "x::" | "xs" | "xs::" | "xt::" | "y" | "y::" | floatlit | intlit | stringlit


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "!" | "(" | "()" | "-" | "[" | "[]" | "_" | "case " | "cons(" | "cons::" | "false" | "filter(" | "filter::" | "fold_left(" | "fold_left::" | "fold_right(" | "fold_right::" | "fun " | "if " | "length::" | "let " | "test " | "true" | "type " | "x" | "x::" | "xs" | "xs::" | "xt::" | "y" | "y::" | floatlit | intlit | stringlit

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y)::[]::y::[

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y)::[]::y::[
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward piece is Incomplete Polytile: <[ ]<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Syntax: Can insert new right-convex
LSP: Gen: Generating New Token (Convex) Suggestions
  LSP: Info: cls: Empty expression hole
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: ?
  LSP: Info: Error: None
  LSP: Info: Backpack stack: ] else ) in
  LSP: Base: Backpack suggestion: ]
  LSP: Base: Mono Convex Const: () [] _ false true
  LSP: Base: Mono Convex Abstract: ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~
  LSP: Base: Mono Convex Vars: y x xs xt filter fold_right fold_left length cons
  LSP: Base: Mono Convex Lookahead Vars: 
  LSP: Base: Mono Prefix: ! -
  LSP: Base: Mono Infix: != !=. $== && * ** **. *. + ++ +. , - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Base: Poly Prefix: ( [ case  fun  if  let  test  type 
  LSP: Base: Poly Postfix: ( |
LSP: Final: (1/1) New right-convex Suggestions: ! ( () - [ [] _ case  cons false filter fold_left fold_right fun  if  length let  test  true type  x xs xt y ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "!" | "(" | "()" | "-" | "[" | "[]" | "_" | "case " | "cons" | "false" | "filter" | "fold_left" | "fold_right" | "fun " | "if " | "length" | "let " | "test " | "true" | "type " | "x" | "xs" | "xt" | "y" | floatlit | intlit | stringlit


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "!" | "(" | "()" | "-" | "[" | "[]" | "_" | "case " | "cons" | "false" | "filter" | "fold_left" | "fold_right" | "fun " | "if " | "length" | "let " | "test " | "true" | "type " | "x" | "xs" | "xt" | "y" | floatlit | intlit | stringlit

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y)::[]::y::[y

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y)::[]::y::[y
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward piece is Monotile: <y>
  LSP: Syntax: No rightwards piece
  LSP: Syntax: Can insert new right-concave or complete left
LSP: Gen: Generating New Token ((Concave 0)) Suggestions
  LSP: Info: cls: Variable reference
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: ?
  LSP: Info: Error: None
  LSP: Info: Backpack stack: ] else ) in
  LSP: Base: Backpack suggestion: ]
  LSP: Base: Mono Convex Const: () [] _ false true
  LSP: Base: Mono Convex Abstract: ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~
  LSP: Base: Mono Convex Vars: y x xs xt filter fold_right fold_left length cons
  LSP: Base: Mono Convex Lookahead Vars: 
  LSP: Base: Mono Prefix: ! -
  LSP: Base: Mono Infix: != !=. $== && * ** **. *. + ++ +. , - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Base: Poly Prefix: ( [ case  fun  if  let  test  type 
  LSP: Base: Poly Postfix: ( |
LSP: Gen: Generating Completion Suggestions
  LSP: Info: cls: Variable reference
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: ?
  LSP: Info: Error: None
  LSP: Info: Backpack stack: ] else ) in
  LSP: Base: Backpack suggestion: ]
  LSP: Base: Mono Convex Const: () [] _ false true
  LSP: Base: Mono Convex Abstract: ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~
  LSP: Base: Mono Convex Vars: y x xs xt filter fold_right fold_left length cons
  LSP: Base: Mono Convex Lookahead Vars: 
  LSP: Base: Mono Prefix: ! -
  LSP: Base: Mono Infix: != !=. $== && * ** **. *. + ++ +. , - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Base: Poly Prefix: ( [ case  fun  if  let  test  type 
  LSP: Base: Poly Postfix: ( |
LSP: (1/2) New Token Suggestions: != !=. $== && ( * ** **. *. + ++ +. , - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/ ] |
LSP: (2/2) Completion Suggestions: 
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "]" | "|"


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "]" | "|"

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y)::[]::y::[y]

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y)::[]::y::[y]
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward piece is Complete Polytile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Syntax: Can insert new right-concave
LSP: Gen: Generating New Token ((Concave 0)) Suggestions
  LSP: Info: cls: List literal
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: None
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: y:: x:: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: Final: (1/1) New right-concave Suggestions: ( :: @ else |
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "(" | "::" | "@" | "else" | "|"


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "(" | "::" | "@" | "else" | "|"

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y)::[]::y::[y]::

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y)::[]::y::[y]::
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward piece is Monotile: >::<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Syntax: Can insert new right-convex or complete left
LSP: Gen: Generating New Token (Convex) Suggestions
  LSP: Info: cls: Empty expression hole
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: None
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: y:: x:: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: Gen: Generating Completion Suggestions
  LSP: Info: cls: Cons
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: None
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: y:: x:: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: Final: (1/2) New Token Suggestions: ! ( () - [ [] _ case  cons( cons:: false filter( filter:: fold_left( fold_left:: fold_right( fold_right:: fun  if  length:: let  test  true type  x x:: xs xs:: xt:: y y:: ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Final: (2/2) Completion Suggestions: 
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "!" | "(" | "()" | "-" | "[" | "[]" | "_" | "case " | "cons(" | "cons::" | "false" | "filter(" | "filter::" | "fold_left(" | "fold_left::" | "fold_right(" | "fold_right::" | "fun " | "if " | "length::" | "let " | "test " | "true" | "type " | "x" | "x::" | "xs" | "xs::" | "xt::" | "y" | "y::" | floatlit | intlit | stringlit


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "!" | "(" | "()" | "-" | "[" | "[]" | "_" | "case " | "cons(" | "cons::" | "false" | "filter(" | "filter::" | "fold_left(" | "fold_left::" | "fold_right(" | "fold_right::" | "fun " | "if " | "length::" | "let " | "test " | "true" | "type " | "x" | "x::" | "xs" | "xs::" | "xt::" | "y" | "y::" | floatlit | intlit | stringlit

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y)::[]::y::[y]::y

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y)::[]::y::[y]::y
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward piece is Monotile: <y>
  LSP: Syntax: No rightwards piece
  LSP: Syntax: Can insert new right-concave or complete left
LSP: Gen: Generating New Token ((Concave 0)) Suggestions
  LSP: Info: cls: Variable reference
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: None
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: y:: x:: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: Gen: Generating Completion Suggestions
  LSP: Info: cls: Variable reference
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: None
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: y:: x:: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: (1/2) New Token Suggestions: ( :: @ else |
LSP: (2/2) Completion Suggestions: ::
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "(" | "::" | "@" | "else" | "|" | "::"


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "(" | "::" | "@" | "else" | "|" | "::"

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y)::[]::y::[y]::y::

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y)::[]::y::[y]::y::
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward piece is Monotile: >::<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Syntax: Can insert new right-convex or complete left
LSP: Gen: Generating New Token (Convex) Suggestions
  LSP: Info: cls: Empty expression hole
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: None
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: y:: x:: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: Gen: Generating Completion Suggestions
  LSP: Info: cls: Cons
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: None
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: y:: x:: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: Final: (1/2) New Token Suggestions: ! ( () - [ [] _ case  cons( cons:: false filter( filter:: fold_left( fold_left:: fold_right( fold_right:: fun  if  length:: let  test  true type  x x:: xs xs:: xt:: y y:: ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Final: (2/2) Completion Suggestions: 
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "!" | "(" | "()" | "-" | "[" | "[]" | "_" | "case " | "cons(" | "cons::" | "false" | "filter(" | "filter::" | "fold_left(" | "fold_left::" | "fold_right(" | "fold_right::" | "fun " | "if " | "length::" | "let " | "test " | "true" | "type " | "x" | "x::" | "xs" | "xs::" | "xt::" | "y" | "y::" | floatlit | intlit | stringlit


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "!" | "(" | "()" | "-" | "[" | "[]" | "_" | "case " | "cons(" | "cons::" | "false" | "filter(" | "filter::" | "fold_left(" | "fold_left::" | "fold_right(" | "fold_right::" | "fun " | "if " | "length::" | "let " | "test " | "true" | "type " | "x" | "x::" | "xs" | "xs::" | "xt::" | "y" | "y::" | floatlit | intlit | stringlit

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y)::[]::y::[y]::y::[]

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y)::[]::y::[y]::y::[]
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward piece is Monotile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Syntax: Can insert new right-concave or complete left
LSP: Gen: Generating New Token ((Concave 0)) Suggestions
  LSP: Info: cls: List literal
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: None
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: y:: x:: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: Gen: Generating Completion Suggestions
  LSP: Info: cls: List literal
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: None
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: y:: x:: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: (1/2) New Token Suggestions: ( :: @ else |
LSP: (2/2) Completion Suggestions: 
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "(" | "::" | "@" | "else" | "|"


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "(" | "::" | "@" | "else" | "|"

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y)::[]::y::[y]::y::[]::

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y)::[]::y::[y]::y::[]::
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward piece is Monotile: >::<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Syntax: Can insert new right-convex or complete left
LSP: Gen: Generating New Token (Convex) Suggestions
  LSP: Info: cls: Empty expression hole
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: None
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: y:: x:: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: Gen: Generating Completion Suggestions
  LSP: Info: cls: Cons
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: None
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: y:: x:: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: Final: (1/2) New Token Suggestions: ! ( () - [ [] _ case  cons( cons:: false filter( filter:: fold_left( fold_left:: fold_right( fold_right:: fun  if  length:: let  test  true type  x x:: xs xs:: xt:: y y:: ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Final: (2/2) Completion Suggestions: 
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "!" | "(" | "()" | "-" | "[" | "[]" | "_" | "case " | "cons(" | "cons::" | "false" | "filter(" | "filter::" | "fold_left(" | "fold_left::" | "fold_right(" | "fold_right::" | "fun " | "if " | "length::" | "let " | "test " | "true" | "type " | "x" | "x::" | "xs" | "xs::" | "xt::" | "y" | "y::" | floatlit | intlit | stringlit


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "!" | "(" | "()" | "-" | "[" | "[]" | "_" | "case " | "cons(" | "cons::" | "false" | "filter(" | "filter::" | "fold_left(" | "fold_left::" | "fold_right(" | "fold_right::" | "fun " | "if " | "length::" | "let " | "test " | "true" | "type " | "x" | "x::" | "xs" | "xs::" | "xt::" | "y" | "y::" | floatlit | intlit | stringlit

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y)::[]::y::[y]::y::[]::y

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y)::[]::y::[y]::y::[]::y
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward piece is Monotile: <y>
  LSP: Syntax: No rightwards piece
  LSP: Syntax: Can insert new right-concave or complete left
LSP: Gen: Generating New Token ((Concave 0)) Suggestions
  LSP: Info: cls: Variable reference
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: None
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: y:: x:: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: Gen: Generating Completion Suggestions
  LSP: Info: cls: Variable reference
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: None
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: y:: x:: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: (1/2) New Token Suggestions: ( :: @ else |
LSP: (2/2) Completion Suggestions: ::
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "(" | "::" | "@" | "else" | "|" | "::"


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "(" | "::" | "@" | "else" | "|" | "::"

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y)::[]::y::[y]::y::[]::y::

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y)::[]::y::[y]::y::[]::y::
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward piece is Monotile: >::<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Syntax: Can insert new right-convex or complete left
LSP: Gen: Generating New Token (Convex) Suggestions
  LSP: Info: cls: Empty expression hole
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: None
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: y:: x:: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: Gen: Generating Completion Suggestions
  LSP: Info: cls: Cons
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: None
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: y:: x:: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: Final: (1/2) New Token Suggestions: ! ( () - [ [] _ case  cons( cons:: false filter( filter:: fold_left( fold_left:: fold_right( fold_right:: fun  if  length:: let  test  true type  x x:: xs xs:: xt:: y y:: ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Final: (2/2) Completion Suggestions: 
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "!" | "(" | "()" | "-" | "[" | "[]" | "_" | "case " | "cons(" | "cons::" | "false" | "filter(" | "filter::" | "fold_left(" | "fold_left::" | "fold_right(" | "fold_right::" | "fun " | "if " | "length::" | "let " | "test " | "true" | "type " | "x" | "x::" | "xs" | "xs::" | "xt::" | "y" | "y::" | floatlit | intlit | stringlit


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "!" | "(" | "()" | "-" | "[" | "[]" | "_" | "case " | "cons(" | "cons::" | "false" | "filter(" | "filter::" | "fold_left(" | "fold_left::" | "fold_right(" | "fold_right::" | "fun " | "if " | "length::" | "let " | "test " | "true" | "type " | "x" | "x::" | "xs" | "xs::" | "xt::" | "y" | "y::" | floatlit | intlit | stringlit

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y)::[]::y::[y]::y::[]::y::[]

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y)::[]::y::[y]::y::[]::y::[]
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward piece is Monotile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Syntax: Can insert new right-concave or complete left
LSP: Gen: Generating New Token ((Concave 0)) Suggestions
  LSP: Info: cls: List literal
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: None
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: y:: x:: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: Gen: Generating Completion Suggestions
  LSP: Info: cls: List literal
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: None
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: y:: x:: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: (1/2) New Token Suggestions: ( :: @ else |
LSP: (2/2) Completion Suggestions: 
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "(" | "::" | "@" | "else" | "|"


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "(" | "::" | "@" | "else" | "|"

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y)::[]::y::[y]::y::[]::y::[]::

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y)::[]::y::[y]::y::[]::y::[]::
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward piece is Monotile: >::<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Syntax: Can insert new right-convex or complete left
LSP: Gen: Generating New Token (Convex) Suggestions
  LSP: Info: cls: Empty expression hole
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: None
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: y:: x:: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: Gen: Generating Completion Suggestions
  LSP: Info: cls: Cons
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: None
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: y:: x:: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: Final: (1/2) New Token Suggestions: ! ( () - [ [] _ case  cons( cons:: false filter( filter:: fold_left( fold_left:: fold_right( fold_right:: fun  if  length:: let  test  true type  x x:: xs xs:: xt:: y y:: ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Final: (2/2) Completion Suggestions: 
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "!" | "(" | "()" | "-" | "[" | "[]" | "_" | "case " | "cons(" | "cons::" | "false" | "filter(" | "filter::" | "fold_left(" | "fold_left::" | "fold_right(" | "fold_right::" | "fun " | "if " | "length::" | "let " | "test " | "true" | "type " | "x" | "x::" | "xs" | "xs::" | "xt::" | "y" | "y::" | floatlit | intlit | stringlit


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "!" | "(" | "()" | "-" | "[" | "[]" | "_" | "case " | "cons(" | "cons::" | "false" | "filter(" | "filter::" | "fold_left(" | "fold_left::" | "fold_right(" | "fold_right::" | "fun " | "if " | "length::" | "let " | "test " | "true" | "type " | "x" | "x::" | "xs" | "xs::" | "xt::" | "y" | "y::" | floatlit | intlit | stringlit

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y)::[]::y::[y]::y::[]::y::[]::[]

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y)::[]::y::[y]::y::[]::y::[]::[]
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward piece is Monotile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Syntax: Can insert new right-concave or complete left
LSP: Gen: Generating New Token ((Concave 0)) Suggestions
  LSP: Info: cls: List literal
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: None
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: y:: x:: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: Gen: Generating Completion Suggestions
  LSP: Info: cls: List literal
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: None
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: y:: x:: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: (1/2) New Token Suggestions: ( :: @ else |
LSP: (2/2) Completion Suggestions: 
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "(" | "::" | "@" | "else" | "|"


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "(" | "::" | "@" | "else" | "|"

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y)::[]::y::[y]::y::[]::y::[]::[]::

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y)::[]::y::[y]::y::[]::y::[]::[]::
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward piece is Monotile: >::<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Syntax: Can insert new right-convex or complete left
LSP: Gen: Generating New Token (Convex) Suggestions
  LSP: Info: cls: Empty expression hole
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: None
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: y:: x:: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: Gen: Generating Completion Suggestions
  LSP: Info: cls: Cons
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: None
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: y:: x:: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: Final: (1/2) New Token Suggestions: ! ( () - [ [] _ case  cons( cons:: false filter( filter:: fold_left( fold_left:: fold_right( fold_right:: fun  if  length:: let  test  true type  x x:: xs xs:: xt:: y y:: ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Final: (2/2) Completion Suggestions: 
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "!" | "(" | "()" | "-" | "[" | "[]" | "_" | "case " | "cons(" | "cons::" | "false" | "filter(" | "filter::" | "fold_left(" | "fold_left::" | "fold_right(" | "fold_right::" | "fun " | "if " | "length::" | "let " | "test " | "true" | "type " | "x" | "x::" | "xs" | "xs::" | "xt::" | "y" | "y::" | floatlit | intlit | stringlit


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "!" | "(" | "()" | "-" | "[" | "[]" | "_" | "case " | "cons(" | "cons::" | "false" | "filter(" | "filter::" | "fold_left(" | "fold_left::" | "fold_right(" | "fold_right::" | "fun " | "if " | "length::" | "let " | "test " | "true" | "type " | "x" | "x::" | "xs" | "xs::" | "xt::" | "y" | "y::" | floatlit | intlit | stringlit

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y)::[]::y::[y]::y::[]::y::[]::[]::y

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y)::[]::y::[y]::y::[]::y::[]::[]::y
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward piece is Monotile: <y>
  LSP: Syntax: No rightwards piece
  LSP: Syntax: Can insert new right-concave or complete left
LSP: Gen: Generating New Token ((Concave 0)) Suggestions
  LSP: Info: cls: Variable reference
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: None
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: y:: x:: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: Gen: Generating Completion Suggestions
  LSP: Info: cls: Variable reference
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: None
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: y:: x:: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: (1/2) New Token Suggestions: ( :: @ else |
LSP: (2/2) Completion Suggestions: ::
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "(" | "::" | "@" | "else" | "|" | "::"


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "(" | "::" | "@" | "else" | "|" | "::"

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y)::[]::y::[y]::y::[]::y::[]::[]::y::

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y)::[]::y::[y]::y::[]::y::[]::[]::y::
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward piece is Monotile: >::<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Syntax: Can insert new right-convex or complete left
LSP: Gen: Generating New Token (Convex) Suggestions
  LSP: Info: cls: Empty expression hole
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: None
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: y:: x:: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: Gen: Generating Completion Suggestions
  LSP: Info: cls: Cons
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: None
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: y:: x:: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: Final: (1/2) New Token Suggestions: ! ( () - [ [] _ case  cons( cons:: false filter( filter:: fold_left( fold_left:: fold_right( fold_right:: fun  if  length:: let  test  true type  x x:: xs xs:: xt:: y y:: ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Final: (2/2) Completion Suggestions: 
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "!" | "(" | "()" | "-" | "[" | "[]" | "_" | "case " | "cons(" | "cons::" | "false" | "filter(" | "filter::" | "fold_left(" | "fold_left::" | "fold_right(" | "fold_right::" | "fun " | "if " | "length::" | "let " | "test " | "true" | "type " | "x" | "x::" | "xs" | "xs::" | "xt::" | "y" | "y::" | floatlit | intlit | stringlit


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "!" | "(" | "()" | "-" | "[" | "[]" | "_" | "case " | "cons(" | "cons::" | "false" | "filter(" | "filter::" | "fold_left(" | "fold_left::" | "fold_right(" | "fold_right::" | "fun " | "if " | "length::" | "let " | "test " | "true" | "type " | "x" | "x::" | "xs" | "xs::" | "xt::" | "y" | "y::" | floatlit | intlit | stringlit

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y)::[]::y::[y]::y::[]::y::[]::[]::y::y

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y)::[]::y::[y]::y::[]::y::[]::[]::y::y
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward piece is Monotile: <y>
  LSP: Syntax: No rightwards piece
  LSP: Syntax: Can insert new right-concave or complete left
LSP: Gen: Generating New Token ((Concave 0)) Suggestions
  LSP: Info: cls: Variable reference
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: None
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: y:: x:: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: Gen: Generating Completion Suggestions
  LSP: Info: cls: Variable reference
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: None
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: y:: x:: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: (1/2) New Token Suggestions: ( :: @ else |
LSP: (2/2) Completion Suggestions: ::
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "(" | "::" | "@" | "else" | "|" | "::"


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "(" | "::" | "@" | "else" | "|" | "::"

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y)::[]::y::[y]::y::[]::y::[]::[]::y::y::

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y)::[]::y::[y]::y::[]::y::[]::[]::y::y::
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward piece is Monotile: >::<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Syntax: Can insert new right-convex or complete left
LSP: Gen: Generating New Token (Convex) Suggestions
  LSP: Info: cls: Empty expression hole
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: None
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: y:: x:: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: Gen: Generating Completion Suggestions
  LSP: Info: cls: Cons
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: None
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: y:: x:: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: Final: (1/2) New Token Suggestions: ! ( () - [ [] _ case  cons( cons:: false filter( filter:: fold_left( fold_left:: fold_right( fold_right:: fun  if  length:: let  test  true type  x x:: xs xs:: xt:: y y:: ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Final: (2/2) Completion Suggestions: 
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "!" | "(" | "()" | "-" | "[" | "[]" | "_" | "case " | "cons(" | "cons::" | "false" | "filter(" | "filter::" | "fold_left(" | "fold_left::" | "fold_right(" | "fold_right::" | "fun " | "if " | "length::" | "let " | "test " | "true" | "type " | "x" | "x::" | "xs" | "xs::" | "xt::" | "y" | "y::" | floatlit | intlit | stringlit


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "!" | "(" | "()" | "-" | "[" | "[]" | "_" | "case " | "cons(" | "cons::" | "false" | "filter(" | "filter::" | "fold_left(" | "fold_left::" | "fold_right(" | "fold_right::" | "fun " | "if " | "length::" | "let " | "test " | "true" | "type " | "x" | "x::" | "xs" | "xs::" | "xt::" | "y" | "y::" | floatlit | intlit | stringlit

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y)::[]::y::[y]::y::[]::y::[]::[]::y::y::[]

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y)::[]::y::[y]::y::[]::y::[]::[]::y::y::[]
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward piece is Monotile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Syntax: Can insert new right-concave or complete left
LSP: Gen: Generating New Token ((Concave 0)) Suggestions
  LSP: Info: cls: List literal
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: None
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: y:: x:: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: Gen: Generating Completion Suggestions
  LSP: Info: cls: List literal
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: None
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: y:: x:: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: (1/2) New Token Suggestions: ( :: @ else |
LSP: (2/2) Completion Suggestions: 
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "(" | "::" | "@" | "else" | "|"


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "(" | "::" | "@" | "else" | "|"

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y)::[]::y::[y]::y::[]::y::[]::[]::y::y::[]::

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y)::[]::y::[y]::y::[]::y::[]::[]::y::y::[]::
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward piece is Monotile: >::<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Syntax: Can insert new right-convex or complete left
LSP: Gen: Generating New Token (Convex) Suggestions
  LSP: Info: cls: Empty expression hole
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: None
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: y:: x:: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: Gen: Generating Completion Suggestions
  LSP: Info: cls: Cons
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: None
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: y:: x:: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: Final: (1/2) New Token Suggestions: ! ( () - [ [] _ case  cons( cons:: false filter( filter:: fold_left( fold_left:: fold_right( fold_right:: fun  if  length:: let  test  true type  x x:: xs xs:: xt:: y y:: ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Final: (2/2) Completion Suggestions: 
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "!" | "(" | "()" | "-" | "[" | "[]" | "_" | "case " | "cons(" | "cons::" | "false" | "filter(" | "filter::" | "fold_left(" | "fold_left::" | "fold_right(" | "fold_right::" | "fun " | "if " | "length::" | "let " | "test " | "true" | "type " | "x" | "x::" | "xs" | "xs::" | "xt::" | "y" | "y::" | floatlit | intlit | stringlit


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "!" | "(" | "()" | "-" | "[" | "[]" | "_" | "case " | "cons(" | "cons::" | "false" | "filter(" | "filter::" | "fold_left(" | "fold_left::" | "fold_right(" | "fold_right::" | "fun " | "if " | "length::" | "let " | "test " | "true" | "type " | "x" | "x::" | "xs" | "xs::" | "xt::" | "y" | "y::" | floatlit | intlit | stringlit

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y)::[]::y::[y]::y::[]::y::[]::[]::y::y::[]::y

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y)::[]::y::[y]::y::[]::y::[]::[]::y::y::[]::y
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward piece is Monotile: <y>
  LSP: Syntax: No rightwards piece
  LSP: Syntax: Can insert new right-concave or complete left
LSP: Gen: Generating New Token ((Concave 0)) Suggestions
  LSP: Info: cls: Variable reference
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: None
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: y:: x:: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: Gen: Generating Completion Suggestions
  LSP: Info: cls: Variable reference
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: None
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: y:: x:: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: (1/2) New Token Suggestions: ( :: @ else |
LSP: (2/2) Completion Suggestions: ::
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "(" | "::" | "@" | "else" | "|" | "::"


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "(" | "::" | "@" | "else" | "|" | "::"

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y)::[]::y::[y]::y::[]::y::[]::[]::y::y::[]::y::

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y)::[]::y::[y]::y::[]::y::[]::[]::y::y::[]::y::
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward piece is Monotile: >::<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Syntax: Can insert new right-convex or complete left
LSP: Gen: Generating New Token (Convex) Suggestions
  LSP: Info: cls: Empty expression hole
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: None
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: y:: x:: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: Gen: Generating Completion Suggestions
  LSP: Info: cls: Cons
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: None
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: y:: x:: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: Final: (1/2) New Token Suggestions: ! ( () - [ [] _ case  cons( cons:: false filter( filter:: fold_left( fold_left:: fold_right( fold_right:: fun  if  length:: let  test  true type  x x:: xs xs:: xt:: y y:: ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Final: (2/2) Completion Suggestions: 
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "!" | "(" | "()" | "-" | "[" | "[]" | "_" | "case " | "cons(" | "cons::" | "false" | "filter(" | "filter::" | "fold_left(" | "fold_left::" | "fold_right(" | "fold_right::" | "fun " | "if " | "length::" | "let " | "test " | "true" | "type " | "x" | "x::" | "xs" | "xs::" | "xt::" | "y" | "y::" | floatlit | intlit | stringlit


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "!" | "(" | "()" | "-" | "[" | "[]" | "_" | "case " | "cons(" | "cons::" | "false" | "filter(" | "filter::" | "fold_left(" | "fold_left::" | "fold_right(" | "fold_right::" | "fun " | "if " | "length::" | "let " | "test " | "true" | "type " | "x" | "x::" | "xs" | "xs::" | "xt::" | "y" | "y::" | floatlit | intlit | stringlit

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y)::[]::y::[y]::y::[]::y::[]::[]::y::y::[]::y::y

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y)::[]::y::[y]::y::[]::y::[]::[]::y::y::[]::y::y
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward piece is Monotile: <y>
  LSP: Syntax: No rightwards piece
  LSP: Syntax: Can insert new right-concave or complete left
LSP: Gen: Generating New Token ((Concave 0)) Suggestions
  LSP: Info: cls: Variable reference
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: None
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: y:: x:: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: Gen: Generating Completion Suggestions
  LSP: Info: cls: Variable reference
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: None
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: y:: x:: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: (1/2) New Token Suggestions: ( :: @ else |
LSP: (2/2) Completion Suggestions: ::
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "(" | "::" | "@" | "else" | "|" | "::"


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "(" | "::" | "@" | "else" | "|" | "::"

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y)::[]::y::[y]::y::[]::y::[]::[]::y::y::[]::y::y::

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y)::[]::y::[y]::y::[]::y::[]::[]::y::y::[]::y::y::
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward piece is Monotile: >::<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Syntax: Can insert new right-convex or complete left
LSP: Gen: Generating New Token (Convex) Suggestions
  LSP: Info: cls: Empty expression hole
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: None
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: y:: x:: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: Gen: Generating Completion Suggestions
  LSP: Info: cls: Cons
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: None
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: y:: x:: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: Final: (1/2) New Token Suggestions: ! ( () - [ [] _ case  cons( cons:: false filter( filter:: fold_left( fold_left:: fold_right( fold_right:: fun  if  length:: let  test  true type  x x:: xs xs:: xt:: y y:: ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Final: (2/2) Completion Suggestions: 
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "!" | "(" | "()" | "-" | "[" | "[]" | "_" | "case " | "cons(" | "cons::" | "false" | "filter(" | "filter::" | "fold_left(" | "fold_left::" | "fold_right(" | "fold_right::" | "fun " | "if " | "length::" | "let " | "test " | "true" | "type " | "x" | "x::" | "xs" | "xs::" | "xt::" | "y" | "y::" | floatlit | intlit | stringlit


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "!" | "(" | "()" | "-" | "[" | "[]" | "_" | "case " | "cons(" | "cons::" | "false" | "filter(" | "filter::" | "fold_left(" | "fold_left::" | "fold_right(" | "fold_right::" | "fun " | "if " | "length::" | "let " | "test " | "true" | "type " | "x" | "x::" | "xs" | "xs::" | "xt::" | "y" | "y::" | floatlit | intlit | stringlit

# Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y)::[]::y::[y]::y::[]::y::[]::[]::y::y::[]::y::y::[]

====


Grammar:
LSP: Init: Recieved string: # Add an element to the front of a list. #
let cons: (a, [a]) -> [a] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [a] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Reduce a list from the left. #
let fold_left: ((b, a) -> b, b, [a]) -> b =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((a, b) -> b, [a], b) -> b =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let filter: (a -> Bool, [a]) -> [a] =fun xt,xs->fold_right(fun(x,y)->if xt(x)then[x]@yelse(y)::[]::y::[y]::y::[]::y::[]::[]::y::y::[]::y::y::[]
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward piece is Monotile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Syntax: Can insert new right-concave or complete left
LSP: Gen: Generating New Token ((Concave 0)) Suggestions
  LSP: Info: cls: List literal
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: None
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: y:: x:: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: Gen: Generating Completion Suggestions
  LSP: Info: cls: List literal
  LSP: Info: sort: Exp
  LSP: Info: ctx: {y: ?, x: ?, xs: [?], xt: (? -> Bool), filter: (((? -> Bool), [?]) -> [?]), fold_right: ((((?, ?) -> ?), [?], ?) -> ?), fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), length: ([?] -> Int), cons: ((?, [?]) -> [?])}
  LSP: Info: Expected type: [?]
  LSP: Info: Error: None
  LSP: Info: Backpack stack: else ) in
  LSP: Base: Backpack suggestion: else
  LSP: Base: Mono Convex Const: [] _
  LSP: Base: Mono Convex Abstract: 
  LSP: Base: Mono Convex Vars: y x xs filter( fold_right( fold_left( cons(
  LSP: Base: Mono Convex Lookahead Vars: y:: x:: xs:: xt:: filter:: fold_right:: fold_left:: length:: cons:: () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Base: Mono Prefix: 
  LSP: Base: Mono Infix: :: @
  LSP: Base: Poly Prefix: ( [ case  if  let  type 
  LSP: Base: Poly Postfix: ( |
LSP: (1/2) New Token Suggestions: ( :: @ else |
LSP: (2/2) Completion Suggestions: 
LSP: Grammar:
 
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::= whitespace | "(" | "::" | "@" | "else" | "|"


Fixed Grammar:
intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
stringlit ::= "\"" [^"]* "\""
patvar ::= [a-zA-Z_][a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
whitespace ::= [ \n]+

root ::=  "(" | "::" | "@" | "else" | "|"

